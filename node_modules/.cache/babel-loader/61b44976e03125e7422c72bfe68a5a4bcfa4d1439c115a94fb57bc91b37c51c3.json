{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport { warn, getNode, watchRegistry, isNode, sugar, isDOM, isComponent as isComponent$1, isConditional, compile, error, createConfig, clearErrors, setErrors, submitForm, reset, createNode, createMessage, createClasses, generateClassList } from '@formkit/core';\nexport { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\nimport { defineComponent, getCurrentInstance, watch, watchEffect, reactive, ref, isRef, createTextVNode, resolveComponent, h, isReactive, toRaw, inject, computed, provide, toRef, onBeforeUnmount, markRaw, nextTick, triggerRef } from 'vue';\nimport { has, isPojo, cloneAny, extend, camel, kebab, nodeProps, only, except, undefine, slugify, isObject, token, empty, eq, shallowClone } from '@formkit/utils';\nimport { createSection, useSchema, createLibraryPlugin, inputs } from '@formkit/inputs';\nimport * as defaultRules from '@formkit/rules';\nimport { createValidationPlugin } from '@formkit/validation';\nimport { createI18nPlugin, en } from '@formkit/i18n';\nimport { createThemePlugin, createIconHandler } from '@formkit/themes';\nimport { createObserver } from '@formkit/observer';\nimport '@formkit/dev';\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo = {};\n/**\n * This symbol represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey;\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance symbol. For example data from: for-loop instances and slot data.\n */\nconst instanceScopes = new Map();\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__';\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(token, data) {\n  const value = ref(null);\n  if (token === 'get') {\n    const nodeRefs = {};\n    value.value = get$1.bind(null, nodeRefs);\n    return value;\n  }\n  const path = token.split('.');\n  watchEffect(() => {\n    value.value = getValue(isRef(data) ? data.value : data, path);\n  });\n  return value;\n}\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(set, path) {\n  if (Array.isArray(set)) {\n    for (const subset of set) {\n      const value = subset !== false && getValue(subset, path);\n      if (value !== undefined) return value;\n    }\n    return undefined;\n  }\n  let foundValue = undefined;\n  let obj = set;\n  for (const i in path) {\n    const key = path[i];\n    if (typeof obj !== 'object' || obj === null) {\n      foundValue = undefined;\n      break;\n    }\n    const currentValue = obj[key];\n    if (Number(i) === path.length - 1 && currentValue !== undefined) {\n      // When the value is a function, we need to bind the `this` value\n      // before providing this back to the compiler.\n      foundValue = typeof currentValue === 'function' ? currentValue.bind(obj) : currentValue;\n      break;\n    }\n    obj = currentValue;\n  }\n  return foundValue;\n}\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get$1(nodeRefs, id) {\n  if (typeof id !== 'string') return warn(650);\n  if (!(id in nodeRefs)) nodeRefs[id] = ref(undefined);\n  if (nodeRefs[id].value === undefined) {\n    nodeRefs[id].value = null;\n    const root = getNode(id);\n    if (root) nodeRefs[id].value = root.context;\n    watchRegistry(id, ({\n      payload: node\n    }) => {\n      nodeRefs[id].value = isNode(node) ? node.context : node;\n    });\n  }\n  return nodeRefs[id].value;\n}\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(library, schema) {\n  /**\n   * Given an if/then/else schema node, pre-compile the node and return the\n   * artifacts for the render function.\n   * @param data - The schema context object\n   * @param library - The available components\n   * @param node - The node to parse\n   */\n  function parseCondition(library, node) {\n    const condition = provider(compile(node.if), {\n      if: true\n    });\n    const children = createElements(library, node.then);\n    const alternate = node.else ? createElements(library, node.else) : null;\n    return [condition, children, alternate];\n  }\n  /**\n   * Parses a conditional if/then/else attribute statement.\n   * @param data - The data object\n   * @param attr - The attribute\n   * @param _default - The default value\n   * @returns\n   */\n  function parseConditionAttr(attr, _default) {\n    var _a, _b;\n    const condition = provider(compile(attr.if));\n    let b = () => _default;\n    let a = () => _default;\n    if (typeof attr.then === 'object') {\n      a = parseAttrs(attr.then, undefined);\n    } else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {\n      a = provider(compile(attr.then));\n    } else {\n      a = () => attr.then;\n    }\n    if (has(attr, 'else')) {\n      if (typeof attr.else === 'object') {\n        b = parseAttrs(attr.else);\n      } else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {\n        b = provider(compile(attr.else));\n      } else {\n        b = () => attr.else;\n      }\n    }\n    return () => condition() ? a() : b();\n  }\n  /**\n   * Parse attributes for dynamic content.\n   * @param attrs - Object of attributes\n   * @returns\n   */\n  function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n    const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\n    const setters = [attrs => {\n      const bound = boundAttrs();\n      for (const attr in bound) {\n        if (!explicitAttrs.has(attr)) {\n          attrs[attr] = bound[attr];\n        }\n      }\n    }];\n    if (unparsedAttrs) {\n      if (isConditional(unparsedAttrs)) {\n        // This is a root conditional object that must produce an object of\n        // attributes.\n        const condition = parseConditionAttr(unparsedAttrs, _default);\n        return condition;\n      }\n      // Some attributes are explicitly bound, we need to parse those ones\n      // using the compiler and create a dynamic \"setter\".\n      for (let attr in unparsedAttrs) {\n        const value = unparsedAttrs[attr];\n        let getValue;\n        const isStr = typeof value === 'string';\n        if (attr.startsWith(raw)) {\n          // attributes prefixed with __raw__ should not be parsed\n          attr = attr.substring(7);\n          getValue = () => value;\n        } else if (isStr && value.startsWith('$') && value.length > 1 && !(value.startsWith('$reset') && isClassProp.test(attr))) {\n          // Most attribute values starting with $ should be compiled\n          // -class attributes starting with `$reset` should not be compiled\n          getValue = provider(compile(value));\n        } else if (typeof value === 'object' && isConditional(value)) {\n          // Conditional attrs require further processing\n          getValue = parseConditionAttr(value, undefined);\n        } else if (typeof value === 'object' && isPojo(value)) {\n          // Sub-parse pojos\n          getValue = parseAttrs(value);\n        } else {\n          // In all other cases, the value is static\n          getValue = () => value;\n        }\n        setters.push(attrs => {\n          attrs[attr] = getValue();\n        });\n      }\n    }\n    return () => {\n      const attrs = Array.isArray(unparsedAttrs) ? [] : {};\n      setters.forEach(setter => setter(attrs));\n      return attrs;\n    };\n  }\n  /**\n   * Given a single schema node, parse it and extract the value.\n   * @param data - A state object provided to each node\n   * @param node - The schema node being parsed\n   * @returns\n   */\n  function parseNode(library, _node) {\n    let element = null;\n    let attrs = () => null;\n    let condition = false;\n    let children = null;\n    let alternate = null;\n    let iterator = null;\n    let resolve = false;\n    const node = sugar(_node);\n    if (isDOM(node)) {\n      // This is an actual HTML DOM element\n      element = node.$el;\n      attrs = node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;\n    } else if (isComponent$1(node)) {\n      // This is a Vue Component\n      if (typeof node.$cmp === 'string') {\n        if (has(library, node.$cmp)) {\n          element = library[node.$cmp];\n        } else {\n          element = node.$cmp;\n          resolve = true;\n        }\n      } else {\n        // in this case it must be an actual component\n        element = node.$cmp;\n      }\n      attrs = parseAttrs(node.props, node.bind);\n    } else if (isConditional(node)) {\n      [condition, children, alternate] = parseCondition(library, node);\n    }\n    // This is the same as a \"v-if\" statement — not an if/else statement\n    if (!isConditional(node) && 'if' in node) {\n      condition = provider(compile(node.if));\n    } else if (!isConditional(node) && element === null) {\n      // In this odd case our element is actually a partial and\n      // we only want to render the children.\n      condition = () => true;\n    }\n    // Compile children down to a function\n    if ('children' in node && node.children) {\n      if (typeof node.children === 'string') {\n        // We are dealing with a raw string value\n        if (node.children.startsWith('$slots.')) {\n          // this is a lone text node, turn it into a slot\n          element = element === 'text' ? 'slot' : element;\n          children = provider(compile(node.children));\n        } else if (node.children.startsWith('$') && node.children.length > 1) {\n          const value = provider(compile(node.children));\n          children = () => String(value());\n        } else {\n          children = () => String(node.children);\n        }\n      } else if (Array.isArray(node.children)) {\n        // We are dealing with node sub-children\n        children = createElements(library, node.children);\n      } else {\n        // This is a conditional if/else clause\n        const [childCondition, c, a] = parseCondition(library, node.children);\n        children = iterationData => childCondition && childCondition() ? c && c(iterationData) : a && a(iterationData);\n      }\n    }\n    if (isComponent$1(node)) {\n      if (children) {\n        // Children of components need to be provided as an object of slots\n        // so we provide an object with the default slot provided as children.\n        // We also create a new scope for this default slot, and then on each\n        // render pass the scoped slot props to the scope.\n        const produceChildren = children;\n        children = iterationData => {\n          return {\n            default(slotData, key) {\n              var _a, _b, _c, _d;\n              // We need to switch the current instance key back to the one that\n              // originally called this component's render function.\n              const currentKey = instanceKey;\n              if (key) instanceKey = key;\n              if (slotData) (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);\n              if (iterationData) (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);\n              const c = produceChildren(iterationData);\n              // Ensure our instance key never changed during runtime\n              if (slotData) (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();\n              if (iterationData) (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();\n              instanceKey = currentKey;\n              return c;\n            }\n          };\n        };\n        children.slot = true;\n      } else {\n        // If we dont have any children, we still need to provide an object\n        // instead of an empty array (which raises a warning in vue)\n        children = () => ({});\n      }\n    }\n    // Compile the for loop down\n    if ('for' in node && node.for) {\n      const values = node.for.length === 3 ? node.for[2] : node.for[1];\n      const getValues = typeof values === 'string' && values.startsWith('$') ? provider(compile(values)) : () => values;\n      iterator = [getValues, node.for[0], node.for.length === 3 ? String(node.for[1]) : null];\n    }\n    return [condition, element, attrs, children, alternate, iterator, resolve];\n  }\n  /**\n   * Given a particular function that produces children, ensure that the second\n   * argument of all these slots is the original instance key being used to\n   * render the slots.\n   * @param children - The children() function that will produce slots\n   */\n  function createSlots(children, iterationData) {\n    const slots = children(iterationData);\n    const currentKey = instanceKey;\n    return Object.keys(slots).reduce((allSlots, slotName) => {\n      const slotFn = slots && slots[slotName];\n      allSlots[slotName] = data => {\n        return slotFn && slotFn(data, currentKey) || null;\n      };\n      return allSlots;\n    }, {});\n  }\n  /**\n   * Creates an element\n   * @param data - The context data available to the node\n   * @param node - The schema node to render\n   * @returns\n   */\n  function createElement(library, node) {\n    // Parses the schema node into pertinent parts\n    const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);\n    // This is a sub-render function (called within a render function). It must\n    // only use pre-compiled features, and be organized in the most efficient\n    // manner possible.\n    let createNodes = iterationData => {\n      if (condition && element === null && children) {\n        // Handle conditional if/then statements\n        return condition() ? children(iterationData) : alternate && alternate(iterationData);\n      }\n      if (element && (!condition || condition())) {\n        // handle text nodes\n        if (element === 'text' && children) {\n          return createTextVNode(String(children()));\n        }\n        // Handle lone slots\n        if (element === 'slot' && children) return children(iterationData);\n        // Handle resolving components\n        const el = resolve ? resolveComponent(element) : element;\n        // If we are rendering slots as children, ensure their instanceKey is properly added\n        const slots = (children === null || children === void 0 ? void 0 : children.slot) ? createSlots(children, iterationData) : null;\n        // Handle dom elements and components\n        return h(el, attrs(), slots || (children ? children(iterationData) : []));\n      }\n      return typeof alternate === 'function' ? alternate(iterationData) : alternate;\n    };\n    if (iterator) {\n      const repeatedNode = createNodes;\n      const [getValues, valueName, keyName] = iterator;\n      createNodes = () => {\n        const _v = getValues();\n        const values = !isNaN(_v) ? Array(Number(_v)).fill(0).map((_, i) => i) : _v;\n        const fragment = [];\n        if (typeof values !== 'object') return null;\n        const instanceScope = instanceScopes.get(instanceKey) || [];\n        const isArray = Array.isArray(values);\n        for (const key in values) {\n          if (isArray && key in Array.prototype) continue; // Fix #299\n          const iterationData = Object.defineProperty({\n            ...instanceScope.reduce((previousIterationData, scopedData) => {\n              if (previousIterationData.__idata) {\n                return {\n                  ...previousIterationData,\n                  ...scopedData\n                };\n              }\n              return scopedData;\n            }, {}),\n            [valueName]: values[key],\n            ...(keyName !== null ? {\n              [keyName]: isArray ? Number(key) : key\n            } : {})\n          }, '__idata', {\n            enumerable: false,\n            value: true\n          });\n          instanceScope.unshift(iterationData);\n          fragment.push(repeatedNode.bind(null, iterationData)());\n          instanceScope.shift();\n        }\n        return fragment;\n      };\n    }\n    return createNodes;\n  }\n  /**\n   * Given a schema, parse it and return the resulting renderable nodes.\n   * @param data - The schema context object\n   * @param library - The available components\n   * @param node - The node to parse\n   * @returns\n   */\n  function createElements(library, schema) {\n    if (Array.isArray(schema)) {\n      const els = schema.map(createElement.bind(null, library));\n      return iterationData => els.map(element => element(iterationData));\n    }\n    // Single node to render\n    const element = createElement(library, schema);\n    return iterationData => element(iterationData);\n  }\n  /**\n   * Data providers produced as a result of the compiler.\n   */\n  const providers = [];\n  /**\n   * Append the requisite compiler provider and return the compiled function.\n   * @param compiled - A compiled function\n   * @returns\n   */\n  function provider(compiled, hints = {}) {\n    const compiledFns = {};\n    providers.push((callback, key) => {\n      compiledFns[key] = compiled.provide(tokens => callback(tokens, hints));\n    });\n    return () => compiledFns[instanceKey]();\n  }\n  /**\n   * Creates a new instance of a given schema — this either comes from a\n   * memoized copy of the parsed schema or a freshly parsed version. An symbol\n   * instance key, and dataProvider functions are passed in.\n   * @param providerCallback - A function that is called for each required provider\n   * @param key - a symbol representing the current instance\n   */\n  return function createInstance(providerCallback, key) {\n    const memoKey = JSON.stringify(schema);\n    const [render, compiledProviders] = has(memo, memoKey) ? memo[memoKey] : [createElements(library, schema), providers];\n    memo[memoKey] = [render, compiledProviders];\n    compiledProviders.forEach(compiledProvider => {\n      compiledProvider(providerCallback, key);\n    });\n    return () => {\n      instanceKey = key;\n      return render();\n    };\n  };\n}\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token, defaultValue) {\n  const scopedData = instanceScopes.get(instanceKey) || [];\n  let scopedValue = undefined;\n  if (scopedData.length) {\n    scopedValue = getValue(scopedData, token.split('.'));\n  }\n  return scopedValue === undefined ? defaultValue : scopedValue;\n}\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data, key) {\n  return new Proxy(data, {\n    get(...args) {\n      let data = undefined;\n      const property = args[1];\n      if (typeof property === 'string') {\n        const prevKey = instanceKey;\n        instanceKey = key;\n        data = useScope(property, undefined);\n        instanceKey = prevKey;\n      }\n      return data !== undefined ? data : Reflect.get(...args);\n    }\n  });\n}\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(instanceCreator, data, instanceKey) {\n  return instanceCreator((requirements, hints = {}) => {\n    return requirements.reduce((tokens, token) => {\n      if (token.startsWith('slots.')) {\n        const slot = token.substring(6);\n        const hasSlot = () => data.slots && has(data.slots, slot) && typeof data.slots[slot] === 'function';\n        if (hints.if) {\n          // If statement — dont render the slot, check if it exists\n          tokens[token] = hasSlot;\n        } else if (data.slots) {\n          // Render the slot with current scope data\n          const scopedData = slotData(data, instanceKey);\n          tokens[token] = () => hasSlot() ? data.slots[slot](scopedData) : null;\n        }\n      } else {\n        const value = getRef(token, data);\n        tokens[token] = () => useScope(token, value.value);\n      }\n      return tokens;\n    }, {});\n  }, instanceKey);\n}\nlet i = 0;\n/**\n * The FormKitSchema vue component:\n *\n * @public\n */\nconst FormKitSchema = defineComponent({\n  name: 'FormKitSchema',\n  props: {\n    schema: {\n      type: [Array, Object],\n      required: true\n    },\n    data: {\n      type: Object,\n      default: () => ({})\n    },\n    library: {\n      type: Object,\n      default: () => ({})\n    }\n  },\n  setup(props, context) {\n    const instance = getCurrentInstance();\n    let instanceKey = Symbol(String(i++));\n    instanceScopes.set(instanceKey, []);\n    let provider = parseSchema(props.library, props.schema);\n    let render;\n    let data;\n    // Re-parse the schema if it changes:\n    watch(() => props.schema, (newSchema, oldSchema) => {\n      var _a;\n      instanceKey = Symbol(String(i++));\n      provider = parseSchema(props.library, props.schema);\n      render = createRenderFn(provider, data, instanceKey);\n      if (newSchema === oldSchema) {\n        ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();\n      }\n    }, {\n      deep: true\n    });\n    // Watch the data object explicitly\n    watchEffect(() => {\n      data = Object.assign(reactive(props.data), {\n        slots: context.slots\n      });\n      render = createRenderFn(provider, data, instanceKey);\n    });\n    return () => render();\n  }\n});\n\n/**\n * All the explicit FormKit props.\n */\nconst nativeProps = {\n  config: {\n    type: Object,\n    default: {}\n  },\n  classes: {\n    type: Object,\n    required: false\n  },\n  delay: {\n    type: Number,\n    required: false\n  },\n  errors: {\n    type: Array,\n    default: []\n  },\n  inputErrors: {\n    type: Object,\n    default: () => ({})\n  },\n  index: {\n    type: Number,\n    required: false\n  },\n  id: {\n    type: String,\n    required: false\n  },\n  modelValue: {\n    required: false\n  },\n  name: {\n    type: String,\n    required: false\n  },\n  parent: {\n    type: Object,\n    required: false\n  },\n  plugins: {\n    type: Array,\n    default: []\n  },\n  sectionsSchema: {\n    type: Object,\n    default: {}\n  },\n  type: {\n    type: [String, Object],\n    default: 'text'\n  },\n  validation: {\n    type: [String, Array],\n    required: false\n  },\n  validationMessages: {\n    type: Object,\n    required: false\n  },\n  validationRules: {\n    type: Object,\n    required: false\n  },\n  validationLabel: {\n    type: [String, Function],\n    required: false\n  }\n};\n/**\n * The FormKit props object.\n * @internal\n */\nconst props = nativeProps;\n\n/**\n * The symbol that represents the formkit parent injection value.\n *\n * @public\n */\nconst parentSymbol = Symbol('FormKitParent');\n/**\n * The root FormKit component.\n *\n * @public\n */\nconst FormKit = defineComponent({\n  props,\n  emits: {\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    input: (_value, _node) => true,\n    inputRaw: (_value, _node) => true,\n    'update:modelValue': _value => true,\n    node: node => !!node,\n    submit: (_data, _node) => true,\n    submitRaw: (_event, _node) => true,\n    submitInvalid: _node => true\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  },\n\n  inheritAttrs: false,\n  setup(props, context) {\n    const node = useInput(props, context);\n    if (!node.props.definition) error(600, node);\n    if (node.props.definition.component) {\n      return () => {\n        var _a;\n        return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {\n          context: node.context\n        }, {\n          ...context.slots\n        });\n      };\n    }\n    const schema = ref([]);\n    const generateSchema = () => {\n      var _a, _b;\n      const schemaDefinition = (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.schema;\n      if (!schemaDefinition) error(601, node);\n      schema.value = typeof schemaDefinition === 'function' ? schemaDefinition({\n        ...props.sectionsSchema\n      }) : schemaDefinition;\n    };\n    generateSchema();\n    // If someone emits the schema event, we re-generate the schema\n    node.on('schema', generateSchema);\n    context.emit('node', node);\n    const library = node.props.definition.library;\n    // Expose the FormKitNode to template refs.\n    context.expose({\n      node\n    });\n    return () => h(FormKitSchema, {\n      schema: schema.value,\n      data: node.context,\n      library\n    }, {\n      ...context.slots\n    });\n  }\n});\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n *\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n *\n * @internal\n */\nfunction createPlugin(app, options) {\n  app.component(options.alias || 'FormKit', FormKit).component(options.schemaAlias || 'FormKitSchema', FormKitSchema);\n  return {\n    get: getNode,\n    setLocale: locale => {\n      var _a;\n      if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {\n        options.config.rootConfig.locale = locale;\n      }\n    },\n    clearErrors,\n    setErrors,\n    submit: submitForm,\n    reset\n  };\n}\n/**\n * The symbol key for accessing the FormKit node options.\n *\n * @public\n */\nconst optionsSymbol = Symbol.for('FormKitOptions');\n/**\n * The symbol key for accessing FormKit root configuration.\n *\n * @public\n */\nconst configSymbol = Symbol.for('FormKitConfig');\n/**\n * Create the FormKit plugin.\n *\n * @public\n */\nconst plugin = {\n  install(app, _options) {\n    /**\n     * Extend the default configuration options.\n     */\n    const options = Object.assign({\n      alias: 'FormKit',\n      schemaAlias: 'FormKitSchema'\n    }, typeof _options === 'function' ? _options() : _options);\n    /**\n     * The root configuration options.\n     */\n    const rootConfig = createConfig(options.config || {});\n    /**\n     * We dont want to explicitly provide any \"config\" options, only a root\n     * config option — so here we override the existing config options.\n     */\n    options.config = {\n      rootConfig\n    };\n    /**\n     * Register the global $formkit plugin property.\n     */\n    app.config.globalProperties.$formkit = createPlugin(app, options);\n    /**\n     * Provide the config to the application for injection.\n     */\n    app.provide(optionsSymbol, options);\n    /**\n     * Provide the root config to the application.\n     */\n    app.provide(configSymbol, rootConfig);\n  }\n};\n\n/**\n * Indicates that the path that was requested is no longer valid in the object.\n */\nconst invalidGet = Symbol();\n/**\n * A special watcher for Vue that reports the location of a deep mutation.\n *\n * @param obj - An object to observe at depth.\n * @param callback - A callback to call when a change is detected.\n *\n * @public\n */\nfunction watchVerbose(obj, callback) {\n  const watchers = {};\n  const applyWatch = paths => {\n    // Watch each property\n    for (const path of paths) {\n      // Stops pre-existing watchers at a given location to prevent dupes:\n      if (path.__str in watchers) watchers[path.__str]();\n      watchers[path.__str] = watch(touch.bind(null, obj, path), dispatcher.bind(null, path), {\n        deep: false\n      });\n    }\n  };\n  /**\n   * Clear any watchers deeper than this path.\n   * @param path - The path to start from\n   */\n  const clearWatch = path => {\n    if (!path.length) return;\n    for (const key in watchers) {\n      if (`${key}`.startsWith(`${path.__str}.`)) {\n        watchers[key]();\n        delete watchers[key];\n      }\n    }\n  };\n  const dispatcher = createDispatcher(obj, callback, applyWatch, clearWatch);\n  applyWatch(getPaths(obj));\n}\n/**\n * This function synchronously dispatches to the watch callbacks. It uses the\n * knowledge that the getPath function is a depth-first-search thus lower\n * specificity (lower tree nodes) will always have their watchers called first.\n * If a lower specificity watcher is triggered we want to ignore the higher\n * specificity watcher.\n * @param obj - The object to dispatch\n * @param callback - The callback function to emit\n * @param applyWatch - A way to apply watchers to update objects\n * @returns\n */\nfunction createDispatcher(obj, callback, applyWatch, clearChildWatches) {\n  // let dispatchedPaths: Record<string, ObjectPath> = {}\n  // let clear: Promise<void> | null = null\n  return path => {\n    const value = get(obj, path);\n    if (value === invalidGet) return;\n    if (path.__deep) clearChildWatches(path);\n    if (typeof value === 'object') applyWatch(getPaths(value, [path], ...path));\n    callback(path, value, obj);\n  };\n}\n/**\n * \"Touches\" a given property for reactivity tracking purposes, if the value at\n * the given path is an object, we flatten it to just its keys since we will\n * already be tracking sub properties independently.\n * @param obj - A ref to traverse for a given path\n * @param path - An array of strings representing the path to locate\n * @returns\n */\nfunction touch(obj, path) {\n  const value = get(obj, path);\n  return value && typeof value === 'object' ? Object.keys(value) : value;\n}\n/**\n * \"Touches\" a given property for reactivity tracking purposes.\n * @param obj - A ref to traverse for a given path\n * @param path - An array of strings representing the path to locate\n * @returns\n */\nfunction get(obj, path) {\n  if (isRef(obj)) {\n    if (path.length === 0) return obj.value;\n    obj = obj.value;\n  }\n  return path.reduce((value, segment) => {\n    if (value === invalidGet) return value;\n    if (value === null || typeof value !== 'object') {\n      return invalidGet;\n    }\n    return value[segment];\n  }, obj);\n}\n/**\n * Recursively retrieves all enumerable property paths from the origination\n * object. For example:\n * ```js\n * const obj = {\n *   a: {\n *     b: 123\n *   },\n *   c: 567\n * }\n * const paths = getPaths(obj)\n * // [\n * //   ['a'],\n * //   ['a', 'b'],\n * //   ['c']\n * // ]\n * ```\n * @param obj - An object to retrieve paths for.\n * @param parents - An array of parent paths.\n * @returns\n * @internal\n */\nfunction getPaths(obj, paths = [], ...parents) {\n  if (obj === null) return paths;\n  if (!parents.length) {\n    const path = Object.defineProperty([], '__str', {\n      value: ''\n    });\n    obj = isRef(obj) ? obj.value : obj;\n    if (obj && typeof obj === 'object') {\n      Object.defineProperty(path, '__deep', {\n        value: true\n      });\n      paths.push(path);\n    } else {\n      return [path];\n    }\n  }\n  if (obj === null || typeof obj !== 'object') return paths;\n  for (const key in obj) {\n    const path = parents.concat(key);\n    Object.defineProperty(path, '__str', {\n      value: path.join('.')\n    });\n    const value = obj[key];\n    if (isPojo(value) || Array.isArray(value)) {\n      paths.push(Object.defineProperty(path, '__deep', {\n        value: true\n      }));\n      paths = paths.concat(getPaths(value, [], ...path));\n    } else {\n      paths.push(path);\n    }\n  }\n  return paths;\n}\n\n/**\n * Gets the raw underlying target object from a Vue Ref or Reactive object.\n * @param obj - Get the underlying target object, or no-op.\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction useRaw(obj) {\n  if (obj === null || typeof obj !== 'object') return obj;\n  if (isReactive(obj)) {\n    obj = toRaw(obj);\n  } else if (isRef(obj)) {\n    obj = isReactive(obj.value) ? useRaw(obj.value) : obj.value;\n  }\n  return obj;\n}\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = ['help', 'label', 'ignore', 'disabled', 'preserve', /^preserve(-e|E)rrors/, /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/, /^[a-zA-Z-]+(?:-class|Class)$/, 'prefixIcon', 'suffixIcon', /^[a-zA-Z-]+(?:-icon|Icon)$/];\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node, props) {\n  if (props.classes) {\n    Object.keys(props.classes).forEach(key => {\n      if (typeof key === 'string') {\n        node.props[`_${key}Class`] = props.classes[key];\n        // We need to ensure Vue is aware that we want to actually observe the\n        // child values too, so we touch them here.\n        if (isObject(props.classes[key]) && key === 'inner') Object.values(props.classes[key]);\n      }\n    });\n  }\n}\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(props) {\n  if (!props) return {};\n  const knownListeners = ['Submit', 'SubmitRaw', 'SubmitInvalid'].reduce((listeners, listener) => {\n    const name = `on${listener}`;\n    if (name in props) {\n      if (typeof props[name] === 'function') {\n        listeners[name] = props[name];\n      }\n    }\n    return listeners;\n  }, {});\n  return knownListeners;\n}\n/**\n * A composable for creating a new FormKit node.\n *\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" — which is really the attrs list.\n *\n * @returns {@link @formkit/core#FormKitNode | FormKitNode}\n *\n * @public\n */\nfunction useInput(props, context, options = {}) {\n  var _a;\n  /**\n   * The configuration options, these are provided by either the plugin or by\n   * explicit props.\n   */\n  const config = Object.assign({}, inject(optionsSymbol) || {}, options);\n  /**\n   * The current instance.\n   */\n  const instance = getCurrentInstance();\n  /**\n   * Extracts the listeners.\n   */\n  const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);\n  /**\n   * Determines if the prop is v-modeled. Credit to:\n   * {@link https://github.com/LinusBorg | Thorsten Lünborg}\n   * for coming up with this solution.\n   */\n  const isVModeled = ('modelValue' in ((_a = instance === null || instance === void 0 ? void 0 : instance.vnode.props) !== null && _a !== void 0 ? _a : {}));\n  /**\n   * Determines if the object being passed as a v-model is reactive.\n   */\n  // const isReactiveVModel = isVModeled && isReactive(props.modelValue)\n  /**\n   * Define the initial component\n   */\n  const value = props.modelValue !== undefined ? props.modelValue : cloneAny(context.attrs.value);\n  /**\n   * Creates the node's initial props from the context, props, and definition\n   * @returns\n   */\n  function createInitialProps() {\n    const initialProps = {\n      ...nodeProps(props),\n      ...listeners\n    };\n    const attrs = except(nodeProps(context.attrs), pseudoProps);\n    if (!attrs.key) attrs.key = token();\n    initialProps.attrs = attrs;\n    const propValues = only(nodeProps(context.attrs), pseudoProps);\n    for (const propName in propValues) {\n      initialProps[camel(propName)] = propValues[propName];\n    }\n    const classesProps = {\n      props: {}\n    };\n    classesToNodeProps(classesProps, props);\n    Object.assign(initialProps, classesProps.props);\n    if (typeof initialProps.type !== 'string') {\n      initialProps.definition = initialProps.type;\n      delete initialProps.type;\n    }\n    return initialProps;\n  }\n  /**\n   * Create the FormKitNode.\n   */\n  const initialProps = createInitialProps();\n  /**\n   * The parent node.\n   */\n  const parent = initialProps.ignore ? null : props.parent || inject(parentSymbol, null);\n  const node = createNode(extend(config || {}, {\n    name: props.name || undefined,\n    value,\n    parent,\n    plugins: (config.plugins || []).concat(props.plugins),\n    config: props.config,\n    props: initialProps,\n    index: props.index\n  }, false, true));\n  /**\n   * If no definition has been assigned at this point — we're out!\n   */\n  if (!node.props.definition) error(600, node);\n  /**\n   * All props that are bound \"late\" (after node creation) — are added to a set\n   * which is used to watch the context.attrs object.\n   */\n  const lateBoundProps = ref(new Set(node.props.definition.props || []));\n  /**\n   * Any additional props added at a \"later\" time should also be part of the\n   * late bound props.\n   */\n  node.on('added-props', ({\n    payload: lateProps\n  }) => {\n    if (Array.isArray(lateProps)) lateProps.forEach(newProp => lateBoundProps.value.add(newProp));\n  });\n  /**\n   * These prop names must be assigned.\n   */\n  const pseudoPropNames = computed(() => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n    if (typeof prop === 'string') {\n      names.push(camel(prop));\n      names.push(kebab(prop));\n    } else {\n      names.push(prop);\n    }\n    return names;\n  }, []));\n  /* Splits Classes object into discrete props for each key */\n  watchEffect(() => classesToNodeProps(node, props));\n  /**\n   * The props object already has properties even if they start as \"undefined\"\n   * so we can loop over them and individual watchEffect to prevent responding\n   * inappropriately.\n   */\n  const passThrough = nodeProps(props);\n  for (const prop in passThrough) {\n    watch(() => props[prop], () => {\n      if (props[prop] !== undefined) {\n        node.props[prop] = props[prop];\n      }\n    });\n  }\n  /**\n   * Watch \"pseudoProp\" attributes explicitly.\n   */\n  const attributeWatchers = new Set();\n  const possibleProps = nodeProps(context.attrs);\n  watchEffect(() => {\n    watchAttributes(only(possibleProps, pseudoPropNames.value));\n  });\n  /**\n   * Defines attributes that should be used as props.\n   * @param attrProps - Attributes that should be used as props instead\n   */\n  function watchAttributes(attrProps) {\n    attributeWatchers.forEach(stop => {\n      stop();\n      attributeWatchers.delete(stop);\n    });\n    for (const prop in attrProps) {\n      const camelName = camel(prop);\n      attributeWatchers.add(watch(() => context.attrs[prop], () => {\n        node.props[camelName] = context.attrs[prop];\n      }));\n    }\n  }\n  /**\n   * Watch and dynamically set attribute values, those values that are not\n   * props and are not pseudoProps\n   */\n  watchEffect(() => {\n    const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);\n    // An explicit exception to ensure naked \"multiple\" attributes appear on the\n    // outer wrapper as data-multiple=\"true\"\n    if ('multiple' in attrs) attrs.multiple = undefine(attrs.multiple);\n    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n  });\n  /**\n   * Add any/all \"prop\" errors to the store.\n   */\n  watchEffect(() => {\n    const messages = props.errors.map(error => createMessage({\n      key: slugify(error),\n      type: 'error',\n      value: error,\n      meta: {\n        source: 'prop'\n      }\n    }));\n    node.store.apply(messages, message => message.type === 'error' && message.meta.source === 'prop');\n  });\n  /**\n   * Add input errors.\n   */\n  if (node.type !== 'input') {\n    const sourceKey = `${node.name}-prop`;\n    watchEffect(() => {\n      const keys = Object.keys(props.inputErrors);\n      if (!keys.length) node.clearErrors(true, sourceKey);\n      const messages = keys.reduce((messages, key) => {\n        let value = props.inputErrors[key];\n        if (typeof value === 'string') value = [value];\n        if (Array.isArray(value)) {\n          messages[key] = value.map(error => createMessage({\n            key: error,\n            type: 'error',\n            value: error,\n            meta: {\n              source: sourceKey\n            }\n          }));\n        }\n        return messages;\n      }, {});\n      node.store.apply(messages, message => message.type === 'error' && message.meta.source === sourceKey);\n    });\n  }\n  /**\n   * Watch the config prop for any changes.\n   */\n  watchEffect(() => Object.assign(node.config, props.config));\n  /**\n   * Produce another parent object.\n   */\n  if (node.type !== 'input') {\n    provide(parentSymbol, node);\n  }\n  let inputTimeout;\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  const mutex = new WeakSet();\n  /**\n   * Explicitly watch the input value, and emit changes (lazy)\n   */\n  node.on('modelUpdated', () => {\n    var _a, _b;\n    // Emit the values after commit\n    context.emit('inputRaw', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value, node);\n    clearTimeout(inputTimeout);\n    inputTimeout = setTimeout(context.emit, 20, 'input', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value, node);\n    if (isVModeled && node.context) {\n      const newValue = useRaw(node.context.value);\n      if (isObject(newValue) && useRaw(props.modelValue) !== newValue) {\n        // If this is an object that has been mutated inside FormKit core then\n        // we know when it is emitted it will \"return\" in the watchVerbose so\n        // we pro-actively add it to the mutex.\n        mutex.add(newValue);\n      }\n      context.emit('update:modelValue', newValue);\n    }\n  });\n  /**\n   * Enabled support for v-model, using this for groups/lists is not recommended\n   */\n  if (isVModeled) {\n    watchVerbose(toRef(props, 'modelValue'), (path, value) => {\n      var _a;\n      const rawValue = useRaw(value);\n      if (isObject(rawValue) && mutex.has(rawValue)) {\n        return mutex.delete(rawValue);\n      }\n      if (!path.length) node.input(value, false);else (_a = node.at(path)) === null || _a === void 0 ? void 0 : _a.input(value, false);\n    });\n    /**\n     * On initialization, if the node’s value was updated (like in a plugin\n     * hook) then we should emit a `modelUpdated` event.\n     */\n    if (node.value !== value) {\n      node.emit('modelUpdated');\n    }\n  }\n  /**\n   * When this input shuts down, we need to \"delete\" the node too.\n   */\n  // onUnmounted(() => node.destroy())\n  onBeforeUnmount(() => node.destroy());\n  return node;\n}\nlet totalCreated = 1;\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj) {\n  return typeof obj === 'function' && obj.length === 2 || typeof obj === 'object' && !Array.isArray(obj) && !('$el' in obj) && !('$cmp' in obj) && !('if' in obj);\n}\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input or the component.\n * @param definitionOptions - Any options in the FormKitTypeDefinition you want\n * to define.\n *\n * @returns {@link @formkit/core#FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @public\n */\nfunction createInput(schemaOrComponent, definitionOptions = {}) {\n  const definition = {\n    type: 'input',\n    ...definitionOptions\n  };\n  let schema;\n  if (isComponent(schemaOrComponent)) {\n    const cmpName = `SchemaComponent${totalCreated++}`;\n    schema = createSection('input', () => ({\n      $cmp: cmpName,\n      props: {\n        context: '$node.context'\n      }\n    }));\n    definition.library = {\n      [cmpName]: markRaw(schemaOrComponent)\n    };\n  } else if (typeof schemaOrComponent === 'function') {\n    schema = schemaOrComponent;\n  } else {\n    schema = createSection('input', () => cloneAny(schemaOrComponent));\n  }\n  // Use the default wrapping schema\n  definition.schema = useSchema(schema || 'Schema undefined');\n  return definition;\n}\n\n/**\n * @internal\n */\nconst messages = createSection('messages', () => ({\n  $el: 'ul',\n  if: '$fns.length($messages)'\n}), true);\n/**\n * @internal\n */\nconst message = createSection('message', () => ({\n  $el: 'li',\n  for: ['message', '$messages'],\n  attrs: {\n    key: '$message.key',\n    id: `$id + '-' + $message.key`,\n    'data-message-type': '$message.type'\n  }\n}));\n/**\n * The actual schema to render for the messages.\n */\nconst definition = messages(message('$message.value'));\n/**\n * Renders the messages for a parent node, or any node explicitly passed to it.\n * @public\n */\nconst FormKitMessages = defineComponent({\n  props: {\n    node: {\n      type: Object,\n      required: false\n    },\n    sectionsSchema: {\n      type: Object,\n      default: {}\n    },\n    defaultPosition: {\n      type: [String, Boolean],\n      default: false\n    }\n  },\n  setup(props, context) {\n    const node = computed(() => {\n      return props.node || inject(parentSymbol, undefined);\n    });\n    watch(node, () => {\n      var _a;\n      if (((_a = node.value) === null || _a === void 0 ? void 0 : _a.context) && !undefine(props.defaultPosition)) {\n        node.value.context.defaultMessagePlacement = false;\n      }\n    }, {\n      immediate: true\n    });\n    const schema = definition(props.sectionsSchema || {});\n    const data = computed(() => {\n      var _a, _b, _c, _d, _e, _f;\n      return {\n        messages: ((_b = (_a = node.value) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.messages) || {},\n        fns: ((_d = (_c = node.value) === null || _c === void 0 ? void 0 : _c.context) === null || _d === void 0 ? void 0 : _d.fns) || {},\n        classes: ((_f = (_e = node.value) === null || _e === void 0 ? void 0 : _e.context) === null || _f === void 0 ? void 0 : _f.classes) || {}\n      };\n    });\n    return () => {\n      var _a;\n      return ((_a = node.value) === null || _a === void 0 ? void 0 : _a.context) ? h(FormKitSchema, {\n        schema,\n        data: data.value\n      }, {\n        ...context.slots\n      }) : null;\n    };\n  }\n});\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n *\n * @param node - FormKitNode to create the context on.\n *\n * @public\n */\nconst vueBindings = function vueBindings(node) {\n  /**\n   * Start a validity counter on all blocking messages.\n   */\n  node.ledger.count('blocking', m => m.blocking);\n  const isValid = ref(!node.ledger.value('blocking'));\n  /**\n   * Start an error message counter.\n   */\n  node.ledger.count('errors', m => m.type === 'error');\n  const hasErrors = ref(!!node.ledger.value('errors'));\n  /**\n   * Keep track of the first time a Vue tick cycle has passed.\n   */\n  let hasTicked = false;\n  nextTick(() => {\n    hasTicked = true;\n  });\n  /**\n   * All messages with the visibility state set to true.\n   */\n  const availableMessages = reactive(node.store.reduce((store, message) => {\n    if (message.visible) {\n      store[message.key] = message;\n    }\n    return store;\n  }, {}));\n  /**\n   * A flag that determines when validation messages should be displayed.\n   */\n  const validationVisibility = ref(node.props.validationVisibility || 'blur');\n  node.on('prop:validationVisibility', ({\n    payload\n  }) => {\n    validationVisibility.value = payload;\n  });\n  /**\n   * Keep track of if this input has ever shown validation errors.\n   */\n  const hasShownErrors = ref(validationVisibility.value === 'live');\n  /**\n   * The current visibility state of validation messages.\n   */\n  const validationVisible = computed(() => {\n    if (context.state.submitted) return true;\n    if (!hasShownErrors.value && !context.state.settled) {\n      return false;\n    }\n    switch (validationVisibility.value) {\n      case 'live':\n        return true;\n      case 'blur':\n        return context.state.blurred;\n      case 'dirty':\n        return context.state.dirty;\n      default:\n        return false;\n    }\n  });\n  /**\n   * Determines if the input should be considered \"complete\".\n   */\n  const isComplete = computed(() => {\n    return hasValidation.value ? isValid.value && !hasErrors.value : context.state.dirty && !empty(context.value);\n  });\n  /**\n   * If the input has validation rules or not.\n   */\n  const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);\n  node.on('prop:parsedRules', ({\n    payload: rules\n  }) => {\n    hasValidation.value = Array.isArray(rules) && rules.length > 0;\n  });\n  /**\n   * All messages that are currently on display to an end user. This changes\n   * based on the current message type visibility, like errorVisibility.\n   */\n  const messages = computed(() => {\n    const visibleMessages = {};\n    for (const key in availableMessages) {\n      const message = availableMessages[key];\n      if (message.type !== 'validation' || validationVisible.value) {\n        visibleMessages[key] = message;\n      }\n    }\n    return visibleMessages;\n  });\n  /**\n   * UI Messages.\n   */\n  const ui = reactive(node.store.reduce((messages, message) => {\n    if (message.type === 'ui' && message.visible) messages[message.key] = message;\n    return messages;\n  }, {}));\n  /**\n   * This is the reactive data object that is provided to all schemas and\n   * forms. It is a subset of data in the core node object.\n   */\n  const cachedClasses = reactive({});\n  const classes = new Proxy(cachedClasses, {\n    get(...args) {\n      const [target, property] = args;\n      let className = Reflect.get(...args);\n      if (!className && typeof property === 'string') {\n        if (!has(target, property) && !property.startsWith('__v')) {\n          const observedNode = createObserver(node);\n          observedNode.watch(node => {\n            const rootClasses = typeof node.config.rootClasses === 'function' ? node.config.rootClasses(property, node) : {};\n            const globalConfigClasses = node.config.classes ? createClasses(property, node, node.config.classes[property]) : {};\n            const classesPropClasses = createClasses(property, node, node.props[`_${property}Class`]);\n            const sectionPropClasses = createClasses(property, node, node.props[`${property}Class`]);\n            className = generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);\n            target[property] = className !== null && className !== void 0 ? className : '';\n          });\n        }\n      }\n      return className;\n    }\n  });\n  const describedBy = computed(() => {\n    const describers = [];\n    if (context.help) {\n      describers.push(`help-${node.props.id}`);\n    }\n    for (const key in messages.value) {\n      describers.push(`${node.props.id}-${key}`);\n    }\n    return describers.length ? describers.join(' ') : undefined;\n  });\n  const value = ref(node.value);\n  const _value = ref(node.value);\n  const context = reactive({\n    _value,\n    attrs: node.props.attrs,\n    disabled: node.props.disabled,\n    describedBy,\n    fns: {\n      length: obj => Object.keys(obj).length,\n      number: value => Number(value),\n      string: value => String(value),\n      json: value => JSON.stringify(value),\n      eq\n    },\n    handlers: {\n      blur: e => {\n        node.store.set(createMessage({\n          key: 'blurred',\n          visible: false,\n          value: true\n        }));\n        if (typeof node.props.attrs.onBlur === 'function') {\n          node.props.attrs.onBlur(e);\n        }\n      },\n      touch: () => {\n        var _a;\n        const doCompare = context.dirtyBehavior === 'compare';\n        if (((_a = node.store.dirty) === null || _a === void 0 ? void 0 : _a.value) && !doCompare) return;\n        const isDirty = !eq(node.props._init, node._value);\n        if (!isDirty && !doCompare) return;\n        node.store.set(createMessage({\n          key: 'dirty',\n          visible: false,\n          value: isDirty\n        }));\n      },\n      DOMInput: e => {\n        node.input(e.target.value);\n        node.emit('dom-input-event', e);\n      }\n    },\n    help: node.props.help,\n    id: node.props.id,\n    label: node.props.label,\n    messages,\n    node: markRaw(node),\n    options: node.props.options,\n    defaultMessagePlacement: true,\n    state: {\n      blurred: false,\n      complete: isComplete,\n      dirty: false,\n      submitted: false,\n      settled: node.isSettled,\n      valid: isValid,\n      errors: hasErrors,\n      rules: hasValidation,\n      validationVisible\n    },\n    type: node.props.type,\n    family: node.props.family,\n    ui,\n    value,\n    classes\n  });\n  /**\n   * Ensure the context object is properly configured after booting up.\n   */\n  node.on('created', () => {\n    if (!eq(context.value, node.value)) {\n      _value.value = node.value;\n      value.value = node.value;\n      triggerRef(value);\n      triggerRef(_value);\n    }\n    (async () => {\n      await node.settled;\n      node.props._init = cloneAny(node.value);\n    })();\n  });\n  /**\n   * Sets the settled state.\n   */\n  node.on('settled', ({\n    payload: isSettled\n  }) => {\n    context.state.settled = isSettled;\n  });\n  /**\n   * Observes node.props properties explicitly and updates them in the context\n   * object.\n   * @param observe - Props to observe and register as context data.\n   */\n  function observeProps(observe) {\n    observe.forEach(prop => {\n      prop = camel(prop);\n      if (!has(context, prop) && has(node.props, prop)) {\n        context[prop] = node.props[prop];\n      }\n      node.on(`prop:${prop}`, ({\n        payload\n      }) => {\n        context[prop] = payload;\n      });\n    });\n  }\n  /**\n   * We use a node observer to individually observe node props.\n   */\n  const rootProps = () => {\n    const props = ['help', 'label', 'disabled', 'options', 'type', 'attrs', 'preserve', 'preserveErrors', 'id', 'dirtyBehavior'];\n    const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;\n    const matchingProps = Object.keys(node.props).filter(prop => {\n      return iconPattern.test(prop);\n    });\n    return props.concat(matchingProps);\n  };\n  observeProps(rootProps());\n  /**\n   * Once the input is defined, deal with it.\n   * @param definition - Type definition.\n   */\n  function definedAs(definition) {\n    if (definition.props) observeProps(definition.props);\n  }\n  node.props.definition && definedAs(node.props.definition);\n  /**\n   * When new props are added to the core node as \"props\" (ie not attrs) then\n   * we automatically need to start tracking them here.\n   */\n  node.on('added-props', ({\n    payload\n  }) => observeProps(payload));\n  /**\n   * Watch for input events from core.\n   */\n  node.on('input', ({\n    payload\n  }) => {\n    if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n      _value.value = shallowClone(payload);\n    } else {\n      _value.value = payload;\n      triggerRef(_value);\n    }\n  });\n  /**\n   * Watch for input commits from core.\n   */\n  node.on('commit', ({\n    payload\n  }) => {\n    if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n      value.value = _value.value = shallowClone(payload);\n    } else {\n      value.value = _value.value = payload;\n      triggerRef(value);\n    }\n    node.emit('modelUpdated');\n    // The input is dirty after a value has been input by a user\n    if ((!context.state.dirty || context.dirtyBehavior === 'compare') && node.isCreated && hasTicked) {\n      context.handlers.touch();\n    }\n    if (isComplete && node.type === 'input' && hasErrors.value && !undefine(node.props.preserveErrors)) {\n      node.store.filter(message => {\n        var _a;\n        return !(message.type === 'error' && ((_a = message.meta) === null || _a === void 0 ? void 0 : _a.autoClear) === true);\n      });\n    }\n  });\n  /**\n   * Update the local state in response to messages.\n   * @param message - A formkit message\n   */\n  const updateState = async message => {\n    if (message.type === 'ui' && message.visible && !message.meta.showAsMessage) {\n      ui[message.key] = message;\n    } else if (message.visible) {\n      availableMessages[message.key] = message;\n    } else if (message.type === 'state') {\n      // await node.settled\n      context.state[message.key] = !!message.value;\n    }\n  };\n  /**\n   * Listen to message events and modify the local message data values.\n   */\n  node.on('message-added', e => updateState(e.payload));\n  node.on('message-updated', e => updateState(e.payload));\n  node.on('message-removed', ({\n    payload: message\n  }) => {\n    delete ui[message.key];\n    delete availableMessages[message.key];\n    delete context.state[message.key];\n  });\n  node.on('settled:blocking', () => {\n    isValid.value = true;\n  });\n  node.on('unsettled:blocking', () => {\n    isValid.value = false;\n  });\n  node.on('settled:errors', () => {\n    hasErrors.value = false;\n  });\n  node.on('unsettled:errors', () => {\n    hasErrors.value = true;\n  });\n  /**\n   * Watch the validation visible prop and set the hasShownErrors state.\n   */\n  watch(validationVisible, value => {\n    if (value) {\n      hasShownErrors.value = true;\n    }\n  });\n  node.context = context;\n  // The context is complete\n  node.emit('context', node, false);\n};\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n *\n * @public\n */\nconst defaultConfig = (options = {}) => {\n  const {\n    rules = {},\n    locales = {},\n    inputs: inputs$1 = {},\n    messages = {},\n    locale = undefined,\n    theme = undefined,\n    iconLoaderUrl = undefined,\n    iconLoader = undefined,\n    icons = {},\n    ...nodeOptions\n  } = options;\n  /**\n   * The default configuration includes the validation plugin,\n   * with all core-available validation rules.\n   */\n  const validation = createValidationPlugin({\n    ...defaultRules,\n    ...(rules || {})\n  });\n  /**\n   * Includes the i18n plugin with only the english language\n   * messages.\n   */\n  const i18n = createI18nPlugin(extend({\n    en,\n    ...(locales || {})\n  }, messages));\n  /**\n   * Create the library of inputs that are generally available. This default\n   * config imports all \"native\" inputs by default, but\n   */\n  const library = createLibraryPlugin(inputs, inputs$1);\n  /**\n   * Create the theme plugin for the user provided theme\n   */\n  const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);\n  return extend({\n    plugins: [library, themePlugin, vueBindings, i18n, validation],\n    ...(!locale ? {} : {\n      config: {\n        locale\n      }\n    })\n  }, nodeOptions || {}, true);\n};\n\n/**\n * Renders an icon using the current IconLoader set at the root FormKit config\n *\n * @public\n */\nconst FormKitIcon = defineComponent({\n  name: 'FormKitIcon',\n  props: {\n    icon: {\n      type: String,\n      default: ''\n    },\n    iconLoader: {\n      type: Function,\n      default: null\n    },\n    iconLoaderUrl: {\n      type: Function,\n      default: null\n    }\n  },\n  setup(props) {\n    var _a, _b;\n    const icon = ref(undefined);\n    const config = inject(optionsSymbol, {});\n    const parent = inject(parentSymbol, null);\n    let iconHandler = undefined;\n    function loadIcon() {\n      if (!iconHandler || typeof iconHandler !== 'function') return;\n      const iconOrPromise = iconHandler(props.icon);\n      if (iconOrPromise instanceof Promise) {\n        iconOrPromise.then(iconValue => {\n          icon.value = iconValue;\n        });\n      } else {\n        icon.value = iconOrPromise;\n      }\n    }\n    if (props.iconLoader && typeof props.iconLoader === 'function') {\n      // if we have a locally supplied loader, then use it\n      iconHandler = createIconHandler(props.iconLoader);\n    } else if (parent && ((_a = parent.props) === null || _a === void 0 ? void 0 : _a.iconLoader)) {\n      // otherwise try to inherit from a parent\n      iconHandler = createIconHandler(parent.props.iconLoader);\n    } else if (props.iconLoaderUrl && typeof props.iconLoaderUrl === 'function') {\n      iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);\n    } else {\n      // grab our iconHandler from the global config\n      const iconPlugin = (_b = config === null || config === void 0 ? void 0 : config.plugins) === null || _b === void 0 ? void 0 : _b.find(plugin => {\n        return typeof plugin.iconHandler === 'function';\n      });\n      if (iconPlugin) {\n        iconHandler = iconPlugin.iconHandler;\n      }\n    }\n    watch(() => props.icon, () => {\n      loadIcon();\n    }, {\n      immediate: true\n    });\n    return () => {\n      if (props.icon && icon.value) {\n        return h('span', {\n          class: 'formkit-icon',\n          innerHTML: icon.value\n        });\n      }\n      return null;\n    };\n  }\n});\nexport { FormKit, FormKitIcon, FormKitMessages, FormKitSchema, vueBindings as bindings, configSymbol, createInput, defaultConfig, optionsSymbol, parentSymbol, plugin, useInput, watchVerbose };","map":{"version":3,"names":["warn","getNode","watchRegistry","isNode","sugar","isDOM","isComponent","isComponent$1","isConditional","compile","error","createConfig","clearErrors","setErrors","submitForm","reset","createNode","createMessage","createClasses","generateClassList","errorHandler","resetCount","defineComponent","getCurrentInstance","watch","watchEffect","reactive","ref","isRef","createTextVNode","resolveComponent","h","isReactive","toRaw","inject","computed","provide","toRef","onBeforeUnmount","markRaw","nextTick","triggerRef","has","isPojo","cloneAny","extend","camel","kebab","nodeProps","only","except","undefine","slugify","isObject","token","empty","eq","shallowClone","createSection","useSchema","createLibraryPlugin","inputs","defaultRules","createValidationPlugin","createI18nPlugin","en","createThemePlugin","createIconHandler","createObserver","memo","instanceKey","instanceScopes","Map","raw","isClassProp","getRef","data","value","nodeRefs","get$1","bind","path","split","getValue","set","Array","isArray","subset","undefined","foundValue","obj","i","key","currentValue","Number","length","id","root","context","payload","node","parseSchema","library","schema","parseCondition","condition","provider","if","children","createElements","then","alternate","else","parseConditionAttr","attr","_default","_a","_b","b","a","parseAttrs","startsWith","unparsedAttrs","bindExp","explicitAttrs","Set","Object","keys","boundAttrs","setters","attrs","bound","isStr","substring","test","push","forEach","setter","parseNode","_node","element","iterator","resolve","$el","$cmp","props","String","childCondition","c","iterationData","produceChildren","default","slotData","_c","_d","currentKey","get","unshift","shift","slot","for","values","getValues","createSlots","slots","reduce","allSlots","slotName","slotFn","createElement","createNodes","el","repeatedNode","valueName","keyName","_v","isNaN","fill","map","_","fragment","instanceScope","prototype","defineProperty","previousIterationData","scopedData","__idata","enumerable","els","providers","compiled","hints","compiledFns","callback","tokens","createInstance","providerCallback","memoKey","JSON","stringify","render","compiledProviders","compiledProvider","useScope","defaultValue","scopedValue","Proxy","args","property","prevKey","Reflect","createRenderFn","instanceCreator","requirements","hasSlot","FormKitSchema","name","type","required","setup","instance","Symbol","newSchema","oldSchema","proxy","$forceUpdate","deep","assign","nativeProps","config","classes","delay","errors","inputErrors","index","modelValue","parent","plugins","sectionsSchema","validation","validationMessages","validationRules","validationLabel","Function","parentSymbol","FormKit","emits","input","_value","inputRaw","submit","_data","submitRaw","_event","submitInvalid","inheritAttrs","useInput","definition","component","generateSchema","schemaDefinition","on","emit","expose","createPlugin","app","options","alias","schemaAlias","setLocale","locale","rootConfig","optionsSymbol","configSymbol","plugin","install","_options","globalProperties","$formkit","invalidGet","watchVerbose","watchers","applyWatch","paths","__str","touch","dispatcher","clearWatch","createDispatcher","getPaths","clearChildWatches","__deep","segment","parents","concat","join","useRaw","pseudoProps","classesToNodeProps","onlyListeners","knownListeners","listeners","listener","vnode","isVModeled","createInitialProps","initialProps","propValues","propName","classesProps","ignore","lateBoundProps","lateProps","newProp","add","pseudoPropNames","names","prop","passThrough","attributeWatchers","possibleProps","watchAttributes","attrProps","stop","delete","camelName","multiple","messages","meta","source","store","apply","message","sourceKey","inputTimeout","mutex","WeakSet","clearTimeout","setTimeout","newValue","rawValue","at","destroy","totalCreated","createInput","schemaOrComponent","definitionOptions","cmpName","FormKitMessages","defaultPosition","Boolean","defaultMessagePlacement","immediate","_e","_f","fns","vueBindings","ledger","count","m","blocking","isValid","hasErrors","hasTicked","availableMessages","visible","validationVisibility","hasShownErrors","validationVisible","state","submitted","settled","blurred","dirty","isComplete","hasValidation","parsedRules","rules","visibleMessages","ui","cachedClasses","target","className","observedNode","rootClasses","globalConfigClasses","classesPropClasses","sectionPropClasses","describedBy","describers","help","disabled","number","string","json","handlers","blur","e","onBlur","doCompare","dirtyBehavior","isDirty","_init","DOMInput","label","complete","isSettled","valid","family","observeProps","observe","rootProps","iconPattern","matchingProps","filter","definedAs","isCreated","preserveErrors","autoClear","updateState","showAsMessage","defaultConfig","locales","inputs$1","theme","iconLoaderUrl","iconLoader","icons","nodeOptions","i18n","themePlugin","FormKitIcon","icon","iconHandler","loadIcon","iconOrPromise","Promise","iconValue","iconPlugin","find","class","innerHTML","bindings"],"sources":["D:/VueJS/Form Validation with Formkit/node_modules/@formkit/vue/dist/index.mjs"],"sourcesContent":["import { warn, getNode, watchRegistry, isNode, sugar, isDOM, isComponent as isComponent$1, isConditional, compile, error, createConfig, clearErrors, setErrors, submitForm, reset, createNode, createMessage, createClasses, generateClassList } from '@formkit/core';\nexport { clearErrors, errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\nimport { defineComponent, getCurrentInstance, watch, watchEffect, reactive, ref, isRef, createTextVNode, resolveComponent, h, isReactive, toRaw, inject, computed, provide, toRef, onBeforeUnmount, markRaw, nextTick, triggerRef } from 'vue';\nimport { has, isPojo, cloneAny, extend, camel, kebab, nodeProps, only, except, undefine, slugify, isObject, token, empty, eq, shallowClone } from '@formkit/utils';\nimport { createSection, useSchema, createLibraryPlugin, inputs } from '@formkit/inputs';\nimport * as defaultRules from '@formkit/rules';\nimport { createValidationPlugin } from '@formkit/validation';\nimport { createI18nPlugin, en } from '@formkit/i18n';\nimport { createThemePlugin, createIconHandler } from '@formkit/themes';\nimport { createObserver } from '@formkit/observer';\nimport '@formkit/dev';\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo = {};\n/**\n * This symbol represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey;\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance symbol. For example data from: for-loop instances and slot data.\n */\nconst instanceScopes = new Map();\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__';\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(token, data) {\n    const value = ref(null);\n    if (token === 'get') {\n        const nodeRefs = {};\n        value.value = get$1.bind(null, nodeRefs);\n        return value;\n    }\n    const path = token.split('.');\n    watchEffect(() => {\n        value.value = getValue(isRef(data) ? data.value : data, path);\n    });\n    return value;\n}\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(set, path) {\n    if (Array.isArray(set)) {\n        for (const subset of set) {\n            const value = subset !== false && getValue(subset, path);\n            if (value !== undefined)\n                return value;\n        }\n        return undefined;\n    }\n    let foundValue = undefined;\n    let obj = set;\n    for (const i in path) {\n        const key = path[i];\n        if (typeof obj !== 'object' || obj === null) {\n            foundValue = undefined;\n            break;\n        }\n        const currentValue = obj[key];\n        if (Number(i) === path.length - 1 && currentValue !== undefined) {\n            // When the value is a function, we need to bind the `this` value\n            // before providing this back to the compiler.\n            foundValue =\n                typeof currentValue === 'function'\n                    ? currentValue.bind(obj)\n                    : currentValue;\n            break;\n        }\n        obj = currentValue;\n    }\n    return foundValue;\n}\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get$1(nodeRefs, id) {\n    if (typeof id !== 'string')\n        return warn(650);\n    if (!(id in nodeRefs))\n        nodeRefs[id] = ref(undefined);\n    if (nodeRefs[id].value === undefined) {\n        nodeRefs[id].value = null;\n        const root = getNode(id);\n        if (root)\n            nodeRefs[id].value = root.context;\n        watchRegistry(id, ({ payload: node }) => {\n            nodeRefs[id].value = isNode(node) ? node.context : node;\n        });\n    }\n    return nodeRefs[id].value;\n}\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(library, schema) {\n    /**\n     * Given an if/then/else schema node, pre-compile the node and return the\n     * artifacts for the render function.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     */\n    function parseCondition(library, node) {\n        const condition = provider(compile(node.if), { if: true });\n        const children = createElements(library, node.then);\n        const alternate = node.else ? createElements(library, node.else) : null;\n        return [condition, children, alternate];\n    }\n    /**\n     * Parses a conditional if/then/else attribute statement.\n     * @param data - The data object\n     * @param attr - The attribute\n     * @param _default - The default value\n     * @returns\n     */\n    function parseConditionAttr(attr, _default) {\n        var _a, _b;\n        const condition = provider(compile(attr.if));\n        let b = () => _default;\n        let a = () => _default;\n        if (typeof attr.then === 'object') {\n            a = parseAttrs(attr.then, undefined);\n        }\n        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {\n            a = provider(compile(attr.then));\n        }\n        else {\n            a = () => attr.then;\n        }\n        if (has(attr, 'else')) {\n            if (typeof attr.else === 'object') {\n                b = parseAttrs(attr.else);\n            }\n            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {\n                b = provider(compile(attr.else));\n            }\n            else {\n                b = () => attr.else;\n            }\n        }\n        return () => (condition() ? a() : b());\n    }\n    /**\n     * Parse attributes for dynamic content.\n     * @param attrs - Object of attributes\n     * @returns\n     */\n    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n        const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\n        const setters = [\n            (attrs) => {\n                const bound = boundAttrs();\n                for (const attr in bound) {\n                    if (!explicitAttrs.has(attr)) {\n                        attrs[attr] = bound[attr];\n                    }\n                }\n            },\n        ];\n        if (unparsedAttrs) {\n            if (isConditional(unparsedAttrs)) {\n                // This is a root conditional object that must produce an object of\n                // attributes.\n                const condition = parseConditionAttr(unparsedAttrs, _default);\n                return condition;\n            }\n            // Some attributes are explicitly bound, we need to parse those ones\n            // using the compiler and create a dynamic \"setter\".\n            for (let attr in unparsedAttrs) {\n                const value = unparsedAttrs[attr];\n                let getValue;\n                const isStr = typeof value === 'string';\n                if (attr.startsWith(raw)) {\n                    // attributes prefixed with __raw__ should not be parsed\n                    attr = attr.substring(7);\n                    getValue = () => value;\n                }\n                else if (isStr &&\n                    value.startsWith('$') &&\n                    value.length > 1 &&\n                    !(value.startsWith('$reset') && isClassProp.test(attr))) {\n                    // Most attribute values starting with $ should be compiled\n                    // -class attributes starting with `$reset` should not be compiled\n                    getValue = provider(compile(value));\n                }\n                else if (typeof value === 'object' && isConditional(value)) {\n                    // Conditional attrs require further processing\n                    getValue = parseConditionAttr(value, undefined);\n                }\n                else if (typeof value === 'object' && isPojo(value)) {\n                    // Sub-parse pojos\n                    getValue = parseAttrs(value);\n                }\n                else {\n                    // In all other cases, the value is static\n                    getValue = () => value;\n                }\n                setters.push((attrs) => {\n                    attrs[attr] = getValue();\n                });\n            }\n        }\n        return () => {\n            const attrs = Array.isArray(unparsedAttrs) ? [] : {};\n            setters.forEach((setter) => setter(attrs));\n            return attrs;\n        };\n    }\n    /**\n     * Given a single schema node, parse it and extract the value.\n     * @param data - A state object provided to each node\n     * @param node - The schema node being parsed\n     * @returns\n     */\n    function parseNode(library, _node) {\n        let element = null;\n        let attrs = () => null;\n        let condition = false;\n        let children = null;\n        let alternate = null;\n        let iterator = null;\n        let resolve = false;\n        const node = sugar(_node);\n        if (isDOM(node)) {\n            // This is an actual HTML DOM element\n            element = node.$el;\n            attrs =\n                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;\n        }\n        else if (isComponent$1(node)) {\n            // This is a Vue Component\n            if (typeof node.$cmp === 'string') {\n                if (has(library, node.$cmp)) {\n                    element = library[node.$cmp];\n                }\n                else {\n                    element = node.$cmp;\n                    resolve = true;\n                }\n            }\n            else {\n                // in this case it must be an actual component\n                element = node.$cmp;\n            }\n            attrs = parseAttrs(node.props, node.bind);\n        }\n        else if (isConditional(node)) {\n            [condition, children, alternate] = parseCondition(library, node);\n        }\n        // This is the same as a \"v-if\" statement — not an if/else statement\n        if (!isConditional(node) && 'if' in node) {\n            condition = provider(compile(node.if));\n        }\n        else if (!isConditional(node) && element === null) {\n            // In this odd case our element is actually a partial and\n            // we only want to render the children.\n            condition = () => true;\n        }\n        // Compile children down to a function\n        if ('children' in node && node.children) {\n            if (typeof node.children === 'string') {\n                // We are dealing with a raw string value\n                if (node.children.startsWith('$slots.')) {\n                    // this is a lone text node, turn it into a slot\n                    element = element === 'text' ? 'slot' : element;\n                    children = provider(compile(node.children));\n                }\n                else if (node.children.startsWith('$') && node.children.length > 1) {\n                    const value = provider(compile(node.children));\n                    children = () => String(value());\n                }\n                else {\n                    children = () => String(node.children);\n                }\n            }\n            else if (Array.isArray(node.children)) {\n                // We are dealing with node sub-children\n                children = createElements(library, node.children);\n            }\n            else {\n                // This is a conditional if/else clause\n                const [childCondition, c, a] = parseCondition(library, node.children);\n                children = (iterationData) => childCondition && childCondition()\n                    ? c && c(iterationData)\n                    : a && a(iterationData);\n            }\n        }\n        if (isComponent$1(node)) {\n            if (children) {\n                // Children of components need to be provided as an object of slots\n                // so we provide an object with the default slot provided as children.\n                // We also create a new scope for this default slot, and then on each\n                // render pass the scoped slot props to the scope.\n                const produceChildren = children;\n                children = (iterationData) => {\n                    return {\n                        default(slotData, key) {\n                            var _a, _b, _c, _d;\n                            // We need to switch the current instance key back to the one that\n                            // originally called this component's render function.\n                            const currentKey = instanceKey;\n                            if (key)\n                                instanceKey = key;\n                            if (slotData)\n                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);\n                            if (iterationData)\n                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);\n                            const c = produceChildren(iterationData);\n                            // Ensure our instance key never changed during runtime\n                            if (slotData)\n                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();\n                            if (iterationData)\n                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();\n                            instanceKey = currentKey;\n                            return c;\n                        },\n                    };\n                };\n                children.slot = true;\n            }\n            else {\n                // If we dont have any children, we still need to provide an object\n                // instead of an empty array (which raises a warning in vue)\n                children = () => ({});\n            }\n        }\n        // Compile the for loop down\n        if ('for' in node && node.for) {\n            const values = node.for.length === 3 ? node.for[2] : node.for[1];\n            const getValues = typeof values === 'string' && values.startsWith('$')\n                ? provider(compile(values))\n                : () => values;\n            iterator = [\n                getValues,\n                node.for[0],\n                node.for.length === 3 ? String(node.for[1]) : null,\n            ];\n        }\n        return [condition, element, attrs, children, alternate, iterator, resolve];\n    }\n    /**\n     * Given a particular function that produces children, ensure that the second\n     * argument of all these slots is the original instance key being used to\n     * render the slots.\n     * @param children - The children() function that will produce slots\n     */\n    function createSlots(children, iterationData) {\n        const slots = children(iterationData);\n        const currentKey = instanceKey;\n        return Object.keys(slots).reduce((allSlots, slotName) => {\n            const slotFn = slots && slots[slotName];\n            allSlots[slotName] = (data) => {\n                return (slotFn && slotFn(data, currentKey)) || null;\n            };\n            return allSlots;\n        }, {});\n    }\n    /**\n     * Creates an element\n     * @param data - The context data available to the node\n     * @param node - The schema node to render\n     * @returns\n     */\n    function createElement(library, node) {\n        // Parses the schema node into pertinent parts\n        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);\n        // This is a sub-render function (called within a render function). It must\n        // only use pre-compiled features, and be organized in the most efficient\n        // manner possible.\n        let createNodes = ((iterationData) => {\n            if (condition && element === null && children) {\n                // Handle conditional if/then statements\n                return condition()\n                    ? children(iterationData)\n                    : alternate && alternate(iterationData);\n            }\n            if (element && (!condition || condition())) {\n                // handle text nodes\n                if (element === 'text' && children) {\n                    return createTextVNode(String(children()));\n                }\n                // Handle lone slots\n                if (element === 'slot' && children)\n                    return children(iterationData);\n                // Handle resolving components\n                const el = resolve ? resolveComponent(element) : element;\n                // If we are rendering slots as children, ensure their instanceKey is properly added\n                const slots = (children === null || children === void 0 ? void 0 : children.slot)\n                    ? createSlots(children, iterationData)\n                    : null;\n                // Handle dom elements and components\n                return h(el, attrs(), (slots || (children ? children(iterationData) : [])));\n            }\n            return typeof alternate === 'function'\n                ? alternate(iterationData)\n                : alternate;\n        });\n        if (iterator) {\n            const repeatedNode = createNodes;\n            const [getValues, valueName, keyName] = iterator;\n            createNodes = (() => {\n                const _v = getValues();\n                const values = !isNaN(_v)\n                    ? Array(Number(_v))\n                        .fill(0)\n                        .map((_, i) => i)\n                    : _v;\n                const fragment = [];\n                if (typeof values !== 'object')\n                    return null;\n                const instanceScope = instanceScopes.get(instanceKey) || [];\n                const isArray = Array.isArray(values);\n                for (const key in values) {\n                    if (isArray && key in Array.prototype)\n                        continue; // Fix #299\n                    const iterationData = Object.defineProperty({\n                        ...instanceScope.reduce((previousIterationData, scopedData) => {\n                            if (previousIterationData.__idata) {\n                                return { ...previousIterationData, ...scopedData };\n                            }\n                            return scopedData;\n                        }, {}),\n                        [valueName]: values[key],\n                        ...(keyName !== null\n                            ? { [keyName]: isArray ? Number(key) : key }\n                            : {}),\n                    }, '__idata', { enumerable: false, value: true });\n                    instanceScope.unshift(iterationData);\n                    fragment.push(repeatedNode.bind(null, iterationData)());\n                    instanceScope.shift();\n                }\n                return fragment;\n            });\n        }\n        return createNodes;\n    }\n    /**\n     * Given a schema, parse it and return the resulting renderable nodes.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     * @returns\n     */\n    function createElements(library, schema) {\n        if (Array.isArray(schema)) {\n            const els = schema.map(createElement.bind(null, library));\n            return (iterationData) => els.map((element) => element(iterationData));\n        }\n        // Single node to render\n        const element = createElement(library, schema);\n        return (iterationData) => element(iterationData);\n    }\n    /**\n     * Data providers produced as a result of the compiler.\n     */\n    const providers = [];\n    /**\n     * Append the requisite compiler provider and return the compiled function.\n     * @param compiled - A compiled function\n     * @returns\n     */\n    function provider(compiled, hints = {}) {\n        const compiledFns = {};\n        providers.push((callback, key) => {\n            compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));\n        });\n        return () => compiledFns[instanceKey]();\n    }\n    /**\n     * Creates a new instance of a given schema — this either comes from a\n     * memoized copy of the parsed schema or a freshly parsed version. An symbol\n     * instance key, and dataProvider functions are passed in.\n     * @param providerCallback - A function that is called for each required provider\n     * @param key - a symbol representing the current instance\n     */\n    return function createInstance(providerCallback, key) {\n        const memoKey = JSON.stringify(schema);\n        const [render, compiledProviders] = has(memo, memoKey)\n            ? memo[memoKey]\n            : [createElements(library, schema), providers];\n        memo[memoKey] = [render, compiledProviders];\n        compiledProviders.forEach((compiledProvider) => {\n            compiledProvider(providerCallback, key);\n        });\n        return () => {\n            instanceKey = key;\n            return render();\n        };\n    };\n}\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token, defaultValue) {\n    const scopedData = instanceScopes.get(instanceKey) || [];\n    let scopedValue = undefined;\n    if (scopedData.length) {\n        scopedValue = getValue(scopedData, token.split('.'));\n    }\n    return scopedValue === undefined ? defaultValue : scopedValue;\n}\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data, key) {\n    return new Proxy(data, {\n        get(...args) {\n            let data = undefined;\n            const property = args[1];\n            if (typeof property === 'string') {\n                const prevKey = instanceKey;\n                instanceKey = key;\n                data = useScope(property, undefined);\n                instanceKey = prevKey;\n            }\n            return data !== undefined ? data : Reflect.get(...args);\n        },\n    });\n}\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(instanceCreator, data, instanceKey) {\n    return instanceCreator((requirements, hints = {}) => {\n        return requirements.reduce((tokens, token) => {\n            if (token.startsWith('slots.')) {\n                const slot = token.substring(6);\n                const hasSlot = () => data.slots &&\n                    has(data.slots, slot) &&\n                    typeof data.slots[slot] === 'function';\n                if (hints.if) {\n                    // If statement — dont render the slot, check if it exists\n                    tokens[token] = hasSlot;\n                }\n                else if (data.slots) {\n                    // Render the slot with current scope data\n                    const scopedData = slotData(data, instanceKey);\n                    tokens[token] = () => hasSlot() ? data.slots[slot](scopedData) : null;\n                }\n            }\n            else {\n                const value = getRef(token, data);\n                tokens[token] = () => useScope(token, value.value);\n            }\n            return tokens;\n        }, {});\n    }, instanceKey);\n}\nlet i = 0;\n/**\n * The FormKitSchema vue component:\n *\n * @public\n */\nconst FormKitSchema = defineComponent({\n    name: 'FormKitSchema',\n    props: {\n        schema: {\n            type: [Array, Object],\n            required: true,\n        },\n        data: {\n            type: Object,\n            default: () => ({}),\n        },\n        library: {\n            type: Object,\n            default: () => ({}),\n        },\n    },\n    setup(props, context) {\n        const instance = getCurrentInstance();\n        let instanceKey = Symbol(String(i++));\n        instanceScopes.set(instanceKey, []);\n        let provider = parseSchema(props.library, props.schema);\n        let render;\n        let data;\n        // Re-parse the schema if it changes:\n        watch(() => props.schema, (newSchema, oldSchema) => {\n            var _a;\n            instanceKey = Symbol(String(i++));\n            provider = parseSchema(props.library, props.schema);\n            render = createRenderFn(provider, data, instanceKey);\n            if (newSchema === oldSchema) {\n                ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();\n            }\n        }, { deep: true });\n        // Watch the data object explicitly\n        watchEffect(() => {\n            data = Object.assign(reactive(props.data), {\n                slots: context.slots,\n            });\n            render = createRenderFn(provider, data, instanceKey);\n        });\n        return () => render();\n    },\n});\n\n/**\n * All the explicit FormKit props.\n */\nconst nativeProps = {\n    config: {\n        type: Object,\n        default: {},\n    },\n    classes: {\n        type: Object,\n        required: false,\n    },\n    delay: {\n        type: Number,\n        required: false,\n    },\n    errors: {\n        type: Array,\n        default: [],\n    },\n    inputErrors: {\n        type: Object,\n        default: () => ({}),\n    },\n    index: {\n        type: Number,\n        required: false,\n    },\n    id: {\n        type: String,\n        required: false,\n    },\n    modelValue: {\n        required: false,\n    },\n    name: {\n        type: String,\n        required: false,\n    },\n    parent: {\n        type: Object,\n        required: false,\n    },\n    plugins: {\n        type: Array,\n        default: [],\n    },\n    sectionsSchema: {\n        type: Object,\n        default: {},\n    },\n    type: {\n        type: [String, Object],\n        default: 'text',\n    },\n    validation: {\n        type: [String, Array],\n        required: false,\n    },\n    validationMessages: {\n        type: Object,\n        required: false,\n    },\n    validationRules: {\n        type: Object,\n        required: false,\n    },\n    validationLabel: {\n        type: [String, Function],\n        required: false,\n    },\n};\n/**\n * The FormKit props object.\n * @internal\n */\nconst props = nativeProps;\n\n/**\n * The symbol that represents the formkit parent injection value.\n *\n * @public\n */\nconst parentSymbol = Symbol('FormKitParent');\n/**\n * The root FormKit component.\n *\n * @public\n */\nconst FormKit = defineComponent({\n    props,\n    emits: {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        input: (_value, _node) => true,\n        inputRaw: (_value, _node) => true,\n        'update:modelValue': (_value) => true,\n        node: (node) => !!node,\n        submit: (_data, _node) => true,\n        submitRaw: (_event, _node) => true,\n        submitInvalid: (_node) => true,\n        /* eslint-enable @typescript-eslint/no-unused-vars */\n    },\n    inheritAttrs: false,\n    setup(props, context) {\n        const node = useInput(props, context);\n        if (!node.props.definition)\n            error(600, node);\n        if (node.props.definition.component) {\n            return () => {\n                var _a;\n                return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {\n                    context: node.context,\n                }, { ...context.slots });\n            };\n        }\n        const schema = ref([]);\n        const generateSchema = () => {\n            var _a, _b;\n            const schemaDefinition = (_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.definition) === null || _b === void 0 ? void 0 : _b.schema;\n            if (!schemaDefinition)\n                error(601, node);\n            schema.value =\n                typeof schemaDefinition === 'function'\n                    ? schemaDefinition({ ...props.sectionsSchema })\n                    : schemaDefinition;\n        };\n        generateSchema();\n        // If someone emits the schema event, we re-generate the schema\n        node.on('schema', generateSchema);\n        context.emit('node', node);\n        const library = node.props.definition.library;\n        // Expose the FormKitNode to template refs.\n        context.expose({ node });\n        return () => h(FormKitSchema, { schema: schema.value, data: node.context, library }, { ...context.slots });\n    },\n});\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n *\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n *\n * @internal\n */\nfunction createPlugin(app, options) {\n    app\n        .component(options.alias || 'FormKit', FormKit)\n        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);\n    return {\n        get: getNode,\n        setLocale: (locale) => {\n            var _a;\n            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {\n                options.config.rootConfig.locale = locale;\n            }\n        },\n        clearErrors,\n        setErrors,\n        submit: submitForm,\n        reset,\n    };\n}\n/**\n * The symbol key for accessing the FormKit node options.\n *\n * @public\n */\nconst optionsSymbol = Symbol.for('FormKitOptions');\n/**\n * The symbol key for accessing FormKit root configuration.\n *\n * @public\n */\nconst configSymbol = Symbol.for('FormKitConfig');\n/**\n * Create the FormKit plugin.\n *\n * @public\n */\nconst plugin = {\n    install(app, _options) {\n        /**\n         * Extend the default configuration options.\n         */\n        const options = Object.assign({\n            alias: 'FormKit',\n            schemaAlias: 'FormKitSchema',\n        }, typeof _options === 'function' ? _options() : _options);\n        /**\n         * The root configuration options.\n         */\n        const rootConfig = createConfig(options.config || {});\n        /**\n         * We dont want to explicitly provide any \"config\" options, only a root\n         * config option — so here we override the existing config options.\n         */\n        options.config = { rootConfig };\n        /**\n         * Register the global $formkit plugin property.\n         */\n        app.config.globalProperties.$formkit = createPlugin(app, options);\n        /**\n         * Provide the config to the application for injection.\n         */\n        app.provide(optionsSymbol, options);\n        /**\n         * Provide the root config to the application.\n         */\n        app.provide(configSymbol, rootConfig);\n    },\n};\n\n/**\n * Indicates that the path that was requested is no longer valid in the object.\n */\nconst invalidGet = Symbol();\n/**\n * A special watcher for Vue that reports the location of a deep mutation.\n *\n * @param obj - An object to observe at depth.\n * @param callback - A callback to call when a change is detected.\n *\n * @public\n */\nfunction watchVerbose(obj, callback) {\n    const watchers = {};\n    const applyWatch = (paths) => {\n        // Watch each property\n        for (const path of paths) {\n            // Stops pre-existing watchers at a given location to prevent dupes:\n            if (path.__str in watchers)\n                watchers[path.__str]();\n            watchers[path.__str] = watch(touch.bind(null, obj, path), dispatcher.bind(null, path), { deep: false });\n        }\n    };\n    /**\n     * Clear any watchers deeper than this path.\n     * @param path - The path to start from\n     */\n    const clearWatch = (path) => {\n        if (!path.length)\n            return;\n        for (const key in watchers) {\n            if (`${key}`.startsWith(`${path.__str}.`)) {\n                watchers[key]();\n                delete watchers[key];\n            }\n        }\n    };\n    const dispatcher = createDispatcher(obj, callback, applyWatch, clearWatch);\n    applyWatch(getPaths(obj));\n}\n/**\n * This function synchronously dispatches to the watch callbacks. It uses the\n * knowledge that the getPath function is a depth-first-search thus lower\n * specificity (lower tree nodes) will always have their watchers called first.\n * If a lower specificity watcher is triggered we want to ignore the higher\n * specificity watcher.\n * @param obj - The object to dispatch\n * @param callback - The callback function to emit\n * @param applyWatch - A way to apply watchers to update objects\n * @returns\n */\nfunction createDispatcher(obj, callback, applyWatch, clearChildWatches) {\n    // let dispatchedPaths: Record<string, ObjectPath> = {}\n    // let clear: Promise<void> | null = null\n    return (path) => {\n        const value = get(obj, path);\n        if (value === invalidGet)\n            return;\n        if (path.__deep)\n            clearChildWatches(path);\n        if (typeof value === 'object')\n            applyWatch(getPaths(value, [path], ...path));\n        callback(path, value, obj);\n    };\n}\n/**\n * \"Touches\" a given property for reactivity tracking purposes, if the value at\n * the given path is an object, we flatten it to just its keys since we will\n * already be tracking sub properties independently.\n * @param obj - A ref to traverse for a given path\n * @param path - An array of strings representing the path to locate\n * @returns\n */\nfunction touch(obj, path) {\n    const value = get(obj, path);\n    return value && typeof value === 'object' ? Object.keys(value) : value;\n}\n/**\n * \"Touches\" a given property for reactivity tracking purposes.\n * @param obj - A ref to traverse for a given path\n * @param path - An array of strings representing the path to locate\n * @returns\n */\nfunction get(obj, path) {\n    if (isRef(obj)) {\n        if (path.length === 0)\n            return obj.value;\n        obj = obj.value;\n    }\n    return path.reduce((value, segment) => {\n        if (value === invalidGet)\n            return value;\n        if (value === null || typeof value !== 'object') {\n            return invalidGet;\n        }\n        return value[segment];\n    }, obj);\n}\n/**\n * Recursively retrieves all enumerable property paths from the origination\n * object. For example:\n * ```js\n * const obj = {\n *   a: {\n *     b: 123\n *   },\n *   c: 567\n * }\n * const paths = getPaths(obj)\n * // [\n * //   ['a'],\n * //   ['a', 'b'],\n * //   ['c']\n * // ]\n * ```\n * @param obj - An object to retrieve paths for.\n * @param parents - An array of parent paths.\n * @returns\n * @internal\n */\nfunction getPaths(obj, paths = [], ...parents) {\n    if (obj === null)\n        return paths;\n    if (!parents.length) {\n        const path = Object.defineProperty([], '__str', {\n            value: '',\n        });\n        obj = isRef(obj) ? obj.value : obj;\n        if (obj && typeof obj === 'object') {\n            Object.defineProperty(path, '__deep', { value: true });\n            paths.push(path);\n        }\n        else {\n            return [path];\n        }\n    }\n    if (obj === null || typeof obj !== 'object')\n        return paths;\n    for (const key in obj) {\n        const path = parents.concat(key);\n        Object.defineProperty(path, '__str', { value: path.join('.') });\n        const value = obj[key];\n        if (isPojo(value) || Array.isArray(value)) {\n            paths.push(Object.defineProperty(path, '__deep', { value: true }));\n            paths = paths.concat(getPaths(value, [], ...path));\n        }\n        else {\n            paths.push(path);\n        }\n    }\n    return paths;\n}\n\n/**\n * Gets the raw underlying target object from a Vue Ref or Reactive object.\n * @param obj - Get the underlying target object, or no-op.\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction useRaw(obj) {\n    if (obj === null || typeof obj !== 'object')\n        return obj;\n    if (isReactive(obj)) {\n        obj = toRaw(obj);\n    }\n    else if (isRef(obj)) {\n        obj = (isReactive(obj.value) ? useRaw(obj.value) : obj.value);\n    }\n    return obj;\n}\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = [\n    'help',\n    'label',\n    'ignore',\n    'disabled',\n    'preserve',\n    /^preserve(-e|E)rrors/,\n    /^[a-z]+(?:-visibility|Visibility|-behavior|Behavior)$/,\n    /^[a-zA-Z-]+(?:-class|Class)$/,\n    'prefixIcon',\n    'suffixIcon',\n    /^[a-zA-Z-]+(?:-icon|Icon)$/,\n];\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node, props) {\n    if (props.classes) {\n        Object.keys(props.classes).forEach((key) => {\n            if (typeof key === 'string') {\n                node.props[`_${key}Class`] = props.classes[key];\n                // We need to ensure Vue is aware that we want to actually observe the\n                // child values too, so we touch them here.\n                if (isObject(props.classes[key]) && key === 'inner')\n                    Object.values(props.classes[key]);\n            }\n        });\n    }\n}\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(props) {\n    if (!props)\n        return {};\n    const knownListeners = ['Submit', 'SubmitRaw', 'SubmitInvalid'].reduce((listeners, listener) => {\n        const name = `on${listener}`;\n        if (name in props) {\n            if (typeof props[name] === 'function') {\n                listeners[name] = props[name];\n            }\n        }\n        return listeners;\n    }, {});\n    return knownListeners;\n}\n/**\n * A composable for creating a new FormKit node.\n *\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" — which is really the attrs list.\n *\n * @returns {@link @formkit/core#FormKitNode | FormKitNode}\n *\n * @public\n */\nfunction useInput(props, context, options = {}) {\n    var _a;\n    /**\n     * The configuration options, these are provided by either the plugin or by\n     * explicit props.\n     */\n    const config = Object.assign({}, inject(optionsSymbol) || {}, options);\n    /**\n     * The current instance.\n     */\n    const instance = getCurrentInstance();\n    /**\n     * Extracts the listeners.\n     */\n    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);\n    /**\n     * Determines if the prop is v-modeled. Credit to:\n     * {@link https://github.com/LinusBorg | Thorsten Lünborg}\n     * for coming up with this solution.\n     */\n    const isVModeled = 'modelValue' in ((_a = instance === null || instance === void 0 ? void 0 : instance.vnode.props) !== null && _a !== void 0 ? _a : {});\n    /**\n     * Determines if the object being passed as a v-model is reactive.\n     */\n    // const isReactiveVModel = isVModeled && isReactive(props.modelValue)\n    /**\n     * Define the initial component\n     */\n    const value = props.modelValue !== undefined\n        ? props.modelValue\n        : cloneAny(context.attrs.value);\n    /**\n     * Creates the node's initial props from the context, props, and definition\n     * @returns\n     */\n    function createInitialProps() {\n        const initialProps = {\n            ...nodeProps(props),\n            ...listeners,\n        };\n        const attrs = except(nodeProps(context.attrs), pseudoProps);\n        if (!attrs.key)\n            attrs.key = token();\n        initialProps.attrs = attrs;\n        const propValues = only(nodeProps(context.attrs), pseudoProps);\n        for (const propName in propValues) {\n            initialProps[camel(propName)] = propValues[propName];\n        }\n        const classesProps = { props: {} };\n        classesToNodeProps(classesProps, props);\n        Object.assign(initialProps, classesProps.props);\n        if (typeof initialProps.type !== 'string') {\n            initialProps.definition = initialProps.type;\n            delete initialProps.type;\n        }\n        return initialProps;\n    }\n    /**\n     * Create the FormKitNode.\n     */\n    const initialProps = createInitialProps();\n    /**\n     * The parent node.\n     */\n    const parent = initialProps.ignore\n        ? null\n        : props.parent || inject(parentSymbol, null);\n    const node = createNode(extend(config || {}, {\n        name: props.name || undefined,\n        value,\n        parent,\n        plugins: (config.plugins || []).concat(props.plugins),\n        config: props.config,\n        props: initialProps,\n        index: props.index,\n    }, false, true));\n    /**\n     * If no definition has been assigned at this point — we're out!\n     */\n    if (!node.props.definition)\n        error(600, node);\n    /**\n     * All props that are bound \"late\" (after node creation) — are added to a set\n     * which is used to watch the context.attrs object.\n     */\n    const lateBoundProps = ref(new Set(node.props.definition.props || []));\n    /**\n     * Any additional props added at a \"later\" time should also be part of the\n     * late bound props.\n     */\n    node.on('added-props', ({ payload: lateProps }) => {\n        if (Array.isArray(lateProps))\n            lateProps.forEach((newProp) => lateBoundProps.value.add(newProp));\n    });\n    /**\n     * These prop names must be assigned.\n     */\n    const pseudoPropNames = computed(() => pseudoProps.concat([...lateBoundProps.value]).reduce((names, prop) => {\n        if (typeof prop === 'string') {\n            names.push(camel(prop));\n            names.push(kebab(prop));\n        }\n        else {\n            names.push(prop);\n        }\n        return names;\n    }, []));\n    /* Splits Classes object into discrete props for each key */\n    watchEffect(() => classesToNodeProps(node, props));\n    /**\n     * The props object already has properties even if they start as \"undefined\"\n     * so we can loop over them and individual watchEffect to prevent responding\n     * inappropriately.\n     */\n    const passThrough = nodeProps(props);\n    for (const prop in passThrough) {\n        watch(() => props[prop], () => {\n            if (props[prop] !== undefined) {\n                node.props[prop] = props[prop];\n            }\n        });\n    }\n    /**\n     * Watch \"pseudoProp\" attributes explicitly.\n     */\n    const attributeWatchers = new Set();\n    const possibleProps = nodeProps(context.attrs);\n    watchEffect(() => {\n        watchAttributes(only(possibleProps, pseudoPropNames.value));\n    });\n    /**\n     * Defines attributes that should be used as props.\n     * @param attrProps - Attributes that should be used as props instead\n     */\n    function watchAttributes(attrProps) {\n        attributeWatchers.forEach((stop) => {\n            stop();\n            attributeWatchers.delete(stop);\n        });\n        for (const prop in attrProps) {\n            const camelName = camel(prop);\n            attributeWatchers.add(watch(() => context.attrs[prop], () => {\n                node.props[camelName] = context.attrs[prop];\n            }));\n        }\n    }\n    /**\n     * Watch and dynamically set attribute values, those values that are not\n     * props and are not pseudoProps\n     */\n    watchEffect(() => {\n        const attrs = except(nodeProps(context.attrs), pseudoPropNames.value);\n        // An explicit exception to ensure naked \"multiple\" attributes appear on the\n        // outer wrapper as data-multiple=\"true\"\n        if ('multiple' in attrs)\n            attrs.multiple = undefine(attrs.multiple);\n        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n    });\n    /**\n     * Add any/all \"prop\" errors to the store.\n     */\n    watchEffect(() => {\n        const messages = props.errors.map((error) => createMessage({\n            key: slugify(error),\n            type: 'error',\n            value: error,\n            meta: { source: 'prop' },\n        }));\n        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');\n    });\n    /**\n     * Add input errors.\n     */\n    if (node.type !== 'input') {\n        const sourceKey = `${node.name}-prop`;\n        watchEffect(() => {\n            const keys = Object.keys(props.inputErrors);\n            if (!keys.length)\n                node.clearErrors(true, sourceKey);\n            const messages = keys.reduce((messages, key) => {\n                let value = props.inputErrors[key];\n                if (typeof value === 'string')\n                    value = [value];\n                if (Array.isArray(value)) {\n                    messages[key] = value.map((error) => createMessage({\n                        key: error,\n                        type: 'error',\n                        value: error,\n                        meta: { source: sourceKey },\n                    }));\n                }\n                return messages;\n            }, {});\n            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);\n        });\n    }\n    /**\n     * Watch the config prop for any changes.\n     */\n    watchEffect(() => Object.assign(node.config, props.config));\n    /**\n     * Produce another parent object.\n     */\n    if (node.type !== 'input') {\n        provide(parentSymbol, node);\n    }\n    let inputTimeout;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const mutex = new WeakSet();\n    /**\n     * Explicitly watch the input value, and emit changes (lazy)\n     */\n    node.on('modelUpdated', () => {\n        var _a, _b;\n        // Emit the values after commit\n        context.emit('inputRaw', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value, node);\n        clearTimeout(inputTimeout);\n        inputTimeout = setTimeout(context.emit, 20, 'input', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value, node);\n        if (isVModeled && node.context) {\n            const newValue = useRaw(node.context.value);\n            if (isObject(newValue) && useRaw(props.modelValue) !== newValue) {\n                // If this is an object that has been mutated inside FormKit core then\n                // we know when it is emitted it will \"return\" in the watchVerbose so\n                // we pro-actively add it to the mutex.\n                mutex.add(newValue);\n            }\n            context.emit('update:modelValue', newValue);\n        }\n    });\n    /**\n     * Enabled support for v-model, using this for groups/lists is not recommended\n     */\n    if (isVModeled) {\n        watchVerbose(toRef(props, 'modelValue'), (path, value) => {\n            var _a;\n            const rawValue = useRaw(value);\n            if (isObject(rawValue) && mutex.has(rawValue)) {\n                return mutex.delete(rawValue);\n            }\n            if (!path.length)\n                node.input(value, false);\n            else\n                (_a = node.at(path)) === null || _a === void 0 ? void 0 : _a.input(value, false);\n        });\n        /**\n         * On initialization, if the node’s value was updated (like in a plugin\n         * hook) then we should emit a `modelUpdated` event.\n         */\n        if (node.value !== value) {\n            node.emit('modelUpdated');\n        }\n    }\n    /**\n     * When this input shuts down, we need to \"delete\" the node too.\n     */\n    // onUnmounted(() => node.destroy())\n    onBeforeUnmount(() => node.destroy());\n    return node;\n}\n\nlet totalCreated = 1;\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj) {\n    return ((typeof obj === 'function' && obj.length === 2) ||\n        (typeof obj === 'object' &&\n            !Array.isArray(obj) &&\n            !('$el' in obj) &&\n            !('$cmp' in obj) &&\n            !('if' in obj)));\n}\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input or the component.\n * @param definitionOptions - Any options in the FormKitTypeDefinition you want\n * to define.\n *\n * @returns {@link @formkit/core#FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @public\n */\nfunction createInput(schemaOrComponent, definitionOptions = {}) {\n    const definition = {\n        type: 'input',\n        ...definitionOptions,\n    };\n    let schema;\n    if (isComponent(schemaOrComponent)) {\n        const cmpName = `SchemaComponent${totalCreated++}`;\n        schema = createSection('input', () => ({\n            $cmp: cmpName,\n            props: {\n                context: '$node.context',\n            },\n        }));\n        definition.library = { [cmpName]: markRaw(schemaOrComponent) };\n    }\n    else if (typeof schemaOrComponent === 'function') {\n        schema = schemaOrComponent;\n    }\n    else {\n        schema = createSection('input', () => cloneAny(schemaOrComponent));\n    }\n    // Use the default wrapping schema\n    definition.schema = useSchema(schema || 'Schema undefined');\n    return definition;\n}\n\n/**\n * @internal\n */\nconst messages = createSection('messages', () => ({\n    $el: 'ul',\n    if: '$fns.length($messages)',\n}), true);\n/**\n * @internal\n */\nconst message = createSection('message', () => ({\n    $el: 'li',\n    for: ['message', '$messages'],\n    attrs: {\n        key: '$message.key',\n        id: `$id + '-' + $message.key`,\n        'data-message-type': '$message.type',\n    },\n}));\n/**\n * The actual schema to render for the messages.\n */\nconst definition = messages(message('$message.value'));\n/**\n * Renders the messages for a parent node, or any node explicitly passed to it.\n * @public\n */\nconst FormKitMessages = defineComponent({\n    props: {\n        node: {\n            type: Object,\n            required: false,\n        },\n        sectionsSchema: {\n            type: Object,\n            default: {},\n        },\n        defaultPosition: {\n            type: [String, Boolean],\n            default: false,\n        },\n    },\n    setup(props, context) {\n        const node = computed(() => {\n            return props.node || inject(parentSymbol, undefined);\n        });\n        watch(node, () => {\n            var _a;\n            if (((_a = node.value) === null || _a === void 0 ? void 0 : _a.context) && !undefine(props.defaultPosition)) {\n                node.value.context.defaultMessagePlacement = false;\n            }\n        }, { immediate: true });\n        const schema = definition(props.sectionsSchema || {});\n        const data = computed(() => {\n            var _a, _b, _c, _d, _e, _f;\n            return {\n                messages: ((_b = (_a = node.value) === null || _a === void 0 ? void 0 : _a.context) === null || _b === void 0 ? void 0 : _b.messages) || {},\n                fns: ((_d = (_c = node.value) === null || _c === void 0 ? void 0 : _c.context) === null || _d === void 0 ? void 0 : _d.fns) || {},\n                classes: ((_f = (_e = node.value) === null || _e === void 0 ? void 0 : _e.context) === null || _f === void 0 ? void 0 : _f.classes) || {},\n            };\n        });\n        return () => {\n            var _a;\n            return ((_a = node.value) === null || _a === void 0 ? void 0 : _a.context)\n                ? h(FormKitSchema, { schema, data: data.value }, { ...context.slots })\n                : null;\n        };\n    },\n});\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n *\n * @param node - FormKitNode to create the context on.\n *\n * @public\n */\nconst vueBindings = function vueBindings(node) {\n    /**\n     * Start a validity counter on all blocking messages.\n     */\n    node.ledger.count('blocking', (m) => m.blocking);\n    const isValid = ref(!node.ledger.value('blocking'));\n    /**\n     * Start an error message counter.\n     */\n    node.ledger.count('errors', (m) => m.type === 'error');\n    const hasErrors = ref(!!node.ledger.value('errors'));\n    /**\n     * Keep track of the first time a Vue tick cycle has passed.\n     */\n    let hasTicked = false;\n    nextTick(() => {\n        hasTicked = true;\n    });\n    /**\n     * All messages with the visibility state set to true.\n     */\n    const availableMessages = reactive(node.store.reduce((store, message) => {\n        if (message.visible) {\n            store[message.key] = message;\n        }\n        return store;\n    }, {}));\n    /**\n     * A flag that determines when validation messages should be displayed.\n     */\n    const validationVisibility = ref(node.props.validationVisibility || 'blur');\n    node.on('prop:validationVisibility', ({ payload }) => {\n        validationVisibility.value = payload;\n    });\n    /**\n     * Keep track of if this input has ever shown validation errors.\n     */\n    const hasShownErrors = ref(validationVisibility.value === 'live');\n    /**\n     * The current visibility state of validation messages.\n     */\n    const validationVisible = computed(() => {\n        if (context.state.submitted)\n            return true;\n        if (!hasShownErrors.value && !context.state.settled) {\n            return false;\n        }\n        switch (validationVisibility.value) {\n            case 'live':\n                return true;\n            case 'blur':\n                return context.state.blurred;\n            case 'dirty':\n                return context.state.dirty;\n            default:\n                return false;\n        }\n    });\n    /**\n     * Determines if the input should be considered \"complete\".\n     */\n    const isComplete = computed(() => {\n        return hasValidation.value\n            ? isValid.value && !hasErrors.value\n            : context.state.dirty && !empty(context.value);\n    });\n    /**\n     * If the input has validation rules or not.\n     */\n    const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);\n    node.on('prop:parsedRules', ({ payload: rules }) => {\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\n    });\n    /**\n     * All messages that are currently on display to an end user. This changes\n     * based on the current message type visibility, like errorVisibility.\n     */\n    const messages = computed(() => {\n        const visibleMessages = {};\n        for (const key in availableMessages) {\n            const message = availableMessages[key];\n            if (message.type !== 'validation' || validationVisible.value) {\n                visibleMessages[key] = message;\n            }\n        }\n        return visibleMessages;\n    });\n    /**\n     * UI Messages.\n     */\n    const ui = reactive(node.store.reduce((messages, message) => {\n        if (message.type === 'ui' && message.visible)\n            messages[message.key] = message;\n        return messages;\n    }, {}));\n    /**\n     * This is the reactive data object that is provided to all schemas and\n     * forms. It is a subset of data in the core node object.\n     */\n    const cachedClasses = reactive({});\n    const classes = new Proxy(cachedClasses, {\n        get(...args) {\n            const [target, property] = args;\n            let className = Reflect.get(...args);\n            if (!className && typeof property === 'string') {\n                if (!has(target, property) && !property.startsWith('__v')) {\n                    const observedNode = createObserver(node);\n                    observedNode.watch((node) => {\n                        const rootClasses = typeof node.config.rootClasses === 'function'\n                            ? node.config.rootClasses(property, node)\n                            : {};\n                        const globalConfigClasses = node.config.classes\n                            ? createClasses(property, node, node.config.classes[property])\n                            : {};\n                        const classesPropClasses = createClasses(property, node, node.props[`_${property}Class`]);\n                        const sectionPropClasses = createClasses(property, node, node.props[`${property}Class`]);\n                        className = generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);\n                        target[property] = className !== null && className !== void 0 ? className : '';\n                    });\n                }\n            }\n            return className;\n        },\n    });\n    const describedBy = computed(() => {\n        const describers = [];\n        if (context.help) {\n            describers.push(`help-${node.props.id}`);\n        }\n        for (const key in messages.value) {\n            describers.push(`${node.props.id}-${key}`);\n        }\n        return describers.length ? describers.join(' ') : undefined;\n    });\n    const value = ref(node.value);\n    const _value = ref(node.value);\n    const context = reactive({\n        _value,\n        attrs: node.props.attrs,\n        disabled: node.props.disabled,\n        describedBy,\n        fns: {\n            length: (obj) => Object.keys(obj).length,\n            number: (value) => Number(value),\n            string: (value) => String(value),\n            json: (value) => JSON.stringify(value),\n            eq,\n        },\n        handlers: {\n            blur: (e) => {\n                node.store.set(createMessage({ key: 'blurred', visible: false, value: true }));\n                if (typeof node.props.attrs.onBlur === 'function') {\n                    node.props.attrs.onBlur(e);\n                }\n            },\n            touch: () => {\n                var _a;\n                const doCompare = context.dirtyBehavior === 'compare';\n                if (((_a = node.store.dirty) === null || _a === void 0 ? void 0 : _a.value) && !doCompare)\n                    return;\n                const isDirty = !eq(node.props._init, node._value);\n                if (!isDirty && !doCompare)\n                    return;\n                node.store.set(createMessage({ key: 'dirty', visible: false, value: isDirty }));\n            },\n            DOMInput: (e) => {\n                node.input(e.target.value);\n                node.emit('dom-input-event', e);\n            },\n        },\n        help: node.props.help,\n        id: node.props.id,\n        label: node.props.label,\n        messages,\n        node: markRaw(node),\n        options: node.props.options,\n        defaultMessagePlacement: true,\n        state: {\n            blurred: false,\n            complete: isComplete,\n            dirty: false,\n            submitted: false,\n            settled: node.isSettled,\n            valid: isValid,\n            errors: hasErrors,\n            rules: hasValidation,\n            validationVisible,\n        },\n        type: node.props.type,\n        family: node.props.family,\n        ui,\n        value,\n        classes,\n    });\n    /**\n     * Ensure the context object is properly configured after booting up.\n     */\n    node.on('created', () => {\n        if (!eq(context.value, node.value)) {\n            _value.value = node.value;\n            value.value = node.value;\n            triggerRef(value);\n            triggerRef(_value);\n        }\n        (async () => {\n            await node.settled;\n            node.props._init = cloneAny(node.value);\n        })();\n    });\n    /**\n     * Sets the settled state.\n     */\n    node.on('settled', ({ payload: isSettled }) => {\n        context.state.settled = isSettled;\n    });\n    /**\n     * Observes node.props properties explicitly and updates them in the context\n     * object.\n     * @param observe - Props to observe and register as context data.\n     */\n    function observeProps(observe) {\n        observe.forEach((prop) => {\n            prop = camel(prop);\n            if (!has(context, prop) && has(node.props, prop)) {\n                context[prop] = node.props[prop];\n            }\n            node.on(`prop:${prop}`, ({ payload }) => {\n                context[prop] = payload;\n            });\n        });\n    }\n    /**\n     * We use a node observer to individually observe node props.\n     */\n    const rootProps = () => {\n        const props = [\n            'help',\n            'label',\n            'disabled',\n            'options',\n            'type',\n            'attrs',\n            'preserve',\n            'preserveErrors',\n            'id',\n            'dirtyBehavior',\n        ];\n        const iconPattern = /^[a-zA-Z-]+(?:-icon|Icon)$/;\n        const matchingProps = Object.keys(node.props).filter((prop) => {\n            return iconPattern.test(prop);\n        });\n        return props.concat(matchingProps);\n    };\n    observeProps(rootProps());\n    /**\n     * Once the input is defined, deal with it.\n     * @param definition - Type definition.\n     */\n    function definedAs(definition) {\n        if (definition.props)\n            observeProps(definition.props);\n    }\n    node.props.definition && definedAs(node.props.definition);\n    /**\n     * When new props are added to the core node as \"props\" (ie not attrs) then\n     * we automatically need to start tracking them here.\n     */\n    node.on('added-props', ({ payload }) => observeProps(payload));\n    /**\n     * Watch for input events from core.\n     */\n    node.on('input', ({ payload }) => {\n        if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n            _value.value = shallowClone(payload);\n        }\n        else {\n            _value.value = payload;\n            triggerRef(_value);\n        }\n    });\n    /**\n     * Watch for input commits from core.\n     */\n    node.on('commit', ({ payload }) => {\n        if (node.type !== 'input' && !isRef(payload) && !isReactive(payload)) {\n            value.value = _value.value = shallowClone(payload);\n        }\n        else {\n            value.value = _value.value = payload;\n            triggerRef(value);\n        }\n        node.emit('modelUpdated');\n        // The input is dirty after a value has been input by a user\n        if ((!context.state.dirty || context.dirtyBehavior === 'compare') &&\n            node.isCreated &&\n            hasTicked) {\n            context.handlers.touch();\n        }\n        if (isComplete &&\n            node.type === 'input' &&\n            hasErrors.value &&\n            !undefine(node.props.preserveErrors)) {\n            node.store.filter((message) => { var _a; return !(message.type === 'error' && ((_a = message.meta) === null || _a === void 0 ? void 0 : _a.autoClear) === true); });\n        }\n    });\n    /**\n     * Update the local state in response to messages.\n     * @param message - A formkit message\n     */\n    const updateState = async (message) => {\n        if (message.type === 'ui' &&\n            message.visible &&\n            !message.meta.showAsMessage) {\n            ui[message.key] = message;\n        }\n        else if (message.visible) {\n            availableMessages[message.key] = message;\n        }\n        else if (message.type === 'state') {\n            // await node.settled\n            context.state[message.key] = !!message.value;\n        }\n    };\n    /**\n     * Listen to message events and modify the local message data values.\n     */\n    node.on('message-added', (e) => updateState(e.payload));\n    node.on('message-updated', (e) => updateState(e.payload));\n    node.on('message-removed', ({ payload: message }) => {\n        delete ui[message.key];\n        delete availableMessages[message.key];\n        delete context.state[message.key];\n    });\n    node.on('settled:blocking', () => {\n        isValid.value = true;\n    });\n    node.on('unsettled:blocking', () => {\n        isValid.value = false;\n    });\n    node.on('settled:errors', () => {\n        hasErrors.value = false;\n    });\n    node.on('unsettled:errors', () => {\n        hasErrors.value = true;\n    });\n    /**\n     * Watch the validation visible prop and set the hasShownErrors state.\n     */\n    watch(validationVisible, (value) => {\n        if (value) {\n            hasShownErrors.value = true;\n        }\n    });\n    node.context = context;\n    // The context is complete\n    node.emit('context', node, false);\n};\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n *\n * @public\n */\nconst defaultConfig = (options = {}) => {\n    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, theme = undefined, iconLoaderUrl = undefined, iconLoader = undefined, icons = {}, ...nodeOptions } = options;\n    /**\n     * The default configuration includes the validation plugin,\n     * with all core-available validation rules.\n     */\n    const validation = createValidationPlugin({\n        ...defaultRules,\n        ...(rules || {}),\n    });\n    /**\n     * Includes the i18n plugin with only the english language\n     * messages.\n     */\n    const i18n = createI18nPlugin(extend({ en, ...(locales || {}) }, messages));\n    /**\n     * Create the library of inputs that are generally available. This default\n     * config imports all \"native\" inputs by default, but\n     */\n    const library = createLibraryPlugin(inputs, inputs$1);\n    /**\n     * Create the theme plugin for the user provided theme\n     */\n    const themePlugin = createThemePlugin(theme, icons, iconLoaderUrl, iconLoader);\n    return extend({\n        plugins: [library, themePlugin, vueBindings, i18n, validation],\n        ...(!locale ? {} : { config: { locale } }),\n    }, nodeOptions || {}, true);\n};\n\n/**\n * Renders an icon using the current IconLoader set at the root FormKit config\n *\n * @public\n */\nconst FormKitIcon = defineComponent({\n    name: 'FormKitIcon',\n    props: {\n        icon: {\n            type: String,\n            default: ''\n        },\n        iconLoader: {\n            type: Function,\n            default: null\n        },\n        iconLoaderUrl: {\n            type: Function,\n            default: null\n        }\n    },\n    setup(props) {\n        var _a, _b;\n        const icon = ref(undefined);\n        const config = inject(optionsSymbol, {});\n        const parent = inject(parentSymbol, null);\n        let iconHandler = undefined;\n        function loadIcon() {\n            if (!iconHandler || typeof iconHandler !== 'function')\n                return;\n            const iconOrPromise = iconHandler(props.icon);\n            if (iconOrPromise instanceof Promise) {\n                iconOrPromise.then((iconValue) => {\n                    icon.value = iconValue;\n                });\n            }\n            else {\n                icon.value = iconOrPromise;\n            }\n        }\n        if (props.iconLoader && typeof props.iconLoader === 'function') {\n            // if we have a locally supplied loader, then use it\n            iconHandler = createIconHandler(props.iconLoader);\n        }\n        else if (parent && ((_a = parent.props) === null || _a === void 0 ? void 0 : _a.iconLoader)) {\n            // otherwise try to inherit from a parent\n            iconHandler = createIconHandler(parent.props.iconLoader);\n        }\n        else if (props.iconLoaderUrl && typeof props.iconLoaderUrl === 'function') {\n            iconHandler = createIconHandler(iconHandler, props.iconLoaderUrl);\n        }\n        else {\n            // grab our iconHandler from the global config\n            const iconPlugin = (_b = config === null || config === void 0 ? void 0 : config.plugins) === null || _b === void 0 ? void 0 : _b.find(plugin => {\n                return typeof plugin.iconHandler === 'function';\n            });\n            if (iconPlugin) {\n                iconHandler = iconPlugin.iconHandler;\n            }\n        }\n        watch(() => props.icon, () => {\n            loadIcon();\n        }, { immediate: true });\n        return () => {\n            if (props.icon && icon.value) {\n                return h('span', {\n                    class: 'formkit-icon',\n                    innerHTML: icon.value\n                });\n            }\n            return null;\n        };\n    }\n});\n\nexport { FormKit, FormKitIcon, FormKitMessages, FormKitSchema, vueBindings as bindings, configSymbol, createInput, defaultConfig, optionsSymbol, parentSymbol, plugin, useInput, watchVerbose };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}