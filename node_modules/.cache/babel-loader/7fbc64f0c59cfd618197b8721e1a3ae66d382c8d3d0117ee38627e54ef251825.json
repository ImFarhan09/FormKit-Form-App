{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array.unshift.js\";\nimport { token, has, slugify, cloneAny, init, clone, camel, undefine, eq, kebab, dedupe, parseArgs, getAt, isQuotedString, rmEscapes } from '@formkit/utils';\n\n/**\n * Creates a new dispatcher that allows the addition/removal of middleware\n * functions, and the ability to dispatch a payload to all middleware.\n *\n * @returns FormKitDispatcher\n *\n * @internal\n */\nfunction createDispatcher() {\n  const middleware = [];\n  let currentIndex = 0;\n  const use = dispatchable => middleware.push(dispatchable);\n  const dispatch = payload => {\n    const current = middleware[currentIndex];\n    if (typeof current === 'function') {\n      return current(payload, explicitPayload => {\n        currentIndex++;\n        return dispatch(explicitPayload === undefined ? payload : explicitPayload);\n      });\n    }\n    currentIndex = 0;\n    return payload;\n  };\n  use.dispatch = dispatch;\n  use.unshift = dispatchable => middleware.unshift(dispatchable);\n  use.remove = dispatchable => {\n    const index = middleware.indexOf(dispatchable);\n    if (index > -1) middleware.splice(index, 1);\n  };\n  return use;\n}\n\n/**\n * Creates a new event emitter, each node uses one of these to allow it to emit\n * events to local listeners and tree listeners.\n *\n * @returns FormKitEventEmitter\n *\n * @internal\n */\nfunction createEmitter() {\n  const listeners = new Map();\n  const receipts = new Map();\n  let buffer = undefined;\n  const emitter = (node, event) => {\n    if (buffer) {\n      buffer.set(event.name, [node, event]);\n      return;\n    }\n    if (listeners.has(event.name)) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      listeners.get(event.name).forEach(wrapper => {\n        if (event.origin === node || wrapper.modifiers.includes('deep')) {\n          wrapper.listener(event);\n        }\n      });\n    }\n    if (event.bubble) {\n      node.bubble(event);\n    }\n  };\n  /**\n   * Add an event listener\n   *\n   * @param eventName - The name of the event to listen to\n   * @param listener - The callback\n   *\n   * @returns string\n   *\n   * @internal\n   */\n  emitter.on = (eventName, listener) => {\n    const [event, ...modifiers] = eventName.split('.');\n    const receipt = listener.receipt || token();\n    const wrapper = {\n      modifiers,\n      event,\n      listener,\n      receipt\n    };\n    /* eslint-disable @typescript-eslint/no-non-null-assertion */\n    listeners.has(event) ? listeners.get(event).push(wrapper) : listeners.set(event, [wrapper]);\n    receipts.has(receipt) ? receipts.get(receipt).push(event) : receipts.set(receipt, [event]);\n    /* eslint-enable @typescript-eslint/no-non-null-assertion */\n    return receipt;\n  };\n  /**\n   * Remove an event listener\n   *\n   * @param listenerOrReceipt - Either a receipt or the callback function.\n   *\n   * @internal\n   */\n  emitter.off = receipt => {\n    var _a;\n    if (receipts.has(receipt)) {\n      (_a = receipts.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach(event => {\n        const eventListeners = listeners.get(event);\n        if (Array.isArray(eventListeners)) {\n          listeners.set(event, eventListeners.filter(wrapper => wrapper.receipt !== receipt));\n        }\n      });\n      receipts.delete(receipt);\n    }\n  };\n  /**\n   * Pause emitting values. Any events emitted while paused will not be emitted\n   * but rather \"stored\" — and whichever events are emitted last will be output.\n   * For example:\n   * pause()\n   * emit('foo', 1)\n   * emit('foo', 2)\n   * emit('bar', 3)\n   * emit('bar', 4)\n   * play()\n   * // would result in\n   * emit('foo', 2)\n   * emit('bar', 4)\n   * Optionally pauses all children as well.\n   *\n   * @param node - A node to pause all children on.\n   *\n   * @internal\n   */\n  emitter.pause = node => {\n    if (!buffer) buffer = new Map();\n    if (node) {\n      node.walk(child => child._e.pause());\n    }\n  };\n  /**\n   * Release the current event buffer.\n   *\n   * @param node - A node to unpause all children on.\n   *\n   * @internal\n   */\n  emitter.play = node => {\n    if (!buffer) return;\n    const events = buffer;\n    buffer = undefined;\n    events.forEach(([node, event]) => emitter(node, event));\n    if (node) {\n      node.walk(child => child._e.play());\n    }\n  };\n  return emitter;\n}\n/**\n * Emit an event from this node.\n *\n * @param node - The node that is emitting\n * @param context - The context of that node\n * @param name - The name of the event\n * @param payload - The payload to emit\n *\n * @returns FormKitNode\n *\n * @internal\n */\nfunction emit$1(node, context, name, payload,\n// eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\nbubble = true) {\n  context._e(node, {\n    payload,\n    name,\n    bubble,\n    origin: node\n  });\n  return node;\n}\n/**\n * Send an event from the given node up it's ancestor tree.\n *\n * @param node -\n * @param _context -\n * @param event -\n *\n * @internal\n */\nfunction bubble(node, _context, event) {\n  if (isNode(node.parent)) {\n    node.parent._e(node.parent, event);\n  }\n  return node;\n}\n/**\n * Adds an event listener to the node for a specific event. The event name is a\n * simple string matching the name of the event to listen to. It can optionally\n * include modifiers like eventName.deep\n *\n * @param node -\n * @param context -\n * @param name -\n * @param listener -\n *\n * @returns FormKitNode\n *\n * @internal\n */\nfunction on(_node, context, name, listener) {\n  return context._e.on(name, listener);\n}\n/**\n * Removes an event listener from a node by the returned receipt from .on().\n *\n * @param node - The node to remote the listener from\n * @param context - The context to remove\n * @param receipt - The receipt returned by .on()\n *\n * @returns FormKitNode\n *\n * @internal\n */\nfunction off(node, context, receipt) {\n  context._e.off(receipt);\n  return node;\n}\n\n/**\n * FormKit's global error handler.\n *\n * @public\n */\nconst errorHandler = createDispatcher();\nerrorHandler((error, next) => {\n  if (!error.message) error.message = String(`E${error.code}`);\n  return next(error);\n});\n/**\n * FormKit's global warning handler.\n *\n * @public\n */\nconst warningHandler = createDispatcher();\nwarningHandler((warning, next) => {\n  if (!warning.message) warning.message = String(`W${warning.code}`);\n  const result = next(warning);\n  if (console && typeof console.warn === 'function') console.warn(result.message);\n  return result;\n});\n/**\n * Globally emits a warning.\n *\n * @param code - The integer warning code.\n * @param data - Usually an object of information to include.\n *\n * @public\n */\nfunction warn(code, data = {}) {\n  warningHandler.dispatch({\n    code,\n    data\n  });\n}\n/**\n * Emits an error. Generally should result in an exception.\n *\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n *\n * @public\n */\nfunction error(code, data = {}) {\n  throw Error(errorHandler.dispatch({\n    code,\n    data\n  }).message);\n}\n\n/**\n * Creates a new FormKitMessage object.\n *\n * @param conf - An object of optional properties of {@link FormKitMessage | FormKitMessage}.\n * @param node - A {@link @formkit/node#FormKitNode | FormKitNode}.\n *\n * @returns A {@link FormKitMessageProps | FormKitMessageProps}.\n *\n * @public\n */\nfunction createMessage(conf, node) {\n  const m = {\n    blocking: false,\n    key: token(),\n    meta: {},\n    type: 'state',\n    visible: true,\n    ...conf\n  };\n  if (node && m.value && m.meta.localize !== false) {\n    m.value = node.t(m);\n    m.meta.locale = node.config.locale;\n  }\n  return m;\n}\n/**\n * The available traps on the node's store.\n *\n * @internal\n */\nconst storeTraps = {\n  apply: applyMessages,\n  set: setMessage,\n  remove: removeMessage,\n  filter: filterMessages,\n  reduce: reduceMessages,\n  release: releaseBuffer,\n  touch: touchMessages\n};\n/**\n * Creates a new FormKit message store.\n *\n * @internal\n */\nfunction createStore(_buffer = false) {\n  const messages = {};\n  let node;\n  let buffer = _buffer;\n  let _b = [];\n  const _m = new Map();\n  let _r = undefined;\n  const store = new Proxy(messages, {\n    get(...args) {\n      const [_target, property] = args;\n      if (property === 'buffer') return buffer;\n      if (property === '_b') return _b;\n      if (property === '_m') return _m;\n      if (property === '_r') return _r;\n      if (has(storeTraps, property)) {\n        return storeTraps[property].bind(null, messages, store, node);\n      }\n      return Reflect.get(...args);\n    },\n    set(_t, prop, value) {\n      if (prop === '_n') {\n        node = value;\n        if (_r === '__n') releaseMissed(node, store);\n        return true;\n      } else if (prop === '_b') {\n        _b = value;\n        return true;\n      } else if (prop === 'buffer') {\n        buffer = value;\n        return true;\n      } else if (prop === '_r') {\n        _r = value;\n        return true;\n      }\n      error(101, node);\n      return false;\n    }\n  });\n  return store;\n}\n/**\n * Adds a new value to a FormKit message bag.\n *\n * @param messageStore - The message store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param message - The message object\n *\n * @internal\n */\nfunction setMessage(messageStore, store, node, message) {\n  if (store.buffer) {\n    store._b.push([[message]]);\n    return store;\n  }\n  if (messageStore[message.key] !== message) {\n    if (typeof message.value === 'string' && message.meta.localize !== false) {\n      // Expose the value to translation\n      const previous = message.value;\n      message.value = node.t(message);\n      if (message.value !== previous) {\n        message.meta.locale = node.props.locale;\n      }\n    }\n    const e = `message-${has(messageStore, message.key) ? 'updated' : 'added'}`;\n    messageStore[message.key] = Object.freeze(node.hook.message.dispatch(message));\n    node.emit(e, message);\n  }\n  return store;\n}\n/**\n * Run through each message in the store, and ensure it has been translated\n * to the proper language. This most frequently happens after a locale change.\n *\n * @internal\n */\nfunction touchMessages(messageStore, store) {\n  for (const key in messageStore) {\n    const message = {\n      ...messageStore[key]\n    };\n    store.set(message);\n  }\n}\n/**\n * Remove a message from the store.\n *\n * @param messageStore - The message store\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param key - The message key\n *\n * @returns FormKitStore\n *\n * @internal\n */\nfunction removeMessage(messageStore, store, node, key) {\n  if (has(messageStore, key)) {\n    const message = messageStore[key];\n    delete messageStore[key];\n    node.emit('message-removed', message);\n  }\n  if (store.buffer === true) {\n    store._b = store._b.filter(buffered => {\n      buffered[0] = buffered[0].filter(m => m.key !== key);\n      return buffered[1] || buffered[0].length;\n    });\n  }\n  return store;\n}\n/**\n * Iterates over all messages removing those that are no longer wanted.\n *\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n * @param callback - A callback accepting a message and returning a boolean\n * @param type - Pre filtered by a given message type\n *\n * @internal\n */\nfunction filterMessages(messageStore, store, node, callback, type) {\n  for (const key in messageStore) {\n    const message = messageStore[key];\n    if ((!type || message.type === type) && !callback(message)) {\n      removeMessage(messageStore, store, node, key);\n    }\n  }\n}\n/**\n * Reduce the message store to some other generic value.\n *\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param _node - The node owner of this store\n * @param reducer - The callback that performs the reduction\n * @param accumulator - The initial value\n *\n * @returns\n *\n * @internal\n */\nfunction reduceMessages(messageStore, _store, _node, reducer, accumulator) {\n  for (const key in messageStore) {\n    const message = messageStore[key];\n    accumulator = reducer(accumulator, message);\n  }\n  return accumulator;\n}\n/**\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param node - The node owner of this store\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\n *\n * @internal\n */\nfunction applyMessages(_messageStore, store, node, messages, clear) {\n  if (Array.isArray(messages)) {\n    if (store.buffer) {\n      store._b.push([messages, clear]);\n      return;\n    }\n    // In this case we are applying messages to this node’s store.\n    const applied = new Set(messages.map(message => {\n      store.set(message);\n      return message.key;\n    }));\n    // Remove any messages that were not part of the initial apply:\n    if (typeof clear === 'string') {\n      store.filter(message => message.type !== clear || applied.has(message.key));\n    } else if (typeof clear === 'function') {\n      store.filter(message => !clear(message) || applied.has(message.key));\n    }\n  } else {\n    for (const address in messages) {\n      const child = node.at(address);\n      if (child) {\n        child.store.apply(messages[address], clear);\n      } else {\n        missed(node, store, address, messages[address], clear);\n      }\n    }\n  }\n}\n/**\n * Creates an array of message arrays from strings.\n *\n * @param node - FormKitNode\n * @param errors - Arrays or objects of form errors or input errors\n *\n * @internal\n */\nfunction createMessages(node, ...errors) {\n  const sourceKey = `${node.name}-set`;\n  const make = error => createMessage({\n    key: slugify(error),\n    type: 'error',\n    value: error,\n    meta: {\n      source: sourceKey,\n      autoClear: true\n    }\n  });\n  return errors.filter(m => !!m).map(errorSet => {\n    if (typeof errorSet === 'string') errorSet = [errorSet];\n    if (Array.isArray(errorSet)) {\n      return errorSet.map(error => make(error));\n    } else {\n      const errors = {};\n      for (const key in errorSet) {\n        if (Array.isArray(errorSet[key])) {\n          errors[key] = errorSet[key].map(error => make(error));\n        } else {\n          errors[key] = [make(errorSet[key])];\n        }\n      }\n      return errors;\n    }\n  });\n}\n/**\n * @param store - The store to apply this missed applications.\n * @param address - The address that was missed (a node path that didn't yet exist)\n * @param messages - The messages that should have been applied.\n * @param clear - The clearing function (if any)\n *\n * @internal\n */\nfunction missed(node, store, address, messages, clear) {\n  var _a;\n  const misses = store._m;\n  if (!misses.has(address)) misses.set(address, []);\n  // The created receipt\n  if (!store._r) store._r = releaseMissed(node, store);\n  (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages, clear]);\n}\n/**\n * Releases messages that were applied to a child via parent, but the child did\n * not exist. Once the child does exist, the created event for that child will\n * bubble to this point, and any stored applications will be applied serially.\n *\n * @param store - The store object.\n *\n * @internal\n */\nfunction releaseMissed(node, store) {\n  return node.on('child.deep', ({\n    payload: child\n  }) => {\n    store._m.forEach((misses, address) => {\n      if (node.at(address) === child) {\n        misses.forEach(([messages, clear]) => {\n          child.store.apply(messages, clear);\n        });\n        store._m.delete(address);\n      }\n    });\n    // If all the stored misses were applied, remove the listener.\n    if (store._m.size === 0 && store._r) {\n      node.off(store._r);\n      store._r = undefined;\n    }\n  });\n}\n/**\n * Iterates over all buffered messages and applies them in sequence.\n *\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n *\n * @internal\n */\nfunction releaseBuffer(_messageStore, store) {\n  store.buffer = false;\n  store._b.forEach(([messages, clear]) => store.apply(messages, clear));\n  store._b = [];\n}\n\n/**\n * Creates a new ledger for use on a single node's context.\n *\n * @internal\n */\nfunction createLedger() {\n  const ledger = {};\n  let n;\n  return {\n    count: (...args) => createCounter(n, ledger, ...args),\n    init(node) {\n      n = node;\n      node.on('message-added.deep', add(ledger, 1));\n      node.on('message-removed.deep', add(ledger, -1));\n    },\n    merge: child => merge(n, ledger, child),\n    settled(counterName) {\n      return has(ledger, counterName) ? ledger[counterName].promise : Promise.resolve();\n    },\n    unmerge: child => merge(n, ledger, child, true),\n    value(counterName) {\n      return has(ledger, counterName) ? ledger[counterName].count : 0;\n    }\n  };\n}\n/**\n * Creates a new counter object in the counting ledger.\n *\n * @param node - FormKitNode\n * @param ledger - The actual ledger storage object\n * @param counterName - The name of the counter, can be arbitrary\n * @param condition - The condition function (or string) that filters messages\n * @param increment - The increment value\n *\n * @internal\n */\nfunction createCounter(node, ledger, counterName, condition, increment = 0) {\n  condition = parseCondition(condition || counterName);\n  if (!has(ledger, counterName)) {\n    const counter = {\n      condition,\n      count: 0,\n      name: counterName,\n      node,\n      promise: Promise.resolve(),\n      resolve: () => {} // eslint-disable-line @typescript-eslint/no-empty-function\n    };\n\n    ledger[counterName] = counter;\n    increment = node.store.reduce((sum, m) => sum + counter.condition(m) * 1, increment);\n    node.each(child => {\n      child.ledger.count(counter.name, counter.condition);\n      increment += child.ledger.value(counter.name);\n    });\n  }\n  return count(ledger[counterName], increment).promise;\n}\n/**\n * We parse the condition to allow flexibility in how counters are specified.\n *\n * @param condition - The condition that, if true, allows a message to change a counter's value\n *\n * @internal\n */\nfunction parseCondition(condition) {\n  if (typeof condition === 'function') {\n    return condition;\n  }\n  return m => m.type === condition;\n}\n/**\n * Perform a counting action on the a given counter object of the ledger.\n *\n * @param counter - A counter object\n * @param increment - The amount by which we are changing the count value\n *\n * @internal\n */\nfunction count(counter, increment) {\n  const initial = counter.count;\n  const post = counter.count + increment;\n  counter.count = post;\n  if (initial === 0 && post !== 0) {\n    counter.node.emit(`unsettled:${counter.name}`, counter.count, false);\n    counter.promise = new Promise(r => counter.resolve = r);\n  } else if (initial !== 0 && post === 0) {\n    counter.node.emit(`settled:${counter.name}`, counter.count, false);\n    counter.resolve();\n  }\n  counter.node.emit(`count:${counter.name}`, counter.count, false);\n  return counter;\n}\n/**\n * Returns a function to be used as an event listener for message events.\n *\n * @param ledger - A ledger to operate on\n * @param delta - The amount to add or subtract\n *\n * @internal\n */\nfunction add(ledger, delta) {\n  return e => {\n    for (const name in ledger) {\n      const counter = ledger[name];\n      if (counter.condition(e.payload)) {\n        count(counter, delta);\n      }\n    }\n  };\n}\n/**\n * Given a child node, add the parent node's counters to the child and then\n * rectify the upstream ledger counts. Generally used when attaching a child\n * to an already counted tree.\n *\n * @param parent - The parent that is \"receiving\" the child\n * @param ledger - The ledger object\n * @param child - The child (can be a subtree) that is being attached\n * @param remove - If the merge is removing instead of adding\n *\n * @internal\n */\nfunction merge(parent, ledger, child, remove = false) {\n  for (const key in ledger) {\n    const condition = ledger[key].condition;\n    if (!remove) child.ledger.count(key, condition);\n    const increment = child.ledger.value(key) * (remove ? -1 : 1);\n    if (!parent) continue;\n    do {\n      parent.ledger.count(key, condition, increment);\n      parent = parent.parent;\n    } while (parent);\n  }\n}\n\n/**\n * A global registry of nodes by their alias or name (if root).\n */\nconst registry = new Map();\nconst reflected = new Map();\n/**\n * An event emitter for registered/set/unset nodes\n */\nconst emit = createEmitter();\n/**\n * Receipts of listeners.\n */\nconst receipts = [];\n/**\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\n * node has an explicit node.props.alias. If these two things are not true,\n * then no node is registered (idempotent).\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nfunction register(node) {\n  if (node.props.id) {\n    registry.set(node.props.id, node);\n    reflected.set(node, node.props.id);\n    emit(node, {\n      payload: node,\n      name: node.props.id,\n      bubble: false,\n      origin: node\n    });\n  }\n}\n/**\n * Deregister a node from the registry.\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nfunction deregister(node) {\n  if (reflected.has(node)) {\n    const id = reflected.get(node); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    reflected.delete(node);\n    registry.delete(id);\n    emit(node, {\n      payload: null,\n      name: id,\n      bubble: false,\n      origin: node\n    });\n  }\n}\n/**\n * Get a node by a particular id.\n *\n * @param id - Get a node by a given id.\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @public\n */\nfunction getNode$1(id) {\n  return registry.get(id);\n}\n/**\n * Resets the entire registry. Deregisters all nodes and removes all listeners.\n *\n * @public\n */\nfunction resetRegistry() {\n  registry.forEach(node => {\n    deregister(node);\n  });\n  receipts.forEach(receipt => emit.off(receipt));\n}\n/**\n * A way of watching changes in the global registry.\n *\n * @param id - A dot-syntax id where the node is located.\n * @param callback - A callback in the format of {@link FormKitEventListener | FormKitEventListener} to notify when the node is set or removed.\n *\n * @public\n */\nfunction watchRegistry(id, callback) {\n  // register a listener\n  receipts.push(emit.on(id, callback));\n}\n\n/**\n * Applies a given config change to the node.\n *\n * @param node - The node to check for config change\n * @param prop - Checks if this property exists in the local config or props\n * @param value - The value to set\n *\n * @internal\n */\nfunction configChange(node, prop, value) {\n  // When we return false, node.walk will not continue into that child.\n  let usingFallback = true;\n  !(prop in node.config._t) ? node.emit(`config:${prop}`, value, false) : usingFallback = false;\n  if (!(prop in node.props)) {\n    node.emit('prop', {\n      prop,\n      value\n    });\n    node.emit(`prop:${prop}`, value);\n  }\n  return usingFallback;\n}\n/**\n * Creates a new instance of a global configuration option. This object is\n * essentially just a FormKitOption object, but it can be used as the root for\n * FormKitConfig's proxy and retain event \"emitting\".\n *\n * @param options - An object of optional properties of {@link FormKitConfig | FormKitConfig}.\n *\n * @returns A {@link FormKitRootConfig | FormKitRootConfig}.\n *\n * @public\n */\nfunction createConfig$1(options = {}) {\n  const nodes = new Set();\n  const target = {\n    ...options,\n    ...{\n      _add: node => nodes.add(node),\n      _rm: node => nodes.delete(node)\n    }\n  };\n  const rootConfig = new Proxy(target, {\n    set(t, prop, value, r) {\n      if (typeof prop === 'string') {\n        nodes.forEach(node => configChange(node, prop, value));\n      }\n      return Reflect.set(t, prop, value, r);\n    }\n  });\n  return rootConfig;\n}\n\n/**\n * Submits a FormKit form programmatically.\n *\n * @param id - The id of the form.\n *\n * @public\n */\nfunction submitForm(id) {\n  const formElement = document.getElementById(id);\n  if (formElement instanceof HTMLFormElement) {\n    const event = new Event('submit', {\n      cancelable: true,\n      bubbles: true\n    });\n    formElement.dispatchEvent(event);\n    return;\n  }\n  warn(151, id);\n}\n\n/**\n * Clear all state and error messages.\n *\n * @internal\n */\nfunction clearState(node) {\n  const clear = n => {\n    for (const key in n.store) {\n      const message = n.store[key];\n      if (message.type === 'error' || message.type === 'ui' && key === 'incomplete') {\n        n.store.remove(key);\n      } else if (message.type === 'state') {\n        n.store.set({\n          ...message,\n          value: false\n        });\n      }\n    }\n  };\n  clear(node);\n  node.walk(clear);\n}\n/**\n * Resets an input to its \"initial\" value. If the input is a group or list it\n * resets all the children as well.\n *\n * @param id - The id of an input to reset.\n * @param resetTo - A value to reset the node to.\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @public\n */\nfunction reset(id, resetTo) {\n  const node = typeof id === 'string' ? getNode$1(id) : id;\n  if (node) {\n    const initial = n => cloneAny(n.props.initial) || (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined);\n    // pause all events in this tree.\n    node._e.pause(node);\n    // Set it back to basics\n    node.input(cloneAny(resetTo) || initial(node), false);\n    // Set children back to basics in case they were additive (had their own value for example)\n    node.walk(child => child.input(initial(child), false));\n    // Finally we need to lay any values back on top (if it is a group/list) since group values\n    // take precedence over child values.\n    const finalInit = initial(node);\n    node.input(typeof finalInit === 'object' ? cloneAny(resetTo) || init(finalInit) : finalInit, false);\n    // release the events.\n    node._e.play(node);\n    clearState(node);\n    node.emit('reset', node);\n    return node;\n  }\n  warn(152, id);\n  return;\n}\n\n/**\n * Default configuration options.\n */\nconst defaultConfig = {\n  delimiter: '.',\n  delay: 0,\n  locale: 'en',\n  rootClasses: key => ({\n    [`formkit-${kebab(key)}`]: true\n  })\n};\n/**\n * If a node’s name is set to useIndex, it replaces the node’s name with the\n * index of the node relative to its parent’s children.\n *\n * @internal\n */\nconst useIndex = Symbol('index');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * removed.\n *\n * @internal\n */\nconst valueRemoved = Symbol('removed');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * moved.\n *\n * @internal\n */\nconst valueMoved = Symbol('moved');\n/**\n * When creating a new node and having its value injected directly at a specific\n * location.\n *\n * @internal\n */\nconst valueInserted = Symbol('inserted');\n/**\n * A simple type guard to determine if the context being evaluated is a list\n * type.\n *\n * @param arg - A {@link FormKitContextShape | FormKitContextShape}.\n *\n * @returns Returns a `boolean`.\n *\n * @public\n */\nfunction isList(arg) {\n  return arg.type === 'list' && Array.isArray(arg._value);\n}\n/**\n * Determine if a given object is a node.\n *\n * @example\n *\n * ```javascript\n * import { isNode, createNode } from '@formkit/core'\n *\n * const input = createNode({\n *   type: 'input', // defaults to 'input' if not specified\n *   value: 'hello node world',\n * })\n *\n * const obj = {};\n *\n * isNode(obj)\n * // false\n *\n * isNode(input)\n * // true\n * ```\n *\n * @param node - Any value.\n *\n * @returns Returns a `boolean`.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isNode(node) {\n  return node && typeof node === 'object' && node.__FKNode__ === true;\n}\n/**\n * The setter you are trying to access is invalid.\n */\nconst invalidSetter = (node, _context, property) => {\n  error(102, [node, property]);\n};\nconst traps = {\n  _c: trap(getContext, invalidSetter, false),\n  add: trap(addChild),\n  addProps: trap(addProps),\n  address: trap(getAddress, invalidSetter, false),\n  at: trap(getNode),\n  bubble: trap(bubble),\n  clearErrors: trap(clearErrors$1),\n  calm: trap(calm),\n  config: trap(false),\n  define: trap(define),\n  disturb: trap(disturb),\n  destroy: trap(destroy),\n  hydrate: trap(hydrate),\n  index: trap(getIndex, setIndex, false),\n  input: trap(input),\n  each: trap(eachChild),\n  emit: trap(emit$1),\n  find: trap(find),\n  on: trap(on),\n  off: trap(off),\n  parent: trap(false, setParent),\n  plugins: trap(false),\n  remove: trap(removeChild),\n  root: trap(getRoot, invalidSetter, false),\n  reset: trap(resetValue),\n  resetConfig: trap(resetConfig),\n  setErrors: trap(setErrors$1),\n  submit: trap(submit),\n  t: trap(text),\n  use: trap(use),\n  name: trap(getName, false, false),\n  walk: trap(walkTree)\n};\n/**\n * These are all the available \"traps\" for a given node. You can think of these\n * a little bit like methods, but they are really Proxy interceptors.\n */\nfunction createTraps() {\n  return new Map(Object.entries(traps));\n}\n/**\n * Creates a getter/setter trap and curries the context/node pair\n *\n * @param getter - The getter function\n * @param setter - The setter function\n * @param curryGetter - Indicates if the getter should be curried or not\n *\n * @returns A {@link FormKitTrap | FormKitTrap}\n */\nfunction trap(getter, setter, curryGetter = true) {\n  return {\n    get: getter ? (node, context) => curryGetter ? (...args) => getter(node, context, ...args) : getter(node, context) : false,\n    set: setter !== undefined ? setter : invalidSetter.bind(null)\n  };\n}\n/**\n * Create all of the node's hook dispatchers.\n */\nfunction createHooks() {\n  const hooks = new Map();\n  return new Proxy(hooks, {\n    get(_, property) {\n      if (!hooks.has(property)) {\n        hooks.set(property, createDispatcher());\n      }\n      return hooks.get(property);\n    }\n  });\n}\n/**\n * This is a simple integer counter of every createName() where the name needs\n * to be generated.\n */\nlet nameCount = 0;\n/**\n * This is a simple integer counter of every default id created.\n */\nlet idCount = 0;\n/**\n * Resets the global number of node registrations, useful for deterministic\n * node naming.\n *\n * @public\n */\nfunction resetCount() {\n  nameCount = 0;\n  idCount = 0;\n}\n/**\n * Create a name-based dictionary of all children in an array.\n *\n * @param children - An array of {@link FormKitNode | FormKitNode}.\n *\n * @returns A dictionary of named {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nfunction names(children) {\n  return children.reduce((named, child) => Object.assign(named, {\n    [child.name]: child\n  }), {});\n}\n/**\n * This node is responsible for deterministically generating an id for this\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\n * re-hydration of the form (like post-SSR) produces the same names/ids.\n *\n * @param options - A {@link FormKitOptions | FormKitOptions}\n *\n * @returns `string | symbol`\n *\n * @internal\n */\nfunction createName(options) {\n  var _a, _b;\n  if (((_a = options.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list') return useIndex;\n  return options.name || `${((_b = options.props) === null || _b === void 0 ? void 0 : _b.type) || 'input'}_${++nameCount}`;\n}\n/**\n * Creates the initial value for a node based on the options passed in and the\n * type of the input.\n *\n * @param options - A {@link FormKitOptions | FormKitOptions}.\n *\n * @returns `unknown`\n *\n * @public\n */\nfunction createValue(options) {\n  if (options.type === 'group') {\n    return init(options.value && typeof options.value === 'object' && !Array.isArray(options.value) ? options.value : {});\n  } else if (options.type === 'list') {\n    return init(Array.isArray(options.value) ? options.value : []);\n  }\n  return options.value;\n}\n/**\n * Sets the internal value of the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param value - A input value to the node\n * @param async - If its an async call\n *\n * @returns `Promise<unknown>`\n *\n * @internal\n */\nfunction input(node, context, value, async = true) {\n  context._value = validateInput(node, node.hook.input.dispatch(value));\n  node.emit('input', context._value);\n  if (context.isSettled) node.disturb();\n  if (async) {\n    if (context._tmo) clearTimeout(context._tmo);\n    context._tmo = setTimeout(commit, node.props.delay, node, context);\n  } else {\n    commit(node, context);\n  }\n  return context.settled;\n}\n/**\n * Validate that the current input is allowed.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param value - The value that is being validated\n *\n * @returns `T`\n *\n * @internal\n */\nfunction validateInput(node, value) {\n  switch (node.type) {\n    // Inputs are allowed to have any type\n    case 'input':\n      break;\n    case 'group':\n      if (!value || typeof value !== 'object') error(107, [node, value]);\n      break;\n    case 'list':\n      if (!Array.isArray(value)) error(108, [node, value]);\n      break;\n  }\n  return value;\n}\n/**\n * Commits the working value to the node graph as the value of this node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param calm - If it calms the node\n * @param hydrate - If it hydrates the node\n *\n * @internal\n */\nfunction commit(node, context, calm = true, hydrate = true) {\n  context._value = context.value = node.hook.commit.dispatch(context._value);\n  if (node.type !== 'input' && hydrate) node.hydrate();\n  node.emit('commit', context.value);\n  if (calm) node.calm();\n}\n/**\n * Perform a modification to a single element of a parent aggregate value. This\n * is only performed on the pre-committed value (_value), although typically\n * the value and _value are both linked in memory.\n *\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction partial(context, {\n  name,\n  value,\n  from\n}) {\n  if (Object.isFrozen(context._value)) return;\n  if (isList(context)) {\n    const insert = value === valueRemoved ? [] : value === valueMoved && typeof from === 'number' ? context._value.splice(from, 1) : [value];\n    context._value.splice(name, value === valueMoved || from === valueInserted ? 0 : 1, ...insert);\n    return;\n  }\n  // In this case we know for sure we're dealing with a group, TS doesn't\n  // know that however, so we use some unpleasant casting here\n  if (value !== valueRemoved) {\n    context._value[name] = value;\n  } else {\n    delete context._value[name];\n  }\n}\n/**\n * Hydrate node and its children\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction hydrate(node, context) {\n  const _value = context._value;\n  context.children.forEach(child => {\n    if (typeof _value !== 'object') return;\n    // if (has(context._value as FormKitGroupValue, child.name)) {\n    if (child.name in _value) {\n      // In this case, the parent has a value to give to the child, so we\n      // perform a down-tree synchronous input which will cascade values down\n      // and then ultimately back up.\n      const childValue = child.type !== 'input' || _value[child.name] && typeof _value[child.name] === 'object' ? init(_value[child.name]) : _value[child.name];\n      child.input(childValue, false);\n    } else {\n      if (node.type !== 'list' || typeof child.name === 'number') {\n        // In this case, the parent’s values have no knowledge of the child\n        // value — this typically occurs on the commit at the end of addChild()\n        // we need to create a value reservation for this node’s name. This is\n        // especially important when dealing with lists where index matters.\n        partial(context, {\n          name: child.name,\n          value: child.value\n        });\n      }\n      if (!_value.__init) {\n        // In this case, someone has explicitly set the value to an empty object\n        // with node.input({}) so we do not define the __init property:\n        if (child.type === 'group') child.input({}, false);else if (child.type === 'list') child.input([], false);else child.input(undefined, false);\n      }\n    }\n  });\n  return node;\n}\n/**\n * Disturbs the state of a node from settled to unsettled — creating appropriate\n * promises and resolutions.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction disturb(node, context) {\n  var _a;\n  if (context._d <= 0) {\n    context.isSettled = false;\n    node.emit('settled', false, false);\n    context.settled = new Promise(resolve => {\n      context._resolve = resolve;\n    });\n    if (node.parent) (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();\n  }\n  context._d++;\n  return node;\n}\n/**\n * Calms the given node's disturbed state by one.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param value - A {@link FormKitChildValue | FormKitChildValue}\n *\n * @internal\n */\nfunction calm(node, context, value) {\n  var _a;\n  if (value !== undefined && node.type !== 'input') {\n    partial(context, value);\n    // Commit the value up, but do not hydrate back down\n    return commit(node, context, true, false);\n  }\n  if (context._d > 0) context._d--;\n  if (context._d === 0) {\n    context.isSettled = true;\n    node.emit('settled', true, false);\n    if (node.parent) (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({\n      name: node.name,\n      value: context.value\n    });\n    if (context._resolve) context._resolve(context.value);\n  }\n}\n/**\n * This node is being removed and needs to be cleaned up.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction destroy(node, context) {\n  node.emit('destroying', node);\n  // flush all messages out\n  node.store.filter(() => false);\n  if (node.parent) {\n    node.parent.emit('childRemoved', node);\n    node.parent.remove(node);\n  }\n  deregister(node);\n  context._value = context.value = undefined;\n  node.emit('destroyed', node);\n}\n/**\n * Defines the current input type concretely.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param definition - A {@link FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @internal\n */\nfunction define(node, context, definition) {\n  // Assign the type\n  context.type = definition.type;\n  // Assign the definition\n  context.props.definition = clone(definition);\n  // Ensure the type is seeded with the `__init` value.\n  context.value = context._value = createValue({\n    type: node.type,\n    value: context.value\n  });\n  /**\n   * If the user has a typename defined, use it here.\n   */\n  if (definition.forceTypeProp) {\n    if (node.props.type) node.props.originalType = node.props.type;\n    context.props.type = definition.forceTypeProp;\n  }\n  /**\n   * If the input is part of a family of inputs, add that prop.\n   */\n  if (definition.family) {\n    context.props.family = definition.family;\n  }\n  // Apply any input features before resetting the props.\n  if (definition.features) {\n    definition.features.forEach(feature => feature(node));\n  }\n  // Its possible that input-defined \"props\" have ended up in the context attrs\n  // these should be moved back out of the attrs object.\n  if (definition.props) {\n    node.addProps(definition.props);\n  }\n  node.emit('defined', definition);\n}\n/**\n * Adds props to a given node by stripping them out of the node.props.attrs and\n * then adding them to the nodes.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param props - An array of prop strings (in camelCase!)\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction addProps(node, context, props) {\n  var _a;\n  if (node.props.attrs) {\n    const attrs = {\n      ...node.props.attrs\n    };\n    // Temporarily disable prop emits\n    node.props._emit = false;\n    for (const attr in attrs) {\n      const camelName = camel(attr);\n      if (props.includes(camelName)) {\n        node.props[camelName] = attrs[attr];\n        delete attrs[attr];\n      }\n    }\n    const initial = cloneAny(context._value);\n    node.props.initial = node.type !== 'input' ? init(initial) : initial;\n    // Re-enable prop emits\n    node.props._emit = true;\n    node.props.attrs = attrs;\n    if (node.props.definition) {\n      node.props.definition.props = [...(((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.props) || []), ...props];\n    }\n  }\n  node.emit('added-props', props);\n  return node;\n}\n/**\n * Adds a child to the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A parent {@link FormKitContext | FormKitContext}\n * @param child - A {@link FormKitNode | FormKitNode}\n * @param listIndex - A index number to be added at\n *\n * @internal\n */\nfunction addChild(parent, parentContext, child, listIndex) {\n  if (parent.type === 'input') error(100, parent);\n  if (child.parent && child.parent !== parent) {\n    child.parent.remove(child);\n  }\n  // Synchronously set the initial value on the parent\n  if (!parentContext.children.includes(child)) {\n    if (listIndex !== undefined && parent.type === 'list') {\n      // Inject the child:\n      parentContext.children.splice(listIndex, 0, child);\n      if (Array.isArray(parent.value) && parent.value.length < parentContext.children.length) {\n        // When adding an node or value to a list it is absolutely critical to\n        // know if, at the moment of injection, the parent’s value or the node\n        // children are the source of truth. For example, if a user pushes or\n        // splices a new value onto the lists’s array then we want to use that\n        // value as the value of the new node, but if a user adds a node to the\n        // list then we want the node’s value. In this specific case, we\n        // assume (due to length) that a new node was injected into the list, so\n        // we want that new node’s value injected into the parent list value.\n        parent.disturb().calm({\n          name: listIndex,\n          value: child.value,\n          from: valueInserted\n        });\n      }\n    } else {\n      parentContext.children.push(child);\n    }\n    if (!child.isSettled) parent.disturb();\n  }\n  if (child.parent !== parent) {\n    child.parent = parent;\n    // In this edge case middleware changed the parent assignment so we need to\n    // re-add the child\n    if (child.parent !== parent) {\n      parent.remove(child);\n      child.parent.add(child);\n      return parent;\n    }\n  } else {\n    // When a parent is properly assigned, we inject the parent's plugins on the\n    // child.\n    child.use(parent.plugins);\n  }\n  // Finally we call commit here, which sub-calls hydrate(), hydrate() will\n  // resolve any conflict between the parent and child values, and also ensure\n  // proper \"placeholders\" are made on the parent.\n  commit(parent, parentContext, false);\n  parent.ledger.merge(child);\n  parent.emit('child', child);\n  return parent;\n}\n/**\n * The setter for node.parent = FormKitNode\n * @param child - A child {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param _property - A property to be setted\n * @param parent - A parent {@link FormKitNode | FormKitNode}\n *\n * @returns `boolean`\n *\n * @internal\n */\nfunction setParent(child, context, _property, parent) {\n  if (isNode(parent)) {\n    if (child.parent && child.parent !== parent) {\n      child.parent.remove(child);\n    }\n    context.parent = parent;\n    child.resetConfig();\n    !parent.children.includes(child) ? parent.add(child) : child.use(parent.plugins);\n    return true;\n  }\n  if (parent === null) {\n    context.parent = null;\n    return true;\n  }\n  return false;\n}\n/**\n * Removes a child from the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param child - A child {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction removeChild(node, context, child) {\n  const childIndex = context.children.indexOf(child);\n  if (childIndex !== -1) {\n    if (child.isSettled) node.disturb();\n    context.children.splice(childIndex, 1);\n    // If an ancestor uses the preserve prop, then we are expected to not remove\n    // our values on this node either, see #53\n    let preserve = undefine(child.props.preserve);\n    let parent = child.parent;\n    while (preserve === undefined && parent) {\n      preserve = undefine(parent.props.preserve);\n      parent = parent.parent;\n    }\n    if (!preserve) {\n      node.calm({\n        name: node.type === 'list' ? childIndex : child.name,\n        value: valueRemoved\n      });\n    } else {\n      node.calm();\n    }\n    child.parent = null;\n    // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\n    child.config._rmn = child;\n  }\n  node.ledger.unmerge(child);\n  return node;\n}\n/**\n * Iterate over each immediate child and perform a callback.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\n *\n * @internal\n */\nfunction eachChild(_node, context, callback) {\n  context.children.forEach(child => callback(child));\n}\n/**\n * Walk all nodes below this one and execute a callback.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\n * @param stopIfFalse - Boolean to stop running on children\n *\n * @internal\n */\nfunction walkTree(_node, context, callback, stopIfFalse = false) {\n  context.children.forEach(child => {\n    if (callback(child) !== false || !stopIfFalse) {\n      child.walk(callback, stopIfFalse);\n    }\n  });\n}\n/**\n * Set the configuration options of the node and it's subtree.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction resetConfig(node, context) {\n  const parent = node.parent || undefined;\n  context.config = createConfig(node.config._t, parent);\n  node.walk(n => n.resetConfig());\n}\n/**\n * Adds a plugin to the node, its children, and executes it.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param plugin -\n * {@link FormKitPlugin | FormKitPlugin}\n * {@link FormKitPlugin | FormKitPlugin[]}\n * {@link FormKitPlugin | Set<FormKitPlugin>}\n * @param run - If it will run on creation\n * @param library - If it will run on library creation\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction use(node, context, plugin, run = true, library = true) {\n  if (Array.isArray(plugin) || plugin instanceof Set) {\n    plugin.forEach(p => use(node, context, p));\n    return node;\n  }\n  if (!context.plugins.has(plugin)) {\n    if (library && typeof plugin.library === 'function') plugin.library(node);\n    // When plugins return false, they are never added as to the plugins Set\n    // meaning they only ever have access to the single node they were added on.\n    if (run && plugin(node) !== false) {\n      context.plugins.add(plugin);\n      node.children.forEach(child => child.use(plugin));\n    }\n  }\n  return node;\n}\n/**\n * Moves a node in the parent’s children to the given index.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param _property - A property to add\n * @param setIndex - The index to move the node\n *\n * @internal\n */\nfunction setIndex(node, _context, _property, setIndex) {\n  if (isNode(node.parent)) {\n    const children = node.parent.children;\n    const index = setIndex >= children.length ? children.length - 1 : setIndex < 0 ? 0 : setIndex;\n    const oldIndex = children.indexOf(node);\n    if (oldIndex === -1) return false;\n    children.splice(oldIndex, 1);\n    children.splice(index, 0, node);\n    node.parent.children = children;\n    if (node.parent.type === 'list') node.parent.disturb().calm({\n      name: index,\n      value: valueMoved,\n      from: oldIndex\n    });\n    return true;\n  }\n  return false;\n}\n/**\n * Retrieves the index of a node from the parent’s children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getIndex(node) {\n  if (node.parent) {\n    const index = [...node.parent.children].indexOf(node);\n    // If the index is currently -1 then the node isnt finished booting, so it\n    // must be the next node.\n    return index === -1 ? node.parent.children.length : index;\n  }\n  return -1;\n}\n/**\n * Retrieves the context object of a given node. This is intended to be a\n * private trap and should absolutely not be used in plugins or user-land code.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getContext(_node, context) {\n  return context;\n}\n/**\n * Get the name of the current node, allowing for slight mutations.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getName(node, context) {\n  var _a;\n  if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list') return node.index;\n  return context.name !== useIndex ? context.name : node.index;\n}\n/**\n * Returns the address of the current node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getAddress(node, context) {\n  return context.parent ? context.parent.address.concat([node.name]) : [node.name];\n}\n/**\n * Fetches a node from the tree by its address.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param locator - A string or {@link FormKitAddress | FormKitAddress} to find in the tree.\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getNode(node, _context, locator) {\n  const address = typeof locator === 'string' ? locator.split(node.config.delimiter) : locator;\n  if (!address.length) return undefined;\n  const first = address[0];\n  let pointer = node.parent;\n  if (!pointer) {\n    // This address names the root node, remove it to get child name:\n    if (String(address[0]) === String(node.name)) address.shift();\n    // All root nodes start at themselves ultimately:\n    pointer = node;\n  }\n  // Any addresses starting with $parent should discard it\n  if (first === '$parent') address.shift();\n  while (pointer && address.length) {\n    const name = address.shift();\n    switch (name) {\n      case '$root':\n        pointer = node.root;\n        break;\n      case '$parent':\n        pointer = pointer.parent;\n        break;\n      case '$self':\n        pointer = node;\n        break;\n      default:\n        pointer = pointer.children.find(c => String(c.name) === String(name)) || select(pointer, name);\n    }\n  }\n  return pointer || undefined;\n}\n/**\n * Perform selections on a subtree using the address \"selector\" methods.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param selector - A `string | number` to find in the node\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\n *\n * @internal\n */\nfunction select(node, selector) {\n  const matches = String(selector).match(/^(find)\\((.*)\\)$/);\n  if (matches) {\n    const [, action, argStr] = matches;\n    const args = argStr.split(',').map(arg => arg.trim());\n    switch (action) {\n      case 'find':\n        return node.find(args[0], args[1]);\n      default:\n        return undefined;\n    }\n  }\n  return undefined;\n}\n/**\n * Perform a breadth first search and return the first instance of a node that\n * is found in the subtree or undefined.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param searchTerm - The term we are searching for\n * @param searcher - Either a key of {@link FormKitNode | FormKitNode}, or a {@link FormKitSearchFunction | FormKitSearchFunction}\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\n *\n * @internal\n */\nfunction find(node, _context, searchTerm, searcher) {\n  return bfs(node, searchTerm, searcher);\n}\n/**\n * Perform a breadth-first search on a node subtree and locate the first\n * instance of a match.\n *\n * @param tree - A {@link FormKitNode | FormKitNode} to start from.\n * @param searchValue - A value to be searched.\n * @param searchGoal - A goal value.\n *\n * @returns A {@link FormKitNode | FormKitNode } or `undefined`.\n *\n * @public\n */\nfunction bfs(tree, searchValue, searchGoal = 'name') {\n  const search = typeof searchGoal === 'string' ? n => n[searchGoal] == searchValue // non-strict comparison is intentional\n  : searchGoal;\n  const stack = [tree];\n  while (stack.length) {\n    const node = stack.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n    if (search(node, searchValue)) return node;\n    stack.push(...node.children);\n  }\n  return undefined;\n}\n/**\n * Get the root node of the tree.\n *\n * @param n - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getRoot(n) {\n  let node = n;\n  while (node.parent) {\n    node = node.parent;\n  }\n  return node;\n}\n/**\n * Creates a new configuration option.\n *\n * @param target - An object of optional properties of {@link FormKitConfig | FormKitConfig}\n * @param parent - A parent {@link FormKitNode | FormKitNode}\n *\n * @returns {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction createConfig(target = {}, parent) {\n  let node = undefined;\n  return new Proxy(target, {\n    get(...args) {\n      const prop = args[1];\n      if (prop === '_t') return target;\n      const localValue = Reflect.get(...args);\n      // Check our local values first\n      if (localValue !== undefined) return localValue;\n      // Then check our parent values next\n      if (parent) {\n        const parentVal = parent.config[prop];\n        if (parentVal !== undefined) return parentVal;\n      }\n      if (target.rootConfig && typeof prop === 'string') {\n        const rootValue = target.rootConfig[prop];\n        if (rootValue !== undefined) return rootValue;\n      }\n      // The default delay value should be 20\n      if (prop === 'delay' && (node === null || node === void 0 ? void 0 : node.type) === 'input') return 20;\n      // Finally check the default values\n      return defaultConfig[prop];\n    },\n    set(...args) {\n      const prop = args[1];\n      const value = args[2];\n      if (prop === '_n') {\n        node = value;\n        if (target.rootConfig) target.rootConfig._add(node);\n        return true;\n      }\n      if (prop === '_rmn') {\n        if (target.rootConfig) target.rootConfig._rm(node);\n        node = undefined;\n        return true;\n      }\n      if (!eq(target[prop], value, false)) {\n        const didSet = Reflect.set(...args);\n        if (node) {\n          node.emit(`config:${prop}`, value, false);\n          configChange(node, prop, value);\n          // Walk the node tree and notify of config/prop changes where relevant\n          node.walk(n => configChange(n, prop, value), true);\n        }\n        return didSet;\n      }\n      return true;\n    }\n  });\n}\n/**\n * Given a string of text, expose it for modification, translation, or full\n * replacement.\n\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param key - A {@link FormKitTextFragment | FormKitTextFragment}, or generic string of text\n * @param type - A string to represent the text type\n *\n * @returns `string`\n *\n * @internal\n */\nfunction text(node, _context, key, type = 'ui') {\n  const fragment = typeof key === 'string' ? {\n    key,\n    value: key,\n    type\n  } : key;\n  const value = node.hook.text.dispatch(fragment);\n  node.emit('text', value, false);\n  return value.value;\n}\n/**\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\n * node is a form by locating an ancestor where node.props.isForm = true.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction submit(node) {\n  const name = node.name;\n  do {\n    if (node.props.isForm === true) break;\n    if (!node.parent) error(106, name);\n    node = node.parent;\n  } while (node);\n  if (node.props.id) {\n    submitForm(node.props.id);\n  }\n}\n/**\n * Reset to the original value.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param value - The value to reset to\n *\n * @internal\n */\nfunction resetValue(node, _context, value) {\n  return reset(node, value);\n}\n/**\n * Sets errors on the node and optionally its children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param localErrors - An array of {@link ErrorMessages | ErrorMessages} to set on this node\n * @param childErrors - An object of name of {@link ErrorMessages | ErrorMessages} to set on children.\n *\n * @internal\n */\nfunction setErrors$1(node, _context, localErrors, childErrors) {\n  const sourceKey = `${node.name}-set`;\n  const errors = node.hook.setErrors.dispatch({\n    localErrors,\n    childErrors\n  });\n  createMessages(node, errors.localErrors, errors.childErrors).forEach(errors => {\n    node.store.apply(errors, message => message.meta.source === sourceKey);\n  });\n  return node;\n}\n/**\n * Clears errors on the node and optionally its children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param clearChildErrors - A boolean to clear children error or not.\n * @param sourceKey - The source key string to reset.\n *\n * @internal\n */\nfunction clearErrors$1(node, context, clearChildErrors = true, sourceKey) {\n  setErrors$1(node, context, []);\n  if (clearChildErrors) {\n    sourceKey = sourceKey || `${node.name}-set`;\n    node.walk(child => {\n      child.store.filter(message => {\n        return !(message.type === 'error' && message.meta && message.meta.source === sourceKey);\n      });\n    });\n  }\n  return node;\n}\n/**\n * Middleware to assign default prop values as issued by core.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction defaultProps(node) {\n  if (!has(node.props, 'id')) node.props.id = `input_${idCount++}`;\n  return node;\n}\n/**\n * Create props based on initial values\n *\n * @param initial - An initial value to be transformed\n *\n * @internal\n */\nfunction createProps(initial) {\n  const props = {\n    initial: typeof initial === 'object' ? cloneAny(initial) : initial\n  };\n  let node;\n  let isEmitting = true;\n  return new Proxy(props, {\n    get(...args) {\n      const [_t, prop] = args;\n      if (has(props, prop)) return Reflect.get(...args);\n      if (node && typeof prop === 'string' && node.config[prop] !== undefined) return node.config[prop];\n      return undefined;\n    },\n    set(target, property, originalValue, receiver) {\n      if (property === '_n') {\n        node = originalValue;\n        return true;\n      }\n      if (property === '_emit') {\n        isEmitting = originalValue;\n        return true;\n      }\n      const {\n        prop,\n        value\n      } = node.hook.prop.dispatch({\n        prop: property,\n        value: originalValue\n      });\n      // Typescript compiler cannot handle a symbol index, even though js can:\n      if (!eq(props[prop], value, false) || typeof value === 'object') {\n        const didSet = Reflect.set(target, prop, value, receiver);\n        if (isEmitting) {\n          node.emit('prop', {\n            prop,\n            value\n          });\n          if (typeof prop === 'string') node.emit(`prop:${prop}`, value);\n        }\n        return didSet;\n      }\n      return true;\n    }\n  });\n}\n/**\n * A cheap function that iterates over all plugins and stops once node.define\n * is called.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param plugins - An array of {@link FormKitPlugin | FormKitPlugin}\n *\n * @internal\n */\nfunction findDefinition(node, plugins) {\n  // If the definition is already there, force call to define.\n  if (node.props.definition) return node.define(node.props.definition);\n  for (const plugin of plugins) {\n    if (node.props.definition) return;\n    if (typeof plugin.library === 'function') {\n      plugin.library(node);\n    }\n  }\n}\n/**\n * Create a new context object for our a FormKit node, given default information\n *\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction createContext(options) {\n  const value = createValue(options);\n  const config = createConfig(options.config || {}, options.parent);\n  return {\n    _d: 0,\n    _e: createEmitter(),\n    _resolve: false,\n    _tmo: false,\n    _value: value,\n    children: dedupe(options.children || []),\n    config,\n    hook: createHooks(),\n    isCreated: false,\n    isSettled: true,\n    ledger: createLedger(),\n    name: createName(options),\n    parent: options.parent || null,\n    plugins: new Set(),\n    props: createProps(value),\n    settled: Promise.resolve(value),\n    store: createStore(true),\n    traps: createTraps(),\n    type: options.type || 'input',\n    value\n  };\n}\n/**\n * Initialize a node object's internal properties.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction nodeInit(node, options) {\n  var _a;\n  // Set the internal node on the props, config, ledger and store\n  node.ledger.init(node.store._n = node.props._n = node.config._n = node);\n  // Apply given in options to the node.\n  node.props._emit = false;\n  if (options.props) Object.assign(node.props, options.props);\n  node.props._emit = true;\n  // Attempt to find a definition from the pre-existing plugins.\n  findDefinition(node, new Set([...(options.plugins || []), ...(node.parent ? node.parent.plugins : [])]));\n  // Then we apply each plugin's root code, we do this with an explicit loop\n  // for that ity-bitty performance bump.\n  if (options.plugins) {\n    for (const plugin of options.plugins) {\n      use(node, node._c, plugin, true, false);\n    }\n  }\n  // Initialize the default props\n  defaultProps(node);\n  // Apply the parent to each child.\n  node.each(child => node.add(child));\n  // If the node has a parent, ensure it's properly nested bi-directionally.\n  if (node.parent) node.parent.add(node, options.index);\n  // Inputs are leafs, and cannot have children\n  if (node.type === 'input' && node.children.length) error(100, node);\n  // Apply the input hook to the initial value.\n  input(node, node._c, node._value, false);\n  // Release the store buffer\n  node.store.release();\n  // Register the node globally if someone explicitly gave it an id\n  if ((_a = options.props) === null || _a === void 0 ? void 0 : _a.id) register(node);\n  // Our node is finally ready, emit it to the world\n  node.emit('created', node);\n  node.isCreated = true;\n  return node;\n}\n/**\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of a FormKit graph.\n *\n * @example\n *\n * ```javascript\n * import { createNode } from '@formkit/core'\n *\n * const input = createNode({\n *   type: 'input', // defaults to 'input' if not specified\n *   value: 'hello node world',\n * })\n *\n * console.log(input.value)\n * // 'hello node world'\n * ```\n *\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nfunction createNode(options) {\n  const ops = options || {};\n  const context = createContext(ops);\n  // Note: The typing for the proxy object cannot be fully modeled, thus we are\n  // force-typing to a FormKitNode. See:\n  // https://github.com/microsoft/TypeScript/issues/28067\n  const node = new Proxy(context, {\n    get(...args) {\n      const [, property] = args;\n      if (property === '__FKNode__') return true;\n      const trap = context.traps.get(property);\n      if (trap && trap.get) return trap.get(node, context);\n      return Reflect.get(...args);\n    },\n    set(...args) {\n      const [, property, value] = args;\n      const trap = context.traps.get(property);\n      if (trap && trap.set) return trap.set(node, context, property, value);\n      return Reflect.set(...args);\n    }\n  });\n  return nodeInit(node, ops);\n}\n\n/**\n * Type narrow that a node is a DOM node.\n *\n * @param node - A schema node to check\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isDOM(node) {\n  return typeof node !== 'string' && has(node, '$el');\n}\n/**\n * Type narrow that a node is a DOM node.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isComponent(node) {\n  return typeof node !== 'string' && has(node, '$cmp');\n}\n/**\n * Root declaration.\n *\n * @param node - An object to check.\n */\nfunction isConditional(node) {\n  if (!node || typeof node === 'string') return false;\n  return has(node, 'if') && has(node, 'then');\n}\n/**\n * Determines if the node is syntactic sugar or not.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isSugar(node) {\n  return typeof node !== 'string' && '$formkit' in node;\n}\n/**\n * Converts syntactic sugar nodes to standard nodes.\n *\n * @param node - A node to covert.\n *\n * @returns A {@link FormKitSchemaNode | FormKitSchemaNode} without the properties of {@link FormKitSchemaFormKit | FormKitSchemaFormKit}.\n *\n * @public\n */\nfunction sugar(node) {\n  if (typeof node === 'string') {\n    return {\n      $el: 'text',\n      children: node\n    };\n  }\n  if (isSugar(node)) {\n    const {\n      $formkit: type,\n      for: iterator,\n      if: condition,\n      children,\n      bind,\n      ...props\n    } = node;\n    return Object.assign({\n      $cmp: 'FormKit',\n      props: {\n        ...props,\n        type\n      }\n    }, condition ? {\n      if: condition\n    } : {}, iterator ? {\n      for: iterator\n    } : {}, children ? {\n      children\n    } : {}, bind ? {\n      bind\n    } : {});\n  }\n  return node;\n}\n\n/**\n * Compiles a logical string like `\"a != z || b == c\"` into a single function.\n * The return value is an object with a \"provide\" method that iterates over all\n * requirement tokens to use as replacements.\n *\n * @example\n *\n * ```typescript\n * let name = {\n *   value: 'jon'\n * }\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\n *  return () => name.value // must return a function!\n * })\n *\n * condition() // false\n * ```\n *\n * @param expr - A string to compile.\n *\n * @returns A {@link FormKitCompilerOutput | FormKitCompilerOutput}.\n *\n * @public\n */\nfunction compile(expr) {\n  /**\n   * These tokens are replacements used in evaluating a given condition.\n   */\n  // const tokens: FormKitTokens = {}\n  /**\n   * The value of the provide() callback. Used for late binding.\n   */\n  let provideTokens;\n  /**\n   * These are token requirements like \"$name.value\" that are need to fulfill\n   * a given condition call.\n   */\n  const requirements = new Set();\n  /**\n   * Expands the current value if it is a function.\n   * @param operand - A left or right hand operand\n   * @returns\n   */\n  const x = function expand(operand, tokens) {\n    return typeof operand === 'function' ? operand(tokens) : operand;\n  };\n  /**\n   * Comprehensive list of operators. This list MUST be\n   * ordered by the length of the operator characters in descending order.\n   */\n  const operatorRegistry = [{\n    '&&': (l, r, t) => x(l, t) && x(r, t),\n    '||': (l, r, t) => x(l, t) || x(r, t)\n  }, {\n    '===': (l, r, t) => !!(x(l, t) === x(r, t)),\n    '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\n    '==': (l, r, t) => !!(x(l, t) == x(r, t)),\n    '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\n    '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\n    '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\n    '>': (l, r, t) => !!(x(l, t) > x(r, t)),\n    '<': (l, r, t) => !!(x(l, t) < x(r, t))\n  }, {\n    '+': (l, r, t) => x(l, t) + x(r, t),\n    '-': (l, r, t) => x(l, t) - x(r, t)\n  }, {\n    '*': (l, r, t) => x(l, t) * x(r, t),\n    '/': (l, r, t) => x(l, t) / x(r, t),\n    '%': (l, r, t) => x(l, t) % x(r, t)\n  }];\n  /**\n   * A full list of all operator symbols.\n   */\n  const operatorSymbols = operatorRegistry.reduce((s, g) => {\n    return s.concat(Object.keys(g));\n  }, []);\n  /**\n   * An array of the first character of each operator.\n   */\n  const operatorChars = new Set(operatorSymbols.map(key => key.charAt(0)));\n  /**\n   * Determines if the current character is the start of an operator symbol, if it\n   * is, it returns that symbol.\n   * @param symbols - An array of symbols that are considered operators\n   * @param char - The current character being operated on\n   * @param p - The position of the pointer\n   * @param expression - The full string expression\n   * @returns\n   */\n  function getOp(symbols, char, p, expression) {\n    const candidates = symbols.filter(s => s.startsWith(char));\n    if (!candidates.length) return false;\n    return candidates.find(symbol => {\n      if (expression.length >= p + symbol.length) {\n        const nextChars = expression.substring(p, p + symbol.length);\n        if (nextChars === symbol) return symbol;\n      }\n      return false;\n    });\n  }\n  /**\n   * Determines the step number of the right or left hand operator.\n   * @param p - The position of the pointer\n   * @param expression - The full string expression\n   * @param direction - 1 = right, 0 = left\n   */\n  function getStep(p, expression, direction = 1) {\n    let next = direction ? expression.substring(p + 1).trim() : expression.substring(0, p).trim();\n    if (!next.length) return -1;\n    if (!direction) {\n      // left hand direction could include a function name we need to remove\n      const reversed = next.split('').reverse();\n      const start = reversed.findIndex(char => operatorChars.has(char));\n      next = reversed.slice(start).join('');\n    }\n    const char = next[0];\n    return operatorRegistry.findIndex(operators => {\n      const symbols = Object.keys(operators);\n      return !!getOp(symbols, char, 0, next);\n    });\n  }\n  /**\n   * Extracts a tail call. For example:\n   * ```\n   * $foo().bar(baz) + 7\n   * ```\n   * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\n   *\n   * @param p - The position of a closing parenthetical.\n   * @param expression - The full expression being parsed.\n   */\n  function getTail(pos, expression) {\n    let tail = '';\n    const length = expression.length;\n    let depth = 0;\n    for (let p = pos; p < length; p++) {\n      const char = expression.charAt(p);\n      if (char === '(') {\n        depth++;\n      } else if (char === ')') {\n        depth--;\n      } else if (depth === 0 && char === ' ') {\n        continue;\n      }\n      if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\n        return [tail, p - 1];\n      } else {\n        tail += char;\n      }\n    }\n    return [tail, expression.length - 1];\n  }\n  /**\n   * Parse a string expression into a function that returns a boolean. This is\n   * the magic behind schema logic like $if.\n   * @param expression - A string expression to parse\n   * @returns\n   */\n  function parseLogicals(expression, step = 0) {\n    const operators = operatorRegistry[step];\n    const length = expression.length;\n    const symbols = Object.keys(operators);\n    let depth = 0;\n    let quote = false;\n    let op = null;\n    let operand = '';\n    let left = null;\n    let operation;\n    let lastChar = '';\n    let char = '';\n    let parenthetical = '';\n    let parenQuote = '';\n    let startP = 0;\n    const addTo = (depth, char) => {\n      depth ? parenthetical += char : operand += char;\n    };\n    for (let p = 0; p < length; p++) {\n      lastChar = char;\n      char = expression.charAt(p);\n      if ((char === \"'\" || char === '\"') && lastChar !== '\\\\' && (depth === 0 && !quote || depth && !parenQuote)) {\n        if (depth) {\n          parenQuote = char;\n        } else {\n          quote = char;\n        }\n        addTo(depth, char);\n        continue;\n      } else if (quote && (char !== quote || lastChar === '\\\\') || parenQuote && (char !== parenQuote || lastChar === '\\\\')) {\n        addTo(depth, char);\n        continue;\n      } else if (quote === char) {\n        quote = false;\n        addTo(depth, char);\n        continue;\n      } else if (parenQuote === char) {\n        parenQuote = false;\n        addTo(depth, char);\n        continue;\n      } else if (char === ' ') {\n        continue;\n      } else if (char === '(') {\n        if (depth === 0) {\n          startP = p;\n        } else {\n          parenthetical += char;\n        }\n        depth++;\n      } else if (char === ')') {\n        depth--;\n        if (depth === 0) {\n          // Parenthetical statements cannot be grouped up in the implicit order\n          // of left/right statements based on which step they are on because\n          // they are parsed on every step and then must be applied to the\n          // operator. Example:\n          //\n          // 5 + (3) * 2\n          //\n          // This should yield 11 not 16. This order is normally implicit in the\n          // sequence of operators being parsed, but with parenthesis the parse\n          // happens each time. Instead we need to know if the resulting value\n          // should be applied to the left or the right hand operator. The\n          // general algorithm is:\n          //\n          // 1. Does this paren have an operator on the left or right side\n          // 2. If not, it's unnecessarily wrapped (3 + 2)\n          // 3. If it does, then which order of operation is highest?\n          // 4. Wait for the highest order of operation to bind to an operator.\n          // If the parenthetical has a preceding token like $fn(1 + 2) then we\n          // need to subtract the existing operand length from the start\n          // to determine if this is a left or right operation\n          const fn = typeof operand === 'string' && operand.startsWith('$') ? operand : undefined;\n          const hasTail = fn && expression.charAt(p + 1) === '.';\n          // It's possible the function has a chained tail call:\n          let tail = '';\n          if (hasTail) {\n            [tail, p] = getTail(p + 2, expression);\n          }\n          const lStep = op ? step : getStep(startP, expression, 0);\n          const rStep = getStep(p, expression);\n          if (lStep === -1 && rStep === -1) {\n            // This parenthetical was unnecessarily wrapped at the root, or\n            // these are args of a function call.\n            operand = evaluate(parenthetical, -1, fn, tail);\n          } else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\n            // has a left hand operator with a higher order of operation\n            left = op.bind(null, evaluate(parenthetical, -1, fn, tail));\n            op = null;\n            operand = '';\n          } else if (rStep > lStep && step === rStep) {\n            // should be applied to the right hand operator when it gets one\n            operand = evaluate(parenthetical, -1, fn, tail);\n          } else {\n            operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`;\n          }\n          parenthetical = '';\n        } else {\n          parenthetical += char;\n        }\n      } else if (depth === 0 && (operation = getOp(symbols, char, p, expression))) {\n        if (p === 0) {\n          error(103, [operation, expression]);\n        }\n        // We identified the operator by looking ahead in the string, so we need\n        // our position to move past the operator\n        p += operation.length - 1;\n        if (p === expression.length - 1) {\n          error(104, [operation, expression]);\n        }\n        if (!op) {\n          // Bind the left hand operand\n          if (left) {\n            // In this case we've already parsed the left hand operator\n            op = operators[operation].bind(null, evaluate(left, step));\n            left = null;\n          } else {\n            op = operators[operation].bind(null, evaluate(operand, step));\n            operand = '';\n          }\n        } else if (operand) {\n          // Bind the right hand operand, and return the resulting expression as a new left hand operator\n          left = op.bind(null, evaluate(operand, step));\n          op = operators[operation].bind(null, left);\n          operand = '';\n        }\n        continue;\n      } else {\n        addTo(depth, char);\n      }\n    }\n    if (operand && op) {\n      // If we were left with an operand after the loop, and an op, it should\n      // be the right hand assignment.\n      op = op.bind(null, evaluate(operand, step));\n    }\n    // If we don't have an op, but we do have a left hand assignment, then that\n    // is actually our operator, so just re-assign it to op\n    op = !op && left ? left : op;\n    if (!op && operand) {\n      // If we don't have any op but we do have an operand so there is no boolean\n      // logic to perform, but that operand still means something so we need to\n      // evaluate it and return it as a function\n      op = (v, t) => {\n        return typeof v === 'function' ? v(t) : v;\n      };\n      op = op.bind(null, evaluate(operand, step));\n    }\n    if (!op && !operand) {\n      error(105, expression);\n    }\n    return op;\n  }\n  /**\n   * Given a string like '$name==bobby' evaluate it to true or false\n   * @param operand - A left or right boolean operand — usually conditions\n   * @param step - The current order of operation\n   * @param fnToken - The token (string) representation of a function being called\n   * @returns\n   */\n  function evaluate(operand, step, fnToken, tail //eslint-disable-line\n  ) {\n    if (fnToken) {\n      const fn = evaluate(fnToken, operatorRegistry.length);\n      let userFuncReturn;\n      // \"Tail calls\" are dot accessors after a function $foo().value. We need\n      // to compile tail calls, and then provide the function result to the\n      // exposed tokens.\n      let tailCall = tail ? compile(`$${tail}`) : false;\n      if (typeof fn === 'function') {\n        const args = parseArgs(String(operand)).map(arg => evaluate(arg, -1));\n        return tokens => {\n          const userFunc = fn(tokens);\n          if (typeof userFunc !== 'function') {\n            warn(150, fnToken);\n            return userFunc;\n          }\n          userFuncReturn = userFunc(...args.map(arg => typeof arg === 'function' ? arg(tokens) : arg));\n          if (tailCall) {\n            tailCall = tailCall.provide(subTokens => {\n              const rootTokens = provideTokens(subTokens);\n              const t = subTokens.reduce((tokenSet, token) => {\n                const isTail = token === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token}(`));\n                if (isTail) {\n                  const value = getAt(userFuncReturn, token);\n                  tokenSet[token] = () => value;\n                } else {\n                  tokenSet[token] = rootTokens[token];\n                }\n                return tokenSet;\n              }, {});\n              return t;\n            });\n          }\n          return tailCall ? tailCall() : userFuncReturn;\n        };\n      }\n    } else if (typeof operand === 'string') {\n      // the word true or false will never contain further operations\n      if (operand === 'true') return true;\n      if (operand === 'false') return false;\n      if (operand === 'undefined') return undefined;\n      // Truly quotes strings cannot contain an operation, return the string\n      if (isQuotedString(operand)) return rmEscapes(operand.substring(1, operand.length - 1));\n      // Actual numbers cannot be contain an operation\n      if (!isNaN(+operand)) return Number(operand);\n      if (step < operatorRegistry.length - 1) {\n        return parseLogicals(operand, step + 1);\n      } else {\n        if (operand.startsWith('$')) {\n          const cleaned = operand.substring(1);\n          requirements.add(cleaned);\n          return function getToken(tokens) {\n            return cleaned in tokens ? tokens[cleaned]() : undefined;\n          };\n        }\n        // In this case we are dealing with an unquoted string, just treat it\n        // as a plain string.\n        return operand;\n      }\n    }\n    return operand;\n  }\n  /**\n   * Compile the string.\n   */\n  const compiled = parseLogicals(expr.startsWith('$:') ? expr.substring(2) : expr);\n  /**\n   * Convert compiled requirements to an array.\n   */\n  const reqs = Array.from(requirements);\n  /**\n   * Provides token values via callback to compiled output.\n   * @param callback - A callback that needs to provide all token requirements\n   * @returns\n   */\n  function provide(callback) {\n    provideTokens = callback;\n    return Object.assign(compiled.bind(null, callback(reqs)), {\n      provide\n    });\n  }\n  return Object.assign(compiled, {\n    provide\n  });\n}\n\n/**\n * Function that produces a standardized object representation of CSS classes.\n *\n * @param propertyKey - the section key.\n * @param node - A {@link FormKitNode | FormKitNode}.\n * @param sectionClassList - A `string | Record<string, boolean>` or a {@link FormKitClasses | FormKitClasses}.\n *\n * @returns `Record<string, boolean>`\n *\n * @public\n */\nfunction createClasses(propertyKey, node, sectionClassList) {\n  if (!sectionClassList) return {};\n  if (typeof sectionClassList === 'string') {\n    const classKeys = sectionClassList.split(' ');\n    return classKeys.reduce((obj, key) => Object.assign(obj, {\n      [key]: true\n    }), {});\n  } else if (typeof sectionClassList === 'function') {\n    return createClasses(propertyKey, node, sectionClassList(node, propertyKey));\n  }\n  return sectionClassList;\n}\n/**\n * Combines multiple class lists into a single list.\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n * @param property - The property key to which the class list will be applied.\n * @param args - And array of `Record<string, boolean>` of CSS class list(s).\n *\n * @returns `string | null`\n *\n * @public\n */\nfunction generateClassList(node, property, ...args) {\n  const combinedClassList = args.reduce((finalClassList, currentClassList) => {\n    if (!currentClassList) return handleNegativeClasses(finalClassList);\n    const {\n      $reset,\n      ...classList\n    } = currentClassList;\n    if ($reset) {\n      return handleNegativeClasses(classList);\n    }\n    return handleNegativeClasses(Object.assign(finalClassList, classList));\n  }, {});\n  return Object.keys(node.hook.classes.dispatch({\n    property,\n    classes: combinedClassList\n  }).classes).filter(key => combinedClassList[key]).join(' ') || null;\n}\nfunction handleNegativeClasses(classList) {\n  const removalToken = '$remove:';\n  let hasNegativeClassValue = false;\n  const applicableClasses = Object.keys(classList).filter(className => {\n    if (classList[className] && className.startsWith(removalToken)) {\n      hasNegativeClassValue = true;\n    }\n    return classList[className];\n  });\n  if (applicableClasses.length > 1 && hasNegativeClassValue) {\n    const negativeClasses = applicableClasses.filter(className => className.startsWith(removalToken));\n    negativeClasses.map(negativeClass => {\n      const targetClass = negativeClass.substring(removalToken.length);\n      classList[targetClass] = false;\n      classList[negativeClass] = false;\n    });\n  }\n  return classList;\n}\n\n/**\n * Sets errors on a form, group, or input.\n *\n * @param id - The id of a form.\n * @param localErrors - The errors to set on the form or the form’s inputs in\n * the format of {@link ErrorMessages | ErrorMessages}.\n * @param childErrors - (optional) The errors to set on the form or the form’s\n * inputs in the format of {@link ErrorMessages | ErrorMessages}.\n *\n * @public\n */\nfunction setErrors(id, localErrors, childErrors) {\n  const node = getNode$1(id);\n  if (node) {\n    node.setErrors(localErrors, childErrors);\n  } else {\n    warn(651, id);\n  }\n}\n/**\n * Clears errors on the node and optionally its children.\n *\n * @param id - The id of the node you want to clear errors for.\n * @param clearChildren - Determines if the children of this node should have\n * their errors cleared.\n *\n * @public\n */\nfunction clearErrors(id, clearChildren = true) {\n  const node = getNode$1(id);\n  if (node) {\n    node.clearErrors(clearChildren);\n  } else {\n    warn(652, id);\n  }\n}\n\n/**\n * The official FormKit core library. This package is responsible for most of FormKit’s internal functionality.\n * You can read documentation specifically on how it works at formkit.com.\n *\n * You can add this package by using `npm install @formkit/core` or `yarn add @formkit/core`.\n *\n * @packageDocumentation\n */\n/**\n * The current version of FormKit at the time the package is published. Is replaced\n * as part of the publishing script.\n *\n * @internal\n */\nconst FORMKIT_VERSION = '0.16.4';\nexport { FORMKIT_VERSION, bfs, clearErrors, compile, createClasses, createConfig$1 as createConfig, createMessage, createNode, createValue, deregister, error, errorHandler, generateClassList, getNode$1 as getNode, isComponent, isConditional, isDOM, isList, isNode, isSugar, names, register, reset, resetCount, resetRegistry, setErrors, submitForm, sugar, use, useIndex, valueInserted, valueMoved, valueRemoved, warn, warningHandler, watchRegistry };","map":{"version":3,"names":["token","has","slugify","cloneAny","init","clone","camel","undefine","eq","kebab","dedupe","parseArgs","getAt","isQuotedString","rmEscapes","createDispatcher","middleware","currentIndex","use","dispatchable","push","dispatch","payload","current","explicitPayload","undefined","unshift","remove","index","indexOf","splice","createEmitter","listeners","Map","receipts","buffer","emitter","node","event","set","name","get","forEach","wrapper","origin","modifiers","includes","listener","bubble","on","eventName","split","receipt","off","_a","eventListeners","Array","isArray","filter","delete","pause","walk","child","_e","play","events","emit$1","context","_context","isNode","parent","_node","errorHandler","error","next","message","String","code","warningHandler","warning","result","console","warn","data","Error","createMessage","conf","m","blocking","key","meta","type","visible","value","localize","t","locale","config","storeTraps","apply","applyMessages","setMessage","removeMessage","filterMessages","reduce","reduceMessages","release","releaseBuffer","touch","touchMessages","createStore","_buffer","messages","_b","_m","_r","store","Proxy","args","_target","property","bind","Reflect","_t","prop","releaseMissed","messageStore","previous","props","e","Object","freeze","hook","emit","buffered","length","callback","_store","reducer","accumulator","_messageStore","clear","applied","Set","map","address","at","missed","createMessages","errors","sourceKey","make","source","autoClear","errorSet","misses","size","createLedger","ledger","n","count","createCounter","add","merge","settled","counterName","promise","Promise","resolve","unmerge","condition","increment","parseCondition","counter","sum","each","initial","post","r","delta","registry","reflected","register","id","deregister","getNode$1","resetRegistry","watchRegistry","configChange","usingFallback","createConfig$1","options","nodes","target","_add","_rm","rootConfig","submitForm","formElement","document","getElementById","HTMLFormElement","Event","cancelable","bubbles","dispatchEvent","clearState","reset","resetTo","input","finalInit","defaultConfig","delimiter","delay","rootClasses","useIndex","Symbol","valueRemoved","valueMoved","valueInserted","isList","arg","_value","__FKNode__","invalidSetter","traps","_c","trap","getContext","addChild","addProps","getAddress","getNode","clearErrors","clearErrors$1","calm","define","disturb","destroy","hydrate","getIndex","setIndex","eachChild","find","setParent","plugins","removeChild","root","getRoot","resetValue","resetConfig","setErrors","setErrors$1","submit","text","getName","walkTree","createTraps","entries","getter","setter","curryGetter","createHooks","hooks","_","nameCount","idCount","resetCount","names","children","named","assign","createName","createValue","async","validateInput","isSettled","_tmo","clearTimeout","setTimeout","commit","partial","from","isFrozen","insert","childValue","__init","_d","_resolve","definition","forceTypeProp","originalType","family","features","feature","attrs","_emit","attr","camelName","parentContext","listIndex","_property","childIndex","preserve","_rmn","stopIfFalse","createConfig","plugin","run","library","p","oldIndex","concat","locator","first","pointer","shift","c","select","selector","matches","match","action","argStr","trim","searchTerm","searcher","bfs","tree","searchValue","searchGoal","search","stack","localValue","parentVal","rootValue","didSet","fragment","isForm","localErrors","childErrors","clearChildErrors","defaultProps","createProps","isEmitting","originalValue","receiver","findDefinition","createContext","isCreated","nodeInit","_n","createNode","ops","isDOM","isComponent","isConditional","isSugar","sugar","$el","$formkit","for","iterator","if","$cmp","compile","expr","provideTokens","requirements","x","expand","operand","tokens","operatorRegistry","&&","l","||","===","!==","==","!=",">=","<=",">","<","+","-","*","/","%","operatorSymbols","s","g","keys","operatorChars","charAt","getOp","symbols","char","expression","candidates","startsWith","symbol","nextChars","substring","getStep","direction","reversed","reverse","start","findIndex","slice","join","operators","getTail","pos","tail","depth","parseLogicals","step","quote","op","left","operation","lastChar","parenthetical","parenQuote","startP","addTo","fn","hasTail","lStep","rStep","evaluate","v","fnToken","userFuncReturn","tailCall","userFunc","provide","subTokens","rootTokens","tokenSet","isTail","isNaN","Number","cleaned","getToken","compiled","reqs","createClasses","propertyKey","sectionClassList","classKeys","obj","generateClassList","combinedClassList","finalClassList","currentClassList","handleNegativeClasses","$reset","classList","classes","removalToken","hasNegativeClassValue","applicableClasses","className","negativeClasses","negativeClass","targetClass","clearChildren","FORMKIT_VERSION"],"sources":["D:/VueJS/Form Validation with Formkit/node_modules/@formkit/core/dist/index.mjs"],"sourcesContent":["import { token, has, slugify, cloneAny, init, clone, camel, undefine, eq, kebab, dedupe, parseArgs, getAt, isQuotedString, rmEscapes } from '@formkit/utils';\n\n/**\n * Creates a new dispatcher that allows the addition/removal of middleware\n * functions, and the ability to dispatch a payload to all middleware.\n *\n * @returns FormKitDispatcher\n *\n * @internal\n */\nfunction createDispatcher() {\n    const middleware = [];\n    let currentIndex = 0;\n    const use = (dispatchable) => middleware.push(dispatchable);\n    const dispatch = (payload) => {\n        const current = middleware[currentIndex];\n        if (typeof current === 'function') {\n            return current(payload, (explicitPayload) => {\n                currentIndex++;\n                return dispatch(explicitPayload === undefined ? payload : explicitPayload);\n            });\n        }\n        currentIndex = 0;\n        return payload;\n    };\n    use.dispatch = dispatch;\n    use.unshift = (dispatchable) => middleware.unshift(dispatchable);\n    use.remove = (dispatchable) => {\n        const index = middleware.indexOf(dispatchable);\n        if (index > -1)\n            middleware.splice(index, 1);\n    };\n    return use;\n}\n\n/**\n * Creates a new event emitter, each node uses one of these to allow it to emit\n * events to local listeners and tree listeners.\n *\n * @returns FormKitEventEmitter\n *\n * @internal\n */\nfunction createEmitter() {\n    const listeners = new Map();\n    const receipts = new Map();\n    let buffer = undefined;\n    const emitter = (node, event) => {\n        if (buffer) {\n            buffer.set(event.name, [node, event]);\n            return;\n        }\n        if (listeners.has(event.name)) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            listeners.get(event.name).forEach((wrapper) => {\n                if (event.origin === node || wrapper.modifiers.includes('deep')) {\n                    wrapper.listener(event);\n                }\n            });\n        }\n        if (event.bubble) {\n            node.bubble(event);\n        }\n    };\n    /**\n     * Add an event listener\n     *\n     * @param eventName - The name of the event to listen to\n     * @param listener - The callback\n     *\n     * @returns string\n     *\n     * @internal\n     */\n    emitter.on = (eventName, listener) => {\n        const [event, ...modifiers] = eventName.split('.');\n        const receipt = listener.receipt || token();\n        const wrapper = {\n            modifiers,\n            event,\n            listener,\n            receipt,\n        };\n        /* eslint-disable @typescript-eslint/no-non-null-assertion */\n        listeners.has(event)\n            ? listeners.get(event).push(wrapper)\n            : listeners.set(event, [wrapper]);\n        receipts.has(receipt)\n            ? receipts.get(receipt).push(event)\n            : receipts.set(receipt, [event]);\n        /* eslint-enable @typescript-eslint/no-non-null-assertion */\n        return receipt;\n    };\n    /**\n     * Remove an event listener\n     *\n     * @param listenerOrReceipt - Either a receipt or the callback function.\n     *\n     * @internal\n     */\n    emitter.off = (receipt) => {\n        var _a;\n        if (receipts.has(receipt)) {\n            (_a = receipts.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {\n                const eventListeners = listeners.get(event);\n                if (Array.isArray(eventListeners)) {\n                    listeners.set(event, eventListeners.filter((wrapper) => wrapper.receipt !== receipt));\n                }\n            });\n            receipts.delete(receipt);\n        }\n    };\n    /**\n     * Pause emitting values. Any events emitted while paused will not be emitted\n     * but rather \"stored\" — and whichever events are emitted last will be output.\n     * For example:\n     * pause()\n     * emit('foo', 1)\n     * emit('foo', 2)\n     * emit('bar', 3)\n     * emit('bar', 4)\n     * play()\n     * // would result in\n     * emit('foo', 2)\n     * emit('bar', 4)\n     * Optionally pauses all children as well.\n     *\n     * @param node - A node to pause all children on.\n     *\n     * @internal\n     */\n    emitter.pause = (node) => {\n        if (!buffer)\n            buffer = new Map();\n        if (node) {\n            node.walk((child) => child._e.pause());\n        }\n    };\n    /**\n     * Release the current event buffer.\n     *\n     * @param node - A node to unpause all children on.\n     *\n     * @internal\n     */\n    emitter.play = (node) => {\n        if (!buffer)\n            return;\n        const events = buffer;\n        buffer = undefined;\n        events.forEach(([node, event]) => emitter(node, event));\n        if (node) {\n            node.walk((child) => child._e.play());\n        }\n    };\n    return emitter;\n}\n/**\n * Emit an event from this node.\n *\n * @param node - The node that is emitting\n * @param context - The context of that node\n * @param name - The name of the event\n * @param payload - The payload to emit\n *\n * @returns FormKitNode\n *\n * @internal\n */\nfunction emit$1(node, context, name, payload, // eslint-disable-line @typescript-eslint/explicit-module-boundary-types,\nbubble = true) {\n    context._e(node, {\n        payload,\n        name,\n        bubble,\n        origin: node,\n    });\n    return node;\n}\n/**\n * Send an event from the given node up it's ancestor tree.\n *\n * @param node -\n * @param _context -\n * @param event -\n *\n * @internal\n */\nfunction bubble(node, _context, event) {\n    if (isNode(node.parent)) {\n        node.parent._e(node.parent, event);\n    }\n    return node;\n}\n/**\n * Adds an event listener to the node for a specific event. The event name is a\n * simple string matching the name of the event to listen to. It can optionally\n * include modifiers like eventName.deep\n *\n * @param node -\n * @param context -\n * @param name -\n * @param listener -\n *\n * @returns FormKitNode\n *\n * @internal\n */\nfunction on(_node, context, name, listener) {\n    return context._e.on(name, listener);\n}\n/**\n * Removes an event listener from a node by the returned receipt from .on().\n *\n * @param node - The node to remote the listener from\n * @param context - The context to remove\n * @param receipt - The receipt returned by .on()\n *\n * @returns FormKitNode\n *\n * @internal\n */\nfunction off(node, context, receipt) {\n    context._e.off(receipt);\n    return node;\n}\n\n/**\n * FormKit's global error handler.\n *\n * @public\n */\nconst errorHandler = createDispatcher();\nerrorHandler((error, next) => {\n    if (!error.message)\n        error.message = String(`E${error.code}`);\n    return next(error);\n});\n/**\n * FormKit's global warning handler.\n *\n * @public\n */\nconst warningHandler = createDispatcher();\nwarningHandler((warning, next) => {\n    if (!warning.message)\n        warning.message = String(`W${warning.code}`);\n    const result = next(warning);\n    if (console && typeof console.warn === 'function')\n        console.warn(result.message);\n    return result;\n});\n/**\n * Globally emits a warning.\n *\n * @param code - The integer warning code.\n * @param data - Usually an object of information to include.\n *\n * @public\n */\nfunction warn(code, data = {}) {\n    warningHandler.dispatch({ code, data });\n}\n/**\n * Emits an error. Generally should result in an exception.\n *\n * @param code - The integer error code.\n * @param data - Usually an object of information to include.\n *\n * @public\n */\nfunction error(code, data = {}) {\n    throw Error(errorHandler.dispatch({ code, data }).message);\n}\n\n/**\n * Creates a new FormKitMessage object.\n *\n * @param conf - An object of optional properties of {@link FormKitMessage | FormKitMessage}.\n * @param node - A {@link @formkit/node#FormKitNode | FormKitNode}.\n *\n * @returns A {@link FormKitMessageProps | FormKitMessageProps}.\n *\n * @public\n */\nfunction createMessage(conf, node) {\n    const m = {\n        blocking: false,\n        key: token(),\n        meta: {},\n        type: 'state',\n        visible: true,\n        ...conf,\n    };\n    if (node && m.value && m.meta.localize !== false) {\n        m.value = node.t(m);\n        m.meta.locale = node.config.locale;\n    }\n    return m;\n}\n/**\n * The available traps on the node's store.\n *\n * @internal\n */\nconst storeTraps = {\n    apply: applyMessages,\n    set: setMessage,\n    remove: removeMessage,\n    filter: filterMessages,\n    reduce: reduceMessages,\n    release: releaseBuffer,\n    touch: touchMessages,\n};\n/**\n * Creates a new FormKit message store.\n *\n * @internal\n */\nfunction createStore(_buffer = false) {\n    const messages = {};\n    let node;\n    let buffer = _buffer;\n    let _b = [];\n    const _m = new Map();\n    let _r = undefined;\n    const store = new Proxy(messages, {\n        get(...args) {\n            const [_target, property] = args;\n            if (property === 'buffer')\n                return buffer;\n            if (property === '_b')\n                return _b;\n            if (property === '_m')\n                return _m;\n            if (property === '_r')\n                return _r;\n            if (has(storeTraps, property)) {\n                return storeTraps[property].bind(null, messages, store, node);\n            }\n            return Reflect.get(...args);\n        },\n        set(_t, prop, value) {\n            if (prop === '_n') {\n                node = value;\n                if (_r === '__n')\n                    releaseMissed(node, store);\n                return true;\n            }\n            else if (prop === '_b') {\n                _b = value;\n                return true;\n            }\n            else if (prop === 'buffer') {\n                buffer = value;\n                return true;\n            }\n            else if (prop === '_r') {\n                _r = value;\n                return true;\n            }\n            error(101, node);\n            return false;\n        },\n    });\n    return store;\n}\n/**\n * Adds a new value to a FormKit message bag.\n *\n * @param messageStore - The message store itself\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param message - The message object\n *\n * @internal\n */\nfunction setMessage(messageStore, store, node, message) {\n    if (store.buffer) {\n        store._b.push([[message]]);\n        return store;\n    }\n    if (messageStore[message.key] !== message) {\n        if (typeof message.value === 'string' && message.meta.localize !== false) {\n            // Expose the value to translation\n            const previous = message.value;\n            message.value = node.t(message);\n            if (message.value !== previous) {\n                message.meta.locale = node.props.locale;\n            }\n        }\n        const e = `message-${has(messageStore, message.key) ? 'updated' : 'added'}`;\n        messageStore[message.key] = Object.freeze(node.hook.message.dispatch(message));\n        node.emit(e, message);\n    }\n    return store;\n}\n/**\n * Run through each message in the store, and ensure it has been translated\n * to the proper language. This most frequently happens after a locale change.\n *\n * @internal\n */\nfunction touchMessages(messageStore, store) {\n    for (const key in messageStore) {\n        const message = { ...messageStore[key] };\n        store.set(message);\n    }\n}\n/**\n * Remove a message from the store.\n *\n * @param messageStore - The message store\n * @param store - The store interface\n * @param node - The node this store belongs to\n * @param key - The message key\n *\n * @returns FormKitStore\n *\n * @internal\n */\nfunction removeMessage(messageStore, store, node, key) {\n    if (has(messageStore, key)) {\n        const message = messageStore[key];\n        delete messageStore[key];\n        node.emit('message-removed', message);\n    }\n    if (store.buffer === true) {\n        store._b = store._b.filter((buffered) => {\n            buffered[0] = buffered[0].filter((m) => m.key !== key);\n            return buffered[1] || buffered[0].length;\n        });\n    }\n    return store;\n}\n/**\n * Iterates over all messages removing those that are no longer wanted.\n *\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n * @param callback - A callback accepting a message and returning a boolean\n * @param type - Pre filtered by a given message type\n *\n * @internal\n */\nfunction filterMessages(messageStore, store, node, callback, type) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        if ((!type || message.type === type) && !callback(message)) {\n            removeMessage(messageStore, store, node, key);\n        }\n    }\n}\n/**\n * Reduce the message store to some other generic value.\n *\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param _node - The node owner of this store\n * @param reducer - The callback that performs the reduction\n * @param accumulator - The initial value\n *\n * @returns\n *\n * @internal\n */\nfunction reduceMessages(messageStore, _store, _node, reducer, accumulator) {\n    for (const key in messageStore) {\n        const message = messageStore[key];\n        accumulator = reducer(accumulator, message);\n    }\n    return accumulator;\n}\n/**\n * @param messageStore - The store itself\n * @param _store - Unused but curried — the store interface itself\n * @param node - The node owner of this store\n * @param messages - An array of FormKitMessages to apply to this input, or an object of messages to apply to children.\n *\n * @internal\n */\nfunction applyMessages(_messageStore, store, node, messages, clear) {\n    if (Array.isArray(messages)) {\n        if (store.buffer) {\n            store._b.push([messages, clear]);\n            return;\n        }\n        // In this case we are applying messages to this node’s store.\n        const applied = new Set(messages.map((message) => {\n            store.set(message);\n            return message.key;\n        }));\n        // Remove any messages that were not part of the initial apply:\n        if (typeof clear === 'string') {\n            store.filter((message) => message.type !== clear || applied.has(message.key));\n        }\n        else if (typeof clear === 'function') {\n            store.filter((message) => !clear(message) || applied.has(message.key));\n        }\n    }\n    else {\n        for (const address in messages) {\n            const child = node.at(address);\n            if (child) {\n                child.store.apply(messages[address], clear);\n            }\n            else {\n                missed(node, store, address, messages[address], clear);\n            }\n        }\n    }\n}\n/**\n * Creates an array of message arrays from strings.\n *\n * @param node - FormKitNode\n * @param errors - Arrays or objects of form errors or input errors\n *\n * @internal\n */\nfunction createMessages(node, ...errors) {\n    const sourceKey = `${node.name}-set`;\n    const make = (error) => createMessage({\n        key: slugify(error),\n        type: 'error',\n        value: error,\n        meta: { source: sourceKey, autoClear: true },\n    });\n    return errors\n        .filter((m) => !!m)\n        .map((errorSet) => {\n        if (typeof errorSet === 'string')\n            errorSet = [errorSet];\n        if (Array.isArray(errorSet)) {\n            return errorSet.map((error) => make(error));\n        }\n        else {\n            const errors = {};\n            for (const key in errorSet) {\n                if (Array.isArray(errorSet[key])) {\n                    errors[key] = errorSet[key].map((error) => make(error));\n                }\n                else {\n                    errors[key] = [make(errorSet[key])];\n                }\n            }\n            return errors;\n        }\n    });\n}\n/**\n * @param store - The store to apply this missed applications.\n * @param address - The address that was missed (a node path that didn't yet exist)\n * @param messages - The messages that should have been applied.\n * @param clear - The clearing function (if any)\n *\n * @internal\n */\nfunction missed(node, store, address, messages, clear) {\n    var _a;\n    const misses = store._m;\n    if (!misses.has(address))\n        misses.set(address, []);\n    // The created receipt\n    if (!store._r)\n        store._r = releaseMissed(node, store);\n    (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages, clear]);\n}\n/**\n * Releases messages that were applied to a child via parent, but the child did\n * not exist. Once the child does exist, the created event for that child will\n * bubble to this point, and any stored applications will be applied serially.\n *\n * @param store - The store object.\n *\n * @internal\n */\nfunction releaseMissed(node, store) {\n    return node.on('child.deep', ({ payload: child }) => {\n        store._m.forEach((misses, address) => {\n            if (node.at(address) === child) {\n                misses.forEach(([messages, clear]) => {\n                    child.store.apply(messages, clear);\n                });\n                store._m.delete(address);\n            }\n        });\n        // If all the stored misses were applied, remove the listener.\n        if (store._m.size === 0 && store._r) {\n            node.off(store._r);\n            store._r = undefined;\n        }\n    });\n}\n/**\n * Iterates over all buffered messages and applies them in sequence.\n *\n * @param messageStore - The store itself\n * @param store - The store interface\n * @param node - The node to filter for\n *\n * @internal\n */\nfunction releaseBuffer(_messageStore, store) {\n    store.buffer = false;\n    store._b.forEach(([messages, clear]) => store.apply(messages, clear));\n    store._b = [];\n}\n\n/**\n * Creates a new ledger for use on a single node's context.\n *\n * @internal\n */\nfunction createLedger() {\n    const ledger = {};\n    let n;\n    return {\n        count: (...args) => createCounter(n, ledger, ...args),\n        init(node) {\n            n = node;\n            node.on('message-added.deep', add(ledger, 1));\n            node.on('message-removed.deep', add(ledger, -1));\n        },\n        merge: (child) => merge(n, ledger, child),\n        settled(counterName) {\n            return has(ledger, counterName)\n                ? ledger[counterName].promise\n                : Promise.resolve();\n        },\n        unmerge: (child) => merge(n, ledger, child, true),\n        value(counterName) {\n            return has(ledger, counterName) ? ledger[counterName].count : 0;\n        },\n    };\n}\n/**\n * Creates a new counter object in the counting ledger.\n *\n * @param node - FormKitNode\n * @param ledger - The actual ledger storage object\n * @param counterName - The name of the counter, can be arbitrary\n * @param condition - The condition function (or string) that filters messages\n * @param increment - The increment value\n *\n * @internal\n */\nfunction createCounter(node, ledger, counterName, condition, increment = 0) {\n    condition = parseCondition(condition || counterName);\n    if (!has(ledger, counterName)) {\n        const counter = {\n            condition,\n            count: 0,\n            name: counterName,\n            node,\n            promise: Promise.resolve(),\n            resolve: () => { }, // eslint-disable-line @typescript-eslint/no-empty-function\n        };\n        ledger[counterName] = counter;\n        increment = node.store.reduce((sum, m) => sum + counter.condition(m) * 1, increment);\n        node.each((child) => {\n            child.ledger.count(counter.name, counter.condition);\n            increment += child.ledger.value(counter.name);\n        });\n    }\n    return count(ledger[counterName], increment).promise;\n}\n/**\n * We parse the condition to allow flexibility in how counters are specified.\n *\n * @param condition - The condition that, if true, allows a message to change a counter's value\n *\n * @internal\n */\nfunction parseCondition(condition) {\n    if (typeof condition === 'function') {\n        return condition;\n    }\n    return (m) => m.type === condition;\n}\n/**\n * Perform a counting action on the a given counter object of the ledger.\n *\n * @param counter - A counter object\n * @param increment - The amount by which we are changing the count value\n *\n * @internal\n */\nfunction count(counter, increment) {\n    const initial = counter.count;\n    const post = counter.count + increment;\n    counter.count = post;\n    if (initial === 0 && post !== 0) {\n        counter.node.emit(`unsettled:${counter.name}`, counter.count, false);\n        counter.promise = new Promise((r) => (counter.resolve = r));\n    }\n    else if (initial !== 0 && post === 0) {\n        counter.node.emit(`settled:${counter.name}`, counter.count, false);\n        counter.resolve();\n    }\n    counter.node.emit(`count:${counter.name}`, counter.count, false);\n    return counter;\n}\n/**\n * Returns a function to be used as an event listener for message events.\n *\n * @param ledger - A ledger to operate on\n * @param delta - The amount to add or subtract\n *\n * @internal\n */\nfunction add(ledger, delta) {\n    return (e) => {\n        for (const name in ledger) {\n            const counter = ledger[name];\n            if (counter.condition(e.payload)) {\n                count(counter, delta);\n            }\n        }\n    };\n}\n/**\n * Given a child node, add the parent node's counters to the child and then\n * rectify the upstream ledger counts. Generally used when attaching a child\n * to an already counted tree.\n *\n * @param parent - The parent that is \"receiving\" the child\n * @param ledger - The ledger object\n * @param child - The child (can be a subtree) that is being attached\n * @param remove - If the merge is removing instead of adding\n *\n * @internal\n */\nfunction merge(parent, ledger, child, remove = false) {\n    for (const key in ledger) {\n        const condition = ledger[key].condition;\n        if (!remove)\n            child.ledger.count(key, condition);\n        const increment = child.ledger.value(key) * (remove ? -1 : 1);\n        if (!parent)\n            continue;\n        do {\n            parent.ledger.count(key, condition, increment);\n            parent = parent.parent;\n        } while (parent);\n    }\n}\n\n/**\n * A global registry of nodes by their alias or name (if root).\n */\nconst registry = new Map();\nconst reflected = new Map();\n/**\n * An event emitter for registered/set/unset nodes\n */\nconst emit = createEmitter();\n/**\n * Receipts of listeners.\n */\nconst receipts = [];\n/**\n * Registers a node to the registry _if_ the node is a root node, _or_ if the\n * node has an explicit node.props.alias. If these two things are not true,\n * then no node is registered (idempotent).\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nfunction register(node) {\n    if (node.props.id) {\n        registry.set(node.props.id, node);\n        reflected.set(node, node.props.id);\n        emit(node, {\n            payload: node,\n            name: node.props.id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Deregister a node from the registry.\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nfunction deregister(node) {\n    if (reflected.has(node)) {\n        const id = reflected.get(node); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        reflected.delete(node);\n        registry.delete(id);\n        emit(node, {\n            payload: null,\n            name: id,\n            bubble: false,\n            origin: node,\n        });\n    }\n}\n/**\n * Get a node by a particular id.\n *\n * @param id - Get a node by a given id.\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @public\n */\nfunction getNode$1(id) {\n    return registry.get(id);\n}\n/**\n * Resets the entire registry. Deregisters all nodes and removes all listeners.\n *\n * @public\n */\nfunction resetRegistry() {\n    registry.forEach((node) => {\n        deregister(node);\n    });\n    receipts.forEach((receipt) => emit.off(receipt));\n}\n/**\n * A way of watching changes in the global registry.\n *\n * @param id - A dot-syntax id where the node is located.\n * @param callback - A callback in the format of {@link FormKitEventListener | FormKitEventListener} to notify when the node is set or removed.\n *\n * @public\n */\nfunction watchRegistry(id, callback) {\n    // register a listener\n    receipts.push(emit.on(id, callback));\n}\n\n/**\n * Applies a given config change to the node.\n *\n * @param node - The node to check for config change\n * @param prop - Checks if this property exists in the local config or props\n * @param value - The value to set\n *\n * @internal\n */\nfunction configChange(node, prop, value) {\n    // When we return false, node.walk will not continue into that child.\n    let usingFallback = true;\n    !(prop in node.config._t)\n        ? node.emit(`config:${prop}`, value, false)\n        : (usingFallback = false);\n    if (!(prop in node.props)) {\n        node.emit('prop', { prop, value });\n        node.emit(`prop:${prop}`, value);\n    }\n    return usingFallback;\n}\n/**\n * Creates a new instance of a global configuration option. This object is\n * essentially just a FormKitOption object, but it can be used as the root for\n * FormKitConfig's proxy and retain event \"emitting\".\n *\n * @param options - An object of optional properties of {@link FormKitConfig | FormKitConfig}.\n *\n * @returns A {@link FormKitRootConfig | FormKitRootConfig}.\n *\n * @public\n */\nfunction createConfig$1(options = {}) {\n    const nodes = new Set();\n    const target = {\n        ...options,\n        ...{\n            _add: (node) => nodes.add(node),\n            _rm: (node) => nodes.delete(node),\n        },\n    };\n    const rootConfig = new Proxy(target, {\n        set(t, prop, value, r) {\n            if (typeof prop === 'string') {\n                nodes.forEach((node) => configChange(node, prop, value));\n            }\n            return Reflect.set(t, prop, value, r);\n        },\n    });\n    return rootConfig;\n}\n\n/**\n * Submits a FormKit form programmatically.\n *\n * @param id - The id of the form.\n *\n * @public\n */\nfunction submitForm(id) {\n    const formElement = document.getElementById(id);\n    if (formElement instanceof HTMLFormElement) {\n        const event = new Event('submit', { cancelable: true, bubbles: true });\n        formElement.dispatchEvent(event);\n        return;\n    }\n    warn(151, id);\n}\n\n/**\n * Clear all state and error messages.\n *\n * @internal\n */\nfunction clearState(node) {\n    const clear = (n) => {\n        for (const key in n.store) {\n            const message = n.store[key];\n            if (message.type === 'error' ||\n                (message.type === 'ui' && key === 'incomplete')) {\n                n.store.remove(key);\n            }\n            else if (message.type === 'state') {\n                n.store.set({ ...message, value: false });\n            }\n        }\n    };\n    clear(node);\n    node.walk(clear);\n}\n/**\n * Resets an input to its \"initial\" value. If the input is a group or list it\n * resets all the children as well.\n *\n * @param id - The id of an input to reset.\n * @param resetTo - A value to reset the node to.\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`.\n *\n * @public\n */\nfunction reset(id, resetTo) {\n    const node = typeof id === 'string' ? getNode$1(id) : id;\n    if (node) {\n        const initial = (n) => cloneAny(n.props.initial) ||\n            (n.type === 'group' ? {} : n.type === 'list' ? [] : undefined);\n        // pause all events in this tree.\n        node._e.pause(node);\n        // Set it back to basics\n        node.input(cloneAny(resetTo) || initial(node), false);\n        // Set children back to basics in case they were additive (had their own value for example)\n        node.walk((child) => child.input(initial(child), false));\n        // Finally we need to lay any values back on top (if it is a group/list) since group values\n        // take precedence over child values.\n        const finalInit = initial(node);\n        node.input(typeof finalInit === 'object'\n            ? cloneAny(resetTo) || init(finalInit)\n            : finalInit, false);\n        // release the events.\n        node._e.play(node);\n        clearState(node);\n        node.emit('reset', node);\n        return node;\n    }\n    warn(152, id);\n    return;\n}\n\n/**\n * Default configuration options.\n */\nconst defaultConfig = {\n    delimiter: '.',\n    delay: 0,\n    locale: 'en',\n    rootClasses: (key) => ({ [`formkit-${kebab(key)}`]: true }),\n};\n/**\n * If a node’s name is set to useIndex, it replaces the node’s name with the\n * index of the node relative to its parent’s children.\n *\n * @internal\n */\nconst useIndex = Symbol('index');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * removed.\n *\n * @internal\n */\nconst valueRemoved = Symbol('removed');\n/**\n * When propagating values up a tree, this value indicates the child should be\n * moved.\n *\n * @internal\n */\nconst valueMoved = Symbol('moved');\n/**\n * When creating a new node and having its value injected directly at a specific\n * location.\n *\n * @internal\n */\nconst valueInserted = Symbol('inserted');\n/**\n * A simple type guard to determine if the context being evaluated is a list\n * type.\n *\n * @param arg - A {@link FormKitContextShape | FormKitContextShape}.\n *\n * @returns Returns a `boolean`.\n *\n * @public\n */\nfunction isList(arg) {\n    return arg.type === 'list' && Array.isArray(arg._value);\n}\n/**\n * Determine if a given object is a node.\n *\n * @example\n *\n * ```javascript\n * import { isNode, createNode } from '@formkit/core'\n *\n * const input = createNode({\n *   type: 'input', // defaults to 'input' if not specified\n *   value: 'hello node world',\n * })\n *\n * const obj = {};\n *\n * isNode(obj)\n * // false\n *\n * isNode(input)\n * // true\n * ```\n *\n * @param node - Any value.\n *\n * @returns Returns a `boolean`.\n *\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction isNode(node) {\n    return node && typeof node === 'object' && node.__FKNode__ === true;\n}\n/**\n * The setter you are trying to access is invalid.\n */\nconst invalidSetter = (node, _context, property) => {\n    error(102, [node, property]);\n};\nconst traps = {\n    _c: trap(getContext, invalidSetter, false),\n    add: trap(addChild),\n    addProps: trap(addProps),\n    address: trap(getAddress, invalidSetter, false),\n    at: trap(getNode),\n    bubble: trap(bubble),\n    clearErrors: trap(clearErrors$1),\n    calm: trap(calm),\n    config: trap(false),\n    define: trap(define),\n    disturb: trap(disturb),\n    destroy: trap(destroy),\n    hydrate: trap(hydrate),\n    index: trap(getIndex, setIndex, false),\n    input: trap(input),\n    each: trap(eachChild),\n    emit: trap(emit$1),\n    find: trap(find),\n    on: trap(on),\n    off: trap(off),\n    parent: trap(false, setParent),\n    plugins: trap(false),\n    remove: trap(removeChild),\n    root: trap(getRoot, invalidSetter, false),\n    reset: trap(resetValue),\n    resetConfig: trap(resetConfig),\n    setErrors: trap(setErrors$1),\n    submit: trap(submit),\n    t: trap(text),\n    use: trap(use),\n    name: trap(getName, false, false),\n    walk: trap(walkTree),\n};\n/**\n * These are all the available \"traps\" for a given node. You can think of these\n * a little bit like methods, but they are really Proxy interceptors.\n */\nfunction createTraps() {\n    return new Map(Object.entries(traps));\n}\n/**\n * Creates a getter/setter trap and curries the context/node pair\n *\n * @param getter - The getter function\n * @param setter - The setter function\n * @param curryGetter - Indicates if the getter should be curried or not\n *\n * @returns A {@link FormKitTrap | FormKitTrap}\n */\nfunction trap(getter, setter, curryGetter = true) {\n    return {\n        get: getter\n            ? (node, context) => curryGetter\n                ? (...args) => getter(node, context, ...args)\n                : getter(node, context)\n            : false,\n        set: setter !== undefined ? setter : invalidSetter.bind(null),\n    };\n}\n/**\n * Create all of the node's hook dispatchers.\n */\nfunction createHooks() {\n    const hooks = new Map();\n    return new Proxy(hooks, {\n        get(_, property) {\n            if (!hooks.has(property)) {\n                hooks.set(property, createDispatcher());\n            }\n            return hooks.get(property);\n        },\n    });\n}\n/**\n * This is a simple integer counter of every createName() where the name needs\n * to be generated.\n */\nlet nameCount = 0;\n/**\n * This is a simple integer counter of every default id created.\n */\nlet idCount = 0;\n/**\n * Resets the global number of node registrations, useful for deterministic\n * node naming.\n *\n * @public\n */\nfunction resetCount() {\n    nameCount = 0;\n    idCount = 0;\n}\n/**\n * Create a name-based dictionary of all children in an array.\n *\n * @param children - An array of {@link FormKitNode | FormKitNode}.\n *\n * @returns A dictionary of named {@link FormKitNode | FormKitNode}.\n *\n * @public\n */\nfunction names(children) {\n    return children.reduce((named, child) => Object.assign(named, { [child.name]: child }), {});\n}\n/**\n * This node is responsible for deterministically generating an id for this\n * node. This cannot just be a random id, it _must_ be deterministic to ensure\n * re-hydration of the form (like post-SSR) produces the same names/ids.\n *\n * @param options - A {@link FormKitOptions | FormKitOptions}\n *\n * @returns `string | symbol`\n *\n * @internal\n */\nfunction createName(options) {\n    var _a, _b;\n    if (((_a = options.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return useIndex;\n    return options.name || `${((_b = options.props) === null || _b === void 0 ? void 0 : _b.type) || 'input'}_${++nameCount}`;\n}\n/**\n * Creates the initial value for a node based on the options passed in and the\n * type of the input.\n *\n * @param options - A {@link FormKitOptions | FormKitOptions}.\n *\n * @returns `unknown`\n *\n * @public\n */\nfunction createValue(options) {\n    if (options.type === 'group') {\n        return init(options.value &&\n            typeof options.value === 'object' &&\n            !Array.isArray(options.value)\n            ? options.value\n            : {});\n    }\n    else if (options.type === 'list') {\n        return init(Array.isArray(options.value) ? options.value : []);\n    }\n    return options.value;\n}\n/**\n * Sets the internal value of the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param value - A input value to the node\n * @param async - If its an async call\n *\n * @returns `Promise<unknown>`\n *\n * @internal\n */\nfunction input(node, context, value, async = true) {\n    context._value = validateInput(node, node.hook.input.dispatch(value));\n    node.emit('input', context._value);\n    if (context.isSettled)\n        node.disturb();\n    if (async) {\n        if (context._tmo)\n            clearTimeout(context._tmo);\n        context._tmo = setTimeout(commit, node.props.delay, node, context);\n    }\n    else {\n        commit(node, context);\n    }\n    return context.settled;\n}\n/**\n * Validate that the current input is allowed.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param value - The value that is being validated\n *\n * @returns `T`\n *\n * @internal\n */\nfunction validateInput(node, value) {\n    switch (node.type) {\n        // Inputs are allowed to have any type\n        case 'input':\n            break;\n        case 'group':\n            if (!value || typeof value !== 'object')\n                error(107, [node, value]);\n            break;\n        case 'list':\n            if (!Array.isArray(value))\n                error(108, [node, value]);\n            break;\n    }\n    return value;\n}\n/**\n * Commits the working value to the node graph as the value of this node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param calm - If it calms the node\n * @param hydrate - If it hydrates the node\n *\n * @internal\n */\nfunction commit(node, context, calm = true, hydrate = true) {\n    context._value = context.value = node.hook.commit.dispatch(context._value);\n    if (node.type !== 'input' && hydrate)\n        node.hydrate();\n    node.emit('commit', context.value);\n    if (calm)\n        node.calm();\n}\n/**\n * Perform a modification to a single element of a parent aggregate value. This\n * is only performed on the pre-committed value (_value), although typically\n * the value and _value are both linked in memory.\n *\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction partial(context, { name, value, from }) {\n    if (Object.isFrozen(context._value))\n        return;\n    if (isList(context)) {\n        const insert = value === valueRemoved\n            ? []\n            : value === valueMoved && typeof from === 'number'\n                ? context._value.splice(from, 1)\n                : [value];\n        context._value.splice(name, value === valueMoved || from === valueInserted ? 0 : 1, ...insert);\n        return;\n    }\n    // In this case we know for sure we're dealing with a group, TS doesn't\n    // know that however, so we use some unpleasant casting here\n    if (value !== valueRemoved) {\n        context._value[name] = value;\n    }\n    else {\n        delete context._value[name];\n    }\n}\n/**\n * Hydrate node and its children\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction hydrate(node, context) {\n    const _value = context._value;\n    context.children.forEach((child) => {\n        if (typeof _value !== 'object')\n            return;\n        // if (has(context._value as FormKitGroupValue, child.name)) {\n        if (child.name in _value) {\n            // In this case, the parent has a value to give to the child, so we\n            // perform a down-tree synchronous input which will cascade values down\n            // and then ultimately back up.\n            const childValue = child.type !== 'input' ||\n                (_value[child.name] && typeof _value[child.name] === 'object')\n                ? init(_value[child.name])\n                : _value[child.name];\n            child.input(childValue, false);\n        }\n        else {\n            if (node.type !== 'list' || typeof child.name === 'number') {\n                // In this case, the parent’s values have no knowledge of the child\n                // value — this typically occurs on the commit at the end of addChild()\n                // we need to create a value reservation for this node’s name. This is\n                // especially important when dealing with lists where index matters.\n                partial(context, { name: child.name, value: child.value });\n            }\n            if (!_value.__init) {\n                // In this case, someone has explicitly set the value to an empty object\n                // with node.input({}) so we do not define the __init property:\n                if (child.type === 'group')\n                    child.input({}, false);\n                else if (child.type === 'list')\n                    child.input([], false);\n                else\n                    child.input(undefined, false);\n            }\n        }\n    });\n    return node;\n}\n/**\n * Disturbs the state of a node from settled to unsettled — creating appropriate\n * promises and resolutions.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction disturb(node, context) {\n    var _a;\n    if (context._d <= 0) {\n        context.isSettled = false;\n        node.emit('settled', false, false);\n        context.settled = new Promise((resolve) => {\n            context._resolve = resolve;\n        });\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();\n    }\n    context._d++;\n    return node;\n}\n/**\n * Calms the given node's disturbed state by one.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param value - A {@link FormKitChildValue | FormKitChildValue}\n *\n * @internal\n */\nfunction calm(node, context, value) {\n    var _a;\n    if (value !== undefined && node.type !== 'input') {\n        partial(context, value);\n        // Commit the value up, but do not hydrate back down\n        return commit(node, context, true, false);\n    }\n    if (context._d > 0)\n        context._d--;\n    if (context._d === 0) {\n        context.isSettled = true;\n        node.emit('settled', true, false);\n        if (node.parent)\n            (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({ name: node.name, value: context.value });\n        if (context._resolve)\n            context._resolve(context.value);\n    }\n}\n/**\n * This node is being removed and needs to be cleaned up.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction destroy(node, context) {\n    node.emit('destroying', node);\n    // flush all messages out\n    node.store.filter(() => false);\n    if (node.parent) {\n        node.parent.emit('childRemoved', node);\n        node.parent.remove(node);\n    }\n    deregister(node);\n    context._value = context.value = undefined;\n    node.emit('destroyed', node);\n}\n/**\n * Defines the current input type concretely.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param definition - A {@link FormKitTypeDefinition | FormKitTypeDefinition}\n *\n * @internal\n */\nfunction define(node, context, definition) {\n    // Assign the type\n    context.type = definition.type;\n    // Assign the definition\n    context.props.definition = clone(definition);\n    // Ensure the type is seeded with the `__init` value.\n    context.value = context._value = createValue({\n        type: node.type,\n        value: context.value,\n    });\n    /**\n     * If the user has a typename defined, use it here.\n     */\n    if (definition.forceTypeProp) {\n        if (node.props.type)\n            node.props.originalType = node.props.type;\n        context.props.type = definition.forceTypeProp;\n    }\n    /**\n     * If the input is part of a family of inputs, add that prop.\n     */\n    if (definition.family) {\n        context.props.family = definition.family;\n    }\n    // Apply any input features before resetting the props.\n    if (definition.features) {\n        definition.features.forEach((feature) => feature(node));\n    }\n    // Its possible that input-defined \"props\" have ended up in the context attrs\n    // these should be moved back out of the attrs object.\n    if (definition.props) {\n        node.addProps(definition.props);\n    }\n    node.emit('defined', definition);\n}\n/**\n * Adds props to a given node by stripping them out of the node.props.attrs and\n * then adding them to the nodes.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param props - An array of prop strings (in camelCase!)\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction addProps(node, context, props) {\n    var _a;\n    if (node.props.attrs) {\n        const attrs = { ...node.props.attrs };\n        // Temporarily disable prop emits\n        node.props._emit = false;\n        for (const attr in attrs) {\n            const camelName = camel(attr);\n            if (props.includes(camelName)) {\n                node.props[camelName] = attrs[attr];\n                delete attrs[attr];\n            }\n        }\n        const initial = cloneAny(context._value);\n        node.props.initial =\n            node.type !== 'input' ? init(initial) : initial;\n        // Re-enable prop emits\n        node.props._emit = true;\n        node.props.attrs = attrs;\n        if (node.props.definition) {\n            node.props.definition.props = [\n                ...(((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.props) || []),\n                ...props,\n            ];\n        }\n    }\n    node.emit('added-props', props);\n    return node;\n}\n/**\n * Adds a child to the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A parent {@link FormKitContext | FormKitContext}\n * @param child - A {@link FormKitNode | FormKitNode}\n * @param listIndex - A index number to be added at\n *\n * @internal\n */\nfunction addChild(parent, parentContext, child, listIndex) {\n    if (parent.type === 'input')\n        error(100, parent);\n    if (child.parent && child.parent !== parent) {\n        child.parent.remove(child);\n    }\n    // Synchronously set the initial value on the parent\n    if (!parentContext.children.includes(child)) {\n        if (listIndex !== undefined && parent.type === 'list') {\n            // Inject the child:\n            parentContext.children.splice(listIndex, 0, child);\n            if (Array.isArray(parent.value) &&\n                parent.value.length < parentContext.children.length) {\n                // When adding an node or value to a list it is absolutely critical to\n                // know if, at the moment of injection, the parent’s value or the node\n                // children are the source of truth. For example, if a user pushes or\n                // splices a new value onto the lists’s array then we want to use that\n                // value as the value of the new node, but if a user adds a node to the\n                // list then we want the node’s value. In this specific case, we\n                // assume (due to length) that a new node was injected into the list, so\n                // we want that new node’s value injected into the parent list value.\n                parent.disturb().calm({\n                    name: listIndex,\n                    value: child.value,\n                    from: valueInserted,\n                });\n            }\n        }\n        else {\n            parentContext.children.push(child);\n        }\n        if (!child.isSettled)\n            parent.disturb();\n    }\n    if (child.parent !== parent) {\n        child.parent = parent;\n        // In this edge case middleware changed the parent assignment so we need to\n        // re-add the child\n        if (child.parent !== parent) {\n            parent.remove(child);\n            child.parent.add(child);\n            return parent;\n        }\n    }\n    else {\n        // When a parent is properly assigned, we inject the parent's plugins on the\n        // child.\n        child.use(parent.plugins);\n    }\n    // Finally we call commit here, which sub-calls hydrate(), hydrate() will\n    // resolve any conflict between the parent and child values, and also ensure\n    // proper \"placeholders\" are made on the parent.\n    commit(parent, parentContext, false);\n    parent.ledger.merge(child);\n    parent.emit('child', child);\n    return parent;\n}\n/**\n * The setter for node.parent = FormKitNode\n * @param child - A child {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param _property - A property to be setted\n * @param parent - A parent {@link FormKitNode | FormKitNode}\n *\n * @returns `boolean`\n *\n * @internal\n */\nfunction setParent(child, context, _property, parent) {\n    if (isNode(parent)) {\n        if (child.parent && child.parent !== parent) {\n            child.parent.remove(child);\n        }\n        context.parent = parent;\n        child.resetConfig();\n        !parent.children.includes(child)\n            ? parent.add(child)\n            : child.use(parent.plugins);\n        return true;\n    }\n    if (parent === null) {\n        context.parent = null;\n        return true;\n    }\n    return false;\n}\n/**\n * Removes a child from the node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param child - A child {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction removeChild(node, context, child) {\n    const childIndex = context.children.indexOf(child);\n    if (childIndex !== -1) {\n        if (child.isSettled)\n            node.disturb();\n        context.children.splice(childIndex, 1);\n        // If an ancestor uses the preserve prop, then we are expected to not remove\n        // our values on this node either, see #53\n        let preserve = undefine(child.props.preserve);\n        let parent = child.parent;\n        while (preserve === undefined && parent) {\n            preserve = undefine(parent.props.preserve);\n            parent = parent.parent;\n        }\n        if (!preserve) {\n            node.calm({\n                name: node.type === 'list' ? childIndex : child.name,\n                value: valueRemoved,\n            });\n        }\n        else {\n            node.calm();\n        }\n        child.parent = null;\n        // Remove the child from the config. Is this weird? Yes. Is it ok? Yes.\n        child.config._rmn = child;\n    }\n    node.ledger.unmerge(child);\n    return node;\n}\n/**\n * Iterate over each immediate child and perform a callback.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\n *\n * @internal\n */\nfunction eachChild(_node, context, callback) {\n    context.children.forEach((child) => callback(child));\n}\n/**\n * Walk all nodes below this one and execute a callback.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param callback - A {@link FormKitChildCallback | FormKitChildCallback}\n * @param stopIfFalse - Boolean to stop running on children\n *\n * @internal\n */\nfunction walkTree(_node, context, callback, stopIfFalse = false) {\n    context.children.forEach((child) => {\n        if (callback(child) !== false || !stopIfFalse) {\n            child.walk(callback, stopIfFalse);\n        }\n    });\n}\n/**\n * Set the configuration options of the node and it's subtree.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction resetConfig(node, context) {\n    const parent = node.parent || undefined;\n    context.config = createConfig(node.config._t, parent);\n    node.walk((n) => n.resetConfig());\n}\n/**\n * Adds a plugin to the node, its children, and executes it.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n * @param plugin -\n * {@link FormKitPlugin | FormKitPlugin}\n * {@link FormKitPlugin | FormKitPlugin[]}\n * {@link FormKitPlugin | Set<FormKitPlugin>}\n * @param run - If it will run on creation\n * @param library - If it will run on library creation\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction use(node, context, plugin, run = true, library = true) {\n    if (Array.isArray(plugin) || plugin instanceof Set) {\n        plugin.forEach((p) => use(node, context, p));\n        return node;\n    }\n    if (!context.plugins.has(plugin)) {\n        if (library && typeof plugin.library === 'function')\n            plugin.library(node);\n        // When plugins return false, they are never added as to the plugins Set\n        // meaning they only ever have access to the single node they were added on.\n        if (run && plugin(node) !== false) {\n            context.plugins.add(plugin);\n            node.children.forEach((child) => child.use(plugin));\n        }\n    }\n    return node;\n}\n/**\n * Moves a node in the parent’s children to the given index.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param _property - A property to add\n * @param setIndex - The index to move the node\n *\n * @internal\n */\nfunction setIndex(node, _context, _property, setIndex) {\n    if (isNode(node.parent)) {\n        const children = node.parent.children;\n        const index = setIndex >= children.length\n            ? children.length - 1\n            : setIndex < 0\n                ? 0\n                : setIndex;\n        const oldIndex = children.indexOf(node);\n        if (oldIndex === -1)\n            return false;\n        children.splice(oldIndex, 1);\n        children.splice(index, 0, node);\n        node.parent.children = children;\n        if (node.parent.type === 'list')\n            node.parent\n                .disturb()\n                .calm({ name: index, value: valueMoved, from: oldIndex });\n        return true;\n    }\n    return false;\n}\n/**\n * Retrieves the index of a node from the parent’s children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getIndex(node) {\n    if (node.parent) {\n        const index = [...node.parent.children].indexOf(node);\n        // If the index is currently -1 then the node isnt finished booting, so it\n        // must be the next node.\n        return index === -1 ? node.parent.children.length : index;\n    }\n    return -1;\n}\n/**\n * Retrieves the context object of a given node. This is intended to be a\n * private trap and should absolutely not be used in plugins or user-land code.\n *\n * @param _node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getContext(_node, context) {\n    return context;\n}\n/**\n * Get the name of the current node, allowing for slight mutations.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getName(node, context) {\n    var _a;\n    if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'list')\n        return node.index;\n    return context.name !== useIndex ? context.name : node.index;\n}\n/**\n * Returns the address of the current node.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param context - A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction getAddress(node, context) {\n    return context.parent\n        ? context.parent.address.concat([node.name])\n        : [node.name];\n}\n/**\n * Fetches a node from the tree by its address.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param locator - A string or {@link FormKitAddress | FormKitAddress} to find in the tree.\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getNode(node, _context, locator) {\n    const address = typeof locator === 'string' ? locator.split(node.config.delimiter) : locator;\n    if (!address.length)\n        return undefined;\n    const first = address[0];\n    let pointer = node.parent;\n    if (!pointer) {\n        // This address names the root node, remove it to get child name:\n        if (String(address[0]) === String(node.name))\n            address.shift();\n        // All root nodes start at themselves ultimately:\n        pointer = node;\n    }\n    // Any addresses starting with $parent should discard it\n    if (first === '$parent')\n        address.shift();\n    while (pointer && address.length) {\n        const name = address.shift();\n        switch (name) {\n            case '$root':\n                pointer = node.root;\n                break;\n            case '$parent':\n                pointer = pointer.parent;\n                break;\n            case '$self':\n                pointer = node;\n                break;\n            default:\n                pointer =\n                    pointer.children.find((c) => String(c.name) === String(name)) ||\n                        select(pointer, name);\n        }\n    }\n    return pointer || undefined;\n}\n/**\n * Perform selections on a subtree using the address \"selector\" methods.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param selector - A `string | number` to find in the node\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\n *\n * @internal\n */\nfunction select(node, selector) {\n    const matches = String(selector).match(/^(find)\\((.*)\\)$/);\n    if (matches) {\n        const [, action, argStr] = matches;\n        const args = argStr.split(',').map((arg) => arg.trim());\n        switch (action) {\n            case 'find':\n                return node.find(args[0], args[1]);\n            default:\n                return undefined;\n        }\n    }\n    return undefined;\n}\n/**\n * Perform a breadth first search and return the first instance of a node that\n * is found in the subtree or undefined.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param searchTerm - The term we are searching for\n * @param searcher - Either a key of {@link FormKitNode | FormKitNode}, or a {@link FormKitSearchFunction | FormKitSearchFunction}\n *\n * @returns A {@link FormKitNode | FormKitNode} or `undefined`\n *\n * @internal\n */\nfunction find(node, _context, searchTerm, searcher) {\n    return bfs(node, searchTerm, searcher);\n}\n/**\n * Perform a breadth-first search on a node subtree and locate the first\n * instance of a match.\n *\n * @param tree - A {@link FormKitNode | FormKitNode} to start from.\n * @param searchValue - A value to be searched.\n * @param searchGoal - A goal value.\n *\n * @returns A {@link FormKitNode | FormKitNode } or `undefined`.\n *\n * @public\n */\nfunction bfs(tree, searchValue, searchGoal = 'name') {\n    const search = typeof searchGoal === 'string'\n        ? (n) => n[searchGoal] == searchValue // non-strict comparison is intentional\n        : searchGoal;\n    const stack = [tree];\n    while (stack.length) {\n        const node = stack.shift(); // eslint-disable-line @typescript-eslint/no-non-null-assertion\n        if (search(node, searchValue))\n            return node;\n        stack.push(...node.children);\n    }\n    return undefined;\n}\n/**\n * Get the root node of the tree.\n *\n * @param n - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction getRoot(n) {\n    let node = n;\n    while (node.parent) {\n        node = node.parent;\n    }\n    return node;\n}\n/**\n * Creates a new configuration option.\n *\n * @param target - An object of optional properties of {@link FormKitConfig | FormKitConfig}\n * @param parent - A parent {@link FormKitNode | FormKitNode}\n *\n * @returns {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction createConfig(target = {}, parent) {\n    let node = undefined;\n    return new Proxy(target, {\n        get(...args) {\n            const prop = args[1];\n            if (prop === '_t')\n                return target;\n            const localValue = Reflect.get(...args);\n            // Check our local values first\n            if (localValue !== undefined)\n                return localValue;\n            // Then check our parent values next\n            if (parent) {\n                const parentVal = parent.config[prop];\n                if (parentVal !== undefined)\n                    return parentVal;\n            }\n            if (target.rootConfig && typeof prop === 'string') {\n                const rootValue = target.rootConfig[prop];\n                if (rootValue !== undefined)\n                    return rootValue;\n            }\n            // The default delay value should be 20\n            if (prop === 'delay' && (node === null || node === void 0 ? void 0 : node.type) === 'input')\n                return 20;\n            // Finally check the default values\n            return defaultConfig[prop];\n        },\n        set(...args) {\n            const prop = args[1];\n            const value = args[2];\n            if (prop === '_n') {\n                node = value;\n                if (target.rootConfig)\n                    target.rootConfig._add(node);\n                return true;\n            }\n            if (prop === '_rmn') {\n                if (target.rootConfig)\n                    target.rootConfig._rm(node);\n                node = undefined;\n                return true;\n            }\n            if (!eq(target[prop], value, false)) {\n                const didSet = Reflect.set(...args);\n                if (node) {\n                    node.emit(`config:${prop}`, value, false);\n                    configChange(node, prop, value);\n                    // Walk the node tree and notify of config/prop changes where relevant\n                    node.walk((n) => configChange(n, prop, value), true);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * Given a string of text, expose it for modification, translation, or full\n * replacement.\n\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param key - A {@link FormKitTextFragment | FormKitTextFragment}, or generic string of text\n * @param type - A string to represent the text type\n *\n * @returns `string`\n *\n * @internal\n */\nfunction text(node, _context, key, type = 'ui') {\n    const fragment = typeof key === 'string' ? { key, value: key, type } : key;\n    const value = node.hook.text.dispatch(fragment);\n    node.emit('text', value, false);\n    return value.value;\n}\n/**\n * Submits the nearest ancestor that is a FormKit \"form\". It determines which\n * node is a form by locating an ancestor where node.props.isForm = true.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction submit(node) {\n    const name = node.name;\n    do {\n        if (node.props.isForm === true)\n            break;\n        if (!node.parent)\n            error(106, name);\n        node = node.parent;\n    } while (node);\n    if (node.props.id) {\n        submitForm(node.props.id);\n    }\n}\n/**\n * Reset to the original value.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param value - The value to reset to\n *\n * @internal\n */\nfunction resetValue(node, _context, value) {\n    return reset(node, value);\n}\n/**\n * Sets errors on the node and optionally its children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param localErrors - An array of {@link ErrorMessages | ErrorMessages} to set on this node\n * @param childErrors - An object of name of {@link ErrorMessages | ErrorMessages} to set on children.\n *\n * @internal\n */\nfunction setErrors$1(node, _context, localErrors, childErrors) {\n    const sourceKey = `${node.name}-set`;\n    const errors = node.hook.setErrors.dispatch({ localErrors, childErrors });\n    createMessages(node, errors.localErrors, errors.childErrors).forEach((errors) => {\n        node.store.apply(errors, (message) => message.meta.source === sourceKey);\n    });\n    return node;\n}\n/**\n * Clears errors on the node and optionally its children.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param _context - A {@link FormKitContext | FormKitContext}\n * @param clearChildErrors - A boolean to clear children error or not.\n * @param sourceKey - The source key string to reset.\n *\n * @internal\n */\nfunction clearErrors$1(node, context, clearChildErrors = true, sourceKey) {\n    setErrors$1(node, context, []);\n    if (clearChildErrors) {\n        sourceKey = sourceKey || `${node.name}-set`;\n        node.walk((child) => {\n            child.store.filter((message) => {\n                return !(message.type === 'error' &&\n                    message.meta &&\n                    message.meta.source === sourceKey);\n            });\n        });\n    }\n    return node;\n}\n/**\n * Middleware to assign default prop values as issued by core.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction defaultProps(node) {\n    if (!has(node.props, 'id'))\n        node.props.id = `input_${idCount++}`;\n    return node;\n}\n/**\n * Create props based on initial values\n *\n * @param initial - An initial value to be transformed\n *\n * @internal\n */\nfunction createProps(initial) {\n    const props = {\n        initial: typeof initial === 'object' ? cloneAny(initial) : initial,\n    };\n    let node;\n    let isEmitting = true;\n    return new Proxy(props, {\n        get(...args) {\n            const [_t, prop] = args;\n            if (has(props, prop))\n                return Reflect.get(...args);\n            if (node && typeof prop === 'string' && node.config[prop] !== undefined)\n                return node.config[prop];\n            return undefined;\n        },\n        set(target, property, originalValue, receiver) {\n            if (property === '_n') {\n                node = originalValue;\n                return true;\n            }\n            if (property === '_emit') {\n                isEmitting = originalValue;\n                return true;\n            }\n            const { prop, value } = node.hook.prop.dispatch({\n                prop: property,\n                value: originalValue,\n            });\n            // Typescript compiler cannot handle a symbol index, even though js can:\n            if (!eq(props[prop], value, false) ||\n                typeof value === 'object') {\n                const didSet = Reflect.set(target, prop, value, receiver);\n                if (isEmitting) {\n                    node.emit('prop', { prop, value });\n                    if (typeof prop === 'string')\n                        node.emit(`prop:${prop}`, value);\n                }\n                return didSet;\n            }\n            return true;\n        },\n    });\n}\n/**\n * A cheap function that iterates over all plugins and stops once node.define\n * is called.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param plugins - An array of {@link FormKitPlugin | FormKitPlugin}\n *\n * @internal\n */\nfunction findDefinition(node, plugins) {\n    // If the definition is already there, force call to define.\n    if (node.props.definition)\n        return node.define(node.props.definition);\n    for (const plugin of plugins) {\n        if (node.props.definition)\n            return;\n        if (typeof plugin.library === 'function') {\n            plugin.library(node);\n        }\n    }\n}\n/**\n * Create a new context object for our a FormKit node, given default information\n *\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link FormKitContext | FormKitContext}\n *\n * @internal\n */\nfunction createContext(options) {\n    const value = createValue(options);\n    const config = createConfig(options.config || {}, options.parent);\n    return {\n        _d: 0,\n        _e: createEmitter(),\n        _resolve: false,\n        _tmo: false,\n        _value: value,\n        children: dedupe(options.children || []),\n        config,\n        hook: createHooks(),\n        isCreated: false,\n        isSettled: true,\n        ledger: createLedger(),\n        name: createName(options),\n        parent: options.parent || null,\n        plugins: new Set(),\n        props: createProps(value),\n        settled: Promise.resolve(value),\n        store: createStore(true),\n        traps: createTraps(),\n        type: options.type || 'input',\n        value,\n    };\n}\n/**\n * Initialize a node object's internal properties.\n *\n * @param node - A {@link FormKitNode | FormKitNode}\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link FormKitNode | FormKitNode}\n *\n * @internal\n */\nfunction nodeInit(node, options) {\n    var _a;\n    // Set the internal node on the props, config, ledger and store\n    node.ledger.init((node.store._n = node.props._n = node.config._n = node));\n    // Apply given in options to the node.\n    node.props._emit = false;\n    if (options.props)\n        Object.assign(node.props, options.props);\n    node.props._emit = true;\n    // Attempt to find a definition from the pre-existing plugins.\n    findDefinition(node, new Set([\n        ...(options.plugins || []),\n        ...(node.parent ? node.parent.plugins : []),\n    ]));\n    // Then we apply each plugin's root code, we do this with an explicit loop\n    // for that ity-bitty performance bump.\n    if (options.plugins) {\n        for (const plugin of options.plugins) {\n            use(node, node._c, plugin, true, false);\n        }\n    }\n    // Initialize the default props\n    defaultProps(node);\n    // Apply the parent to each child.\n    node.each((child) => node.add(child));\n    // If the node has a parent, ensure it's properly nested bi-directionally.\n    if (node.parent)\n        node.parent.add(node, options.index);\n    // Inputs are leafs, and cannot have children\n    if (node.type === 'input' && node.children.length)\n        error(100, node);\n    // Apply the input hook to the initial value.\n    input(node, node._c, node._value, false);\n    // Release the store buffer\n    node.store.release();\n    // Register the node globally if someone explicitly gave it an id\n    if ((_a = options.props) === null || _a === void 0 ? void 0 : _a.id)\n        register(node);\n    // Our node is finally ready, emit it to the world\n    node.emit('created', node);\n    node.isCreated = true;\n    return node;\n}\n/**\n * Creates a new instance of a FormKit Node. Nodes are the atomic unit of a FormKit graph.\n *\n * @example\n *\n * ```javascript\n * import { createNode } from '@formkit/core'\n *\n * const input = createNode({\n *   type: 'input', // defaults to 'input' if not specified\n *   value: 'hello node world',\n * })\n *\n * console.log(input.value)\n * // 'hello node world'\n * ```\n *\n * @param options - An options object of {@link FormKitOptions | FormKitOptions} to override the defaults.\n *\n * @returns A {@link @formkit/core#FormKitNode | FormKitNode}.\n *\n * @public\n */\nfunction createNode(options) {\n    const ops = options || {};\n    const context = createContext(ops);\n    // Note: The typing for the proxy object cannot be fully modeled, thus we are\n    // force-typing to a FormKitNode. See:\n    // https://github.com/microsoft/TypeScript/issues/28067\n    const node = new Proxy(context, {\n        get(...args) {\n            const [, property] = args;\n            if (property === '__FKNode__')\n                return true;\n            const trap = context.traps.get(property);\n            if (trap && trap.get)\n                return trap.get(node, context);\n            return Reflect.get(...args);\n        },\n        set(...args) {\n            const [, property, value] = args;\n            const trap = context.traps.get(property);\n            if (trap && trap.set)\n                return trap.set(node, context, property, value);\n            return Reflect.set(...args);\n        },\n    });\n    return nodeInit(node, ops);\n}\n\n/**\n * Type narrow that a node is a DOM node.\n *\n * @param node - A schema node to check\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isDOM(node) {\n    return typeof node !== 'string' && has(node, '$el');\n}\n/**\n * Type narrow that a node is a DOM node.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isComponent(node) {\n    return typeof node !== 'string' && has(node, '$cmp');\n}\n/**\n * Root declaration.\n *\n * @param node - An object to check.\n */\nfunction isConditional(node) {\n    if (!node || typeof node === 'string')\n        return false;\n    return has(node, 'if') && has(node, 'then');\n}\n/**\n * Determines if the node is syntactic sugar or not.\n *\n * @param node - A schema node to check.\n *\n * @returns `boolean`\n *\n * @public\n */\nfunction isSugar(node) {\n    return typeof node !== 'string' && '$formkit' in node;\n}\n/**\n * Converts syntactic sugar nodes to standard nodes.\n *\n * @param node - A node to covert.\n *\n * @returns A {@link FormKitSchemaNode | FormKitSchemaNode} without the properties of {@link FormKitSchemaFormKit | FormKitSchemaFormKit}.\n *\n * @public\n */\nfunction sugar(node) {\n    if (typeof node === 'string') {\n        return {\n            $el: 'text',\n            children: node,\n        };\n    }\n    if (isSugar(node)) {\n        const { $formkit: type, for: iterator, if: condition, children, bind, ...props } = node;\n        return Object.assign({\n            $cmp: 'FormKit',\n            props: { ...props, type },\n        }, condition ? { if: condition } : {}, iterator ? { for: iterator } : {}, children ? { children } : {}, bind ? { bind } : {});\n    }\n    return node;\n}\n\n/**\n * Compiles a logical string like `\"a != z || b == c\"` into a single function.\n * The return value is an object with a \"provide\" method that iterates over all\n * requirement tokens to use as replacements.\n *\n * @example\n *\n * ```typescript\n * let name = {\n *   value: 'jon'\n * }\n * const condition = compile(\"$name == 'bob'\").provide((token) => {\n *  return () => name.value // must return a function!\n * })\n *\n * condition() // false\n * ```\n *\n * @param expr - A string to compile.\n *\n * @returns A {@link FormKitCompilerOutput | FormKitCompilerOutput}.\n *\n * @public\n */\nfunction compile(expr) {\n    /**\n     * These tokens are replacements used in evaluating a given condition.\n     */\n    // const tokens: FormKitTokens = {}\n    /**\n     * The value of the provide() callback. Used for late binding.\n     */\n    let provideTokens;\n    /**\n     * These are token requirements like \"$name.value\" that are need to fulfill\n     * a given condition call.\n     */\n    const requirements = new Set();\n    /**\n     * Expands the current value if it is a function.\n     * @param operand - A left or right hand operand\n     * @returns\n     */\n    const x = function expand(operand, tokens) {\n        return typeof operand === 'function' ? operand(tokens) : operand;\n    };\n    /**\n     * Comprehensive list of operators. This list MUST be\n     * ordered by the length of the operator characters in descending order.\n     */\n    const operatorRegistry = [\n        {\n            '&&': (l, r, t) => x(l, t) && x(r, t),\n            '||': (l, r, t) => x(l, t) || x(r, t),\n        },\n        {\n            '===': (l, r, t) => !!(x(l, t) === x(r, t)),\n            '!==': (l, r, t) => !!(x(l, t) !== x(r, t)),\n            '==': (l, r, t) => !!(x(l, t) == x(r, t)),\n            '!=': (l, r, t) => !!(x(l, t) != x(r, t)),\n            '>=': (l, r, t) => !!(x(l, t) >= x(r, t)),\n            '<=': (l, r, t) => !!(x(l, t) <= x(r, t)),\n            '>': (l, r, t) => !!(x(l, t) > x(r, t)),\n            '<': (l, r, t) => !!(x(l, t) < x(r, t)),\n        },\n        {\n            '+': (l, r, t) => x(l, t) + x(r, t),\n            '-': (l, r, t) => x(l, t) - x(r, t),\n        },\n        {\n            '*': (l, r, t) => x(l, t) * x(r, t),\n            '/': (l, r, t) => x(l, t) / x(r, t),\n            '%': (l, r, t) => x(l, t) % x(r, t),\n        },\n    ];\n    /**\n     * A full list of all operator symbols.\n     */\n    const operatorSymbols = operatorRegistry.reduce((s, g) => {\n        return s.concat(Object.keys(g));\n    }, []);\n    /**\n     * An array of the first character of each operator.\n     */\n    const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)));\n    /**\n     * Determines if the current character is the start of an operator symbol, if it\n     * is, it returns that symbol.\n     * @param symbols - An array of symbols that are considered operators\n     * @param char - The current character being operated on\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @returns\n     */\n    function getOp(symbols, char, p, expression) {\n        const candidates = symbols.filter((s) => s.startsWith(char));\n        if (!candidates.length)\n            return false;\n        return candidates.find((symbol) => {\n            if (expression.length >= p + symbol.length) {\n                const nextChars = expression.substring(p, p + symbol.length);\n                if (nextChars === symbol)\n                    return symbol;\n            }\n            return false;\n        });\n    }\n    /**\n     * Determines the step number of the right or left hand operator.\n     * @param p - The position of the pointer\n     * @param expression - The full string expression\n     * @param direction - 1 = right, 0 = left\n     */\n    function getStep(p, expression, direction = 1) {\n        let next = direction\n            ? expression.substring(p + 1).trim()\n            : expression.substring(0, p).trim();\n        if (!next.length)\n            return -1;\n        if (!direction) {\n            // left hand direction could include a function name we need to remove\n            const reversed = next.split('').reverse();\n            const start = reversed.findIndex((char) => operatorChars.has(char));\n            next = reversed.slice(start).join('');\n        }\n        const char = next[0];\n        return operatorRegistry.findIndex((operators) => {\n            const symbols = Object.keys(operators);\n            return !!getOp(symbols, char, 0, next);\n        });\n    }\n    /**\n     * Extracts a tail call. For example:\n     * ```\n     * $foo().bar(baz) + 7\n     * ```\n     * Would extract \"bar(baz)\" and return p of 15 (after the (baz)).\n     *\n     * @param p - The position of a closing parenthetical.\n     * @param expression - The full expression being parsed.\n     */\n    function getTail(pos, expression) {\n        let tail = '';\n        const length = expression.length;\n        let depth = 0;\n        for (let p = pos; p < length; p++) {\n            const char = expression.charAt(p);\n            if (char === '(') {\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n            }\n            else if (depth === 0 && char === ' ') {\n                continue;\n            }\n            if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {\n                return [tail, p - 1];\n            }\n            else {\n                tail += char;\n            }\n        }\n        return [tail, expression.length - 1];\n    }\n    /**\n     * Parse a string expression into a function that returns a boolean. This is\n     * the magic behind schema logic like $if.\n     * @param expression - A string expression to parse\n     * @returns\n     */\n    function parseLogicals(expression, step = 0) {\n        const operators = operatorRegistry[step];\n        const length = expression.length;\n        const symbols = Object.keys(operators);\n        let depth = 0;\n        let quote = false;\n        let op = null;\n        let operand = '';\n        let left = null;\n        let operation;\n        let lastChar = '';\n        let char = '';\n        let parenthetical = '';\n        let parenQuote = '';\n        let startP = 0;\n        const addTo = (depth, char) => {\n            depth ? (parenthetical += char) : (operand += char);\n        };\n        for (let p = 0; p < length; p++) {\n            lastChar = char;\n            char = expression.charAt(p);\n            if ((char === \"'\" || char === '\"') &&\n                lastChar !== '\\\\' &&\n                ((depth === 0 && !quote) || (depth && !parenQuote))) {\n                if (depth) {\n                    parenQuote = char;\n                }\n                else {\n                    quote = char;\n                }\n                addTo(depth, char);\n                continue;\n            }\n            else if ((quote && (char !== quote || lastChar === '\\\\')) ||\n                (parenQuote && (char !== parenQuote || lastChar === '\\\\'))) {\n                addTo(depth, char);\n                continue;\n            }\n            else if (quote === char) {\n                quote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (parenQuote === char) {\n                parenQuote = false;\n                addTo(depth, char);\n                continue;\n            }\n            else if (char === ' ') {\n                continue;\n            }\n            else if (char === '(') {\n                if (depth === 0) {\n                    startP = p;\n                }\n                else {\n                    parenthetical += char;\n                }\n                depth++;\n            }\n            else if (char === ')') {\n                depth--;\n                if (depth === 0) {\n                    // Parenthetical statements cannot be grouped up in the implicit order\n                    // of left/right statements based on which step they are on because\n                    // they are parsed on every step and then must be applied to the\n                    // operator. Example:\n                    //\n                    // 5 + (3) * 2\n                    //\n                    // This should yield 11 not 16. This order is normally implicit in the\n                    // sequence of operators being parsed, but with parenthesis the parse\n                    // happens each time. Instead we need to know if the resulting value\n                    // should be applied to the left or the right hand operator. The\n                    // general algorithm is:\n                    //\n                    // 1. Does this paren have an operator on the left or right side\n                    // 2. If not, it's unnecessarily wrapped (3 + 2)\n                    // 3. If it does, then which order of operation is highest?\n                    // 4. Wait for the highest order of operation to bind to an operator.\n                    // If the parenthetical has a preceding token like $fn(1 + 2) then we\n                    // need to subtract the existing operand length from the start\n                    // to determine if this is a left or right operation\n                    const fn = typeof operand === 'string' && operand.startsWith('$')\n                        ? operand\n                        : undefined;\n                    const hasTail = fn && expression.charAt(p + 1) === '.';\n                    // It's possible the function has a chained tail call:\n                    let tail = '';\n                    if (hasTail) {\n                        [tail, p] = getTail(p + 2, expression);\n                    }\n                    const lStep = op ? step : getStep(startP, expression, 0);\n                    const rStep = getStep(p, expression);\n                    if (lStep === -1 && rStep === -1) {\n                        // This parenthetical was unnecessarily wrapped at the root, or\n                        // these are args of a function call.\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {\n                        // has a left hand operator with a higher order of operation\n                        left = op.bind(null, evaluate(parenthetical, -1, fn, tail));\n                        op = null;\n                        operand = '';\n                    }\n                    else if (rStep > lStep && step === rStep) {\n                        // should be applied to the right hand operator when it gets one\n                        operand = evaluate(parenthetical, -1, fn, tail);\n                    }\n                    else {\n                        operand += `(${parenthetical})${hasTail ? `.${tail}` : ''}`;\n                    }\n                    parenthetical = '';\n                }\n                else {\n                    parenthetical += char;\n                }\n            }\n            else if (depth === 0 &&\n                (operation = getOp(symbols, char, p, expression))) {\n                if (p === 0) {\n                    error(103, [operation, expression]);\n                }\n                // We identified the operator by looking ahead in the string, so we need\n                // our position to move past the operator\n                p += operation.length - 1;\n                if (p === expression.length - 1) {\n                    error(104, [operation, expression]);\n                }\n                if (!op) {\n                    // Bind the left hand operand\n                    if (left) {\n                        // In this case we've already parsed the left hand operator\n                        op = operators[operation].bind(null, evaluate(left, step));\n                        left = null;\n                    }\n                    else {\n                        op = operators[operation].bind(null, evaluate(operand, step));\n                        operand = '';\n                    }\n                }\n                else if (operand) {\n                    // Bind the right hand operand, and return the resulting expression as a new left hand operator\n                    left = op.bind(null, evaluate(operand, step));\n                    op = operators[operation].bind(null, left);\n                    operand = '';\n                }\n                continue;\n            }\n            else {\n                addTo(depth, char);\n            }\n        }\n        if (operand && op) {\n            // If we were left with an operand after the loop, and an op, it should\n            // be the right hand assignment.\n            op = op.bind(null, evaluate(operand, step));\n        }\n        // If we don't have an op, but we do have a left hand assignment, then that\n        // is actually our operator, so just re-assign it to op\n        op = !op && left ? left : op;\n        if (!op && operand) {\n            // If we don't have any op but we do have an operand so there is no boolean\n            // logic to perform, but that operand still means something so we need to\n            // evaluate it and return it as a function\n            op = (v, t) => {\n                return typeof v === 'function' ? v(t) : v;\n            };\n            op = op.bind(null, evaluate(operand, step));\n        }\n        if (!op && !operand) {\n            error(105, expression);\n        }\n        return op;\n    }\n    /**\n     * Given a string like '$name==bobby' evaluate it to true or false\n     * @param operand - A left or right boolean operand — usually conditions\n     * @param step - The current order of operation\n     * @param fnToken - The token (string) representation of a function being called\n     * @returns\n     */\n    function evaluate(operand, step, fnToken, tail //eslint-disable-line\n    ) {\n        if (fnToken) {\n            const fn = evaluate(fnToken, operatorRegistry.length);\n            let userFuncReturn;\n            // \"Tail calls\" are dot accessors after a function $foo().value. We need\n            // to compile tail calls, and then provide the function result to the\n            // exposed tokens.\n            let tailCall = tail\n                ? compile(`$${tail}`)\n                : false;\n            if (typeof fn === 'function') {\n                const args = parseArgs(String(operand)).map((arg) => evaluate(arg, -1));\n                return (tokens) => {\n                    const userFunc = fn(tokens);\n                    if (typeof userFunc !== 'function') {\n                        warn(150, fnToken);\n                        return userFunc;\n                    }\n                    userFuncReturn = userFunc(...args.map((arg) => typeof arg === 'function' ? arg(tokens) : arg));\n                    if (tailCall) {\n                        tailCall = tailCall.provide((subTokens) => {\n                            const rootTokens = provideTokens(subTokens);\n                            const t = subTokens.reduce((tokenSet, token) => {\n                                const isTail = token === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token}(`));\n                                if (isTail) {\n                                    const value = getAt(userFuncReturn, token);\n                                    tokenSet[token] = () => value;\n                                }\n                                else {\n                                    tokenSet[token] = rootTokens[token];\n                                }\n                                return tokenSet;\n                            }, {});\n                            return t;\n                        });\n                    }\n                    return tailCall ? tailCall() : userFuncReturn;\n                };\n            }\n        }\n        else if (typeof operand === 'string') {\n            // the word true or false will never contain further operations\n            if (operand === 'true')\n                return true;\n            if (operand === 'false')\n                return false;\n            if (operand === 'undefined')\n                return undefined;\n            // Truly quotes strings cannot contain an operation, return the string\n            if (isQuotedString(operand))\n                return rmEscapes(operand.substring(1, operand.length - 1));\n            // Actual numbers cannot be contain an operation\n            if (!isNaN(+operand))\n                return Number(operand);\n            if (step < operatorRegistry.length - 1) {\n                return parseLogicals(operand, step + 1);\n            }\n            else {\n                if (operand.startsWith('$')) {\n                    const cleaned = operand.substring(1);\n                    requirements.add(cleaned);\n                    return function getToken(tokens) {\n                        return cleaned in tokens ? tokens[cleaned]() : undefined;\n                    };\n                }\n                // In this case we are dealing with an unquoted string, just treat it\n                // as a plain string.\n                return operand;\n            }\n        }\n        return operand;\n    }\n    /**\n     * Compile the string.\n     */\n    const compiled = parseLogicals(expr.startsWith('$:') ? expr.substring(2) : expr);\n    /**\n     * Convert compiled requirements to an array.\n     */\n    const reqs = Array.from(requirements);\n    /**\n     * Provides token values via callback to compiled output.\n     * @param callback - A callback that needs to provide all token requirements\n     * @returns\n     */\n    function provide(callback) {\n        provideTokens = callback;\n        return Object.assign(compiled.bind(null, callback(reqs)), {\n            provide,\n        });\n    }\n    return Object.assign(compiled, {\n        provide,\n    });\n}\n\n/**\n * Function that produces a standardized object representation of CSS classes.\n *\n * @param propertyKey - the section key.\n * @param node - A {@link FormKitNode | FormKitNode}.\n * @param sectionClassList - A `string | Record<string, boolean>` or a {@link FormKitClasses | FormKitClasses}.\n *\n * @returns `Record<string, boolean>`\n *\n * @public\n */\nfunction createClasses(propertyKey, node, sectionClassList) {\n    if (!sectionClassList)\n        return {};\n    if (typeof sectionClassList === 'string') {\n        const classKeys = sectionClassList.split(' ');\n        return classKeys.reduce((obj, key) => Object.assign(obj, { [key]: true }), {});\n    }\n    else if (typeof sectionClassList === 'function') {\n        return createClasses(propertyKey, node, sectionClassList(node, propertyKey));\n    }\n    return sectionClassList;\n}\n/**\n * Combines multiple class lists into a single list.\n *\n * @param node - A {@link FormKitNode | FormKitNode}.\n * @param property - The property key to which the class list will be applied.\n * @param args - And array of `Record<string, boolean>` of CSS class list(s).\n *\n * @returns `string | null`\n *\n * @public\n */\nfunction generateClassList(node, property, ...args) {\n    const combinedClassList = args.reduce((finalClassList, currentClassList) => {\n        if (!currentClassList)\n            return handleNegativeClasses(finalClassList);\n        const { $reset, ...classList } = currentClassList;\n        if ($reset) {\n            return handleNegativeClasses(classList);\n        }\n        return handleNegativeClasses(Object.assign(finalClassList, classList));\n    }, {});\n    return Object.keys(node.hook.classes.dispatch({ property, classes: combinedClassList })\n        .classes)\n        .filter((key) => combinedClassList[key])\n        .join(' ') || null;\n}\nfunction handleNegativeClasses(classList) {\n    const removalToken = '$remove:';\n    let hasNegativeClassValue = false;\n    const applicableClasses = Object.keys(classList).filter((className) => {\n        if (classList[className] && className.startsWith(removalToken)) {\n            hasNegativeClassValue = true;\n        }\n        return classList[className];\n    });\n    if (applicableClasses.length > 1 && hasNegativeClassValue) {\n        const negativeClasses = applicableClasses.filter(className => className.startsWith(removalToken));\n        negativeClasses.map((negativeClass) => {\n            const targetClass = negativeClass.substring(removalToken.length);\n            classList[targetClass] = false;\n            classList[negativeClass] = false;\n        });\n    }\n    return classList;\n}\n\n/**\n * Sets errors on a form, group, or input.\n *\n * @param id - The id of a form.\n * @param localErrors - The errors to set on the form or the form’s inputs in\n * the format of {@link ErrorMessages | ErrorMessages}.\n * @param childErrors - (optional) The errors to set on the form or the form’s\n * inputs in the format of {@link ErrorMessages | ErrorMessages}.\n *\n * @public\n */\nfunction setErrors(id, localErrors, childErrors) {\n    const node = getNode$1(id);\n    if (node) {\n        node.setErrors(localErrors, childErrors);\n    }\n    else {\n        warn(651, id);\n    }\n}\n/**\n * Clears errors on the node and optionally its children.\n *\n * @param id - The id of the node you want to clear errors for.\n * @param clearChildren - Determines if the children of this node should have\n * their errors cleared.\n *\n * @public\n */\nfunction clearErrors(id, clearChildren = true) {\n    const node = getNode$1(id);\n    if (node) {\n        node.clearErrors(clearChildren);\n    }\n    else {\n        warn(652, id);\n    }\n}\n\n/**\n * The official FormKit core library. This package is responsible for most of FormKit’s internal functionality.\n * You can read documentation specifically on how it works at formkit.com.\n *\n * You can add this package by using `npm install @formkit/core` or `yarn add @formkit/core`.\n *\n * @packageDocumentation\n */\n/**\n * The current version of FormKit at the time the package is published. Is replaced\n * as part of the publishing script.\n *\n * @internal\n */\nconst FORMKIT_VERSION = '0.16.4';\n\nexport { FORMKIT_VERSION, bfs, clearErrors, compile, createClasses, createConfig$1 as createConfig, createMessage, createNode, createValue, deregister, error, errorHandler, generateClassList, getNode$1 as getNode, isComponent, isConditional, isDOM, isList, isNode, isSugar, names, register, reset, resetCount, resetRegistry, setErrors, submitForm, sugar, use, useIndex, valueInserted, valueMoved, valueRemoved, warn, warningHandler, watchRegistry };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}