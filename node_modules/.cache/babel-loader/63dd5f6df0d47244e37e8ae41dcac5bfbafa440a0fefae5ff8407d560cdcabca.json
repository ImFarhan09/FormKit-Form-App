{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { createMessage } from '@formkit/core';\nimport { createObserver, removeListeners, isKilled, applyListeners, diffDeps } from '@formkit/observer';\nimport { cloneAny, token, eq, empty, clone, has } from '@formkit/utils';\n\n/**\n * Message that gets set when the node is awaiting validation.\n */\nconst validatingMessage = createMessage({\n  type: 'state',\n  blocking: true,\n  visible: false,\n  value: true,\n  key: 'validating'\n});\n/**\n * The actual validation plugin function. Everything must be bootstrapped here.\n *\n * @param baseRules - Base validation rules to include in the plugin. By default,\n * FormKit makes all rules in the \\@formkit/rules package available via the\n * defaultConfig.\n *\n * @public\n */\nfunction createValidationPlugin(baseRules = {}) {\n  return function validationPlugin(node) {\n    let propRules = cloneAny(node.props.validationRules || {});\n    let availableRules = {\n      ...baseRules,\n      ...propRules\n    };\n    // create an observed node\n    let observedNode = createObserver(node);\n    const state = {\n      input: token(),\n      rerun: null,\n      isPassing: true\n    };\n    let validation = cloneAny(node.props.validation);\n    // If the node's validation props change, reboot:\n    node.on('prop:validation', ({\n      payload\n    }) => reboot(payload, availableRules));\n    node.on('prop:validationRules', ({\n      payload\n    }) => reboot(validation, payload));\n    /**\n     * Reboots the validation using new rules or declarations/intents.\n     * @param newValidation - New validation declaration to use\n     * @param newRules - New validation rules to use\n     * @returns\n     */\n    function reboot(newValidation, newRules) {\n      var _a;\n      if (eq(Object.keys(propRules || {}), Object.keys(newRules || {})) && eq(validation, newValidation)) return;\n      propRules = cloneAny(newRules);\n      validation = cloneAny(newValidation);\n      availableRules = {\n        ...baseRules,\n        ...propRules\n      };\n      // Destroy all observers that may re-trigger validation on an old stack\n      removeListeners(observedNode.receipts);\n      // Clear existing message observers\n      (_a = node.props.parsedRules) === null || _a === void 0 ? void 0 : _a.forEach(validation => {\n        var _a;\n        validation.messageObserver = (_a = validation.messageObserver) === null || _a === void 0 ? void 0 : _a.kill();\n      });\n      // Remove all existing messages before re-validating\n      node.store.filter(() => false, 'validation');\n      node.props.parsedRules = parseRules(newValidation, availableRules);\n      observedNode.kill();\n      observedNode = createObserver(node);\n      validate(observedNode, node.props.parsedRules, state);\n    }\n    // Validate the field when this plugin is initialized\n    node.props.parsedRules = parseRules(validation, availableRules);\n    validate(observedNode, node.props.parsedRules, state);\n  };\n}\n/**\n * Given parsed validations, a value and a node, run the validations and set\n * the appropriate store messages on the node.\n * @param value - The value being validated\n * @param node - The Node this value belongs to\n * @param rules - The rules\n */\nfunction validate(node, validations, state) {\n  if (isKilled(node)) return;\n  state.input = token();\n  state.isPassing = true;\n  node.store.filter(message => !message.meta.removeImmediately, 'validation');\n  validations.forEach(validation => validation.debounce && clearTimeout(validation.timer));\n  if (validations.length) {\n    node.store.set(validatingMessage);\n    run(0, validations, node, state, false, () => {\n      node.store.remove(validatingMessage.key);\n    });\n  }\n}\n/**\n * Runs validation rules recursively while collecting dependencies allowing for\n * cross-node validation rules that automatically re-trigger when a foreign\n * value is changed.\n * @param current - The index of the current validation rule\n * @param validations - The remaining validation rule stack to run\n * @param node - An observed node, the owner of this validation stack\n * @param state - An object of state information about this run\n * @param removeImmediately - Should messages created during this call be removed immediately when a new commit takes place?\n * @returns\n */\nfunction run(current, validations, node, state, removeImmediately, complete) {\n  const validation = validations[current];\n  if (!validation) return complete();\n  const currentRun = state.input;\n  validation.state = null;\n  function next(async, result) {\n    state.isPassing = state.isPassing && !!result;\n    validation.queued = false;\n    const newDeps = node.stopObserve();\n    applyListeners(node, diffDeps(validation.deps, newDeps), () => {\n      validation.queued = true;\n      if (state.rerun) clearTimeout(state.rerun);\n      state.rerun = setTimeout(validate, 0, node, validations, state);\n    });\n    validation.deps = newDeps;\n    if (state.input === currentRun) {\n      validation.state = result;\n      if (result === false) {\n        createFailedMessage(node, validation, removeImmediately || async);\n      } else {\n        removeMessage(node, validation);\n      }\n      if (validations.length > current + 1) {\n        run(current + 1, validations, node, state, removeImmediately || async, complete);\n      } else {\n        // The validation has completed\n        complete();\n      }\n    }\n  }\n  if ((!empty(node.value) || !validation.skipEmpty) && (state.isPassing || validation.force)) {\n    if (validation.queued) {\n      runRule(validation, node, result => {\n        result instanceof Promise ? result.then(r => next(true, r)) : next(false, result);\n      });\n    } else {\n      // In this case our rule is not queued, so literally nothing happened that\n      // would affect it, we just need to move past this rule and make no\n      // modifications to state\n      run(current + 1, validations, node, state, removeImmediately, complete);\n    }\n  } else {\n    // This rule is not being run because either:\n    //  1. The field is empty and this rule should not run when empty\n    //  2. A previous validation rule is failing and this one is not forced\n    // In this case we should call next validation.\n    if (empty(node.value) && validation.skipEmpty && state.isPassing) {\n      // This node has an empty value so its validation was skipped. So we\n      // need to queue it up, we do that by starting an observation and just\n      // touching the value attribute.\n      node.observe();\n      node.value;\n      // Because this validation rule is skipped when the node's value is empty\n      // so we keep the current value `state.isPassing` to the next rule execution\n      // if we pass null it will be typecasted to false and all following rules\n      // will be ignored including `required` rule which cause odds behavior\n      next(false, state.isPassing);\n    } else {\n      next(false, null);\n    }\n  }\n}\n/**\n * Run a validation rule debounced or not.\n * @param validation - A validation to debounce\n */\nfunction runRule(validation, node, after) {\n  if (validation.debounce) {\n    validation.timer = setTimeout(() => {\n      node.observe();\n      after(validation.rule(node, ...validation.args));\n    }, validation.debounce);\n  } else {\n    node.observe();\n    after(validation.rule(node, ...validation.args));\n  }\n}\n/**\n * The messages given to this function have already been set on the node, but\n * any other validation messages on the node that are not included in this\n * stack should be removed because they have been resolved.\n * @param node - The node to operate on.\n * @param messages - A new stack of messages\n */\nfunction removeMessage(node, validation) {\n  const key = `rule_${validation.name}`;\n  if (validation.messageObserver) {\n    validation.messageObserver = validation.messageObserver.kill();\n  }\n  if (has(node.store, key)) {\n    node.store.remove(key);\n  }\n}\n/**\n *\n * @param value - The value that is failing\n * @param validation - The validation object\n */\nfunction createFailedMessage(node, validation, removeImmediately) {\n  if (isKilled(node)) return;\n  if (!validation.messageObserver) {\n    validation.messageObserver = createObserver(node._node);\n  }\n  validation.messageObserver.watch(node => {\n    const i18nArgs = createI18nArgs(node, validation);\n    return i18nArgs;\n  }, i18nArgs => {\n    const customMessage = createCustomMessage(node, validation, i18nArgs);\n    // Here we short circuit the i18n system to force the output.\n    const message = createMessage({\n      blocking: validation.blocking,\n      key: `rule_${validation.name}`,\n      meta: {\n        /**\n         * Use this key instead of the message root key to produce i18n validation\n         * messages.\n         */\n        messageKey: validation.name,\n        /**\n         * For messages that were created *by or after* a debounced or async\n         * validation rule — we make note of it so we can immediately remove them\n         * as soon as the next commit happens.\n         */\n        removeImmediately,\n        /**\n         * Determines if this message should be passed to localization.\n         */\n        localize: !customMessage,\n        /**\n         * The arguments that will be passed to the validation rules\n         */\n        i18nArgs\n      },\n      type: 'validation',\n      value: customMessage || 'This field is not valid.'\n    });\n    node.store.set(message);\n  });\n}\n/**\n * Returns a custom validation message if applicable.\n * @param node - FormKit Node\n * @param validation - The validation rule being processed.\n */\nfunction createCustomMessage(node, validation, i18nArgs) {\n  const customMessage = node.props.validationMessages && has(node.props.validationMessages, validation.name) ? node.props.validationMessages[validation.name] : undefined;\n  if (typeof customMessage === 'function') {\n    return customMessage(...i18nArgs);\n  }\n  return customMessage;\n}\n/**\n * Creates the arguments passed to the i18n\n * @param node - The node that performed the validation\n * @param validation - The validation that failed\n */\nfunction createI18nArgs(node, validation) {\n  // If a custom message has been found, short circuit the i18n system.\n  return [{\n    node,\n    name: createMessageName(node),\n    args: validation.args\n  }];\n}\n/**\n * Given a node, this returns the name that should be used in validation\n * messages. This is either the `validationLabel` prop, the `label` prop, or\n * the name of the input (in that order).\n * @param node - The node to display\n * @returns\n * @public\n */\nfunction createMessageName(node) {\n  if (typeof node.props.validationLabel === 'function') {\n    return node.props.validationLabel(node);\n  }\n  return node.props.validationLabel || node.props.label || node.props.name || String(node.name);\n}\n/**\n * Describes hints, must also be changed in the debounceExtractor.\n */\nconst hintPattern = '(?:[\\\\*+?()0-9]+)';\n/**\n * A pattern to describe rule names. Rules names can only contain letters,\n * numbers, and underscores and must start with a letter.\n */\nconst rulePattern = '[a-zA-Z][a-zA-Z0-9_]+';\n/**\n * Regular expression for extracting rule data.\n */\nconst ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`, 'i');\n/**\n * Validation hints are special characters preceding a validation rule, like\n * !phone\n */\nconst hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, 'i');\n/**\n * Given a hint string like ^(200)? or ^? or (200)?^ extract the hints to\n * matches.\n */\nconst debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/;\n/**\n * Determines if a given string is in the proper debounce format.\n */\nconst hasDebounce = /\\(\\d+\\)/;\n/**\n * The default values of the available validation hints.\n */\nconst defaultHints = {\n  blocking: true,\n  debounce: 0,\n  force: false,\n  skipEmpty: true,\n  name: ''\n};\n/**\n * Parse validation intents and strings into validation rule stacks.\n * @param validation - Either a string a validation rules, or proper array of structured rules.\n * @internal\n */\nfunction parseRules(validation, rules) {\n  if (!validation) return [];\n  const intents = typeof validation === 'string' ? extractRules(validation) : clone(validation);\n  return intents.reduce((validations, args) => {\n    let rule = args.shift();\n    const hints = {};\n    if (typeof rule === 'string') {\n      const [ruleName, parsedHints] = parseHints(rule);\n      if (has(rules, ruleName)) {\n        rule = rules[ruleName];\n        Object.assign(hints, parsedHints);\n      }\n    }\n    if (typeof rule === 'function') {\n      validations.push({\n        rule,\n        args,\n        timer: 0,\n        state: null,\n        queued: true,\n        deps: new Map(),\n        ...defaultHints,\n        ...fnHints(hints, rule)\n      });\n    }\n    return validations;\n  }, []);\n}\n/**\n * A string of validation rules written in FormKitRule notation.\n * @param validation - The string of rules\n * @internal\n */\nfunction extractRules(validation) {\n  return validation.split('|').reduce((rules, rule) => {\n    const parsedRule = parseRule(rule);\n    if (parsedRule) {\n      rules.push(parsedRule);\n    }\n    return rules;\n  }, []);\n}\n/**\n * Given a rule like confirm:password_confirm produce a FormKitValidationIntent\n * @param rule - A string representing a validation rule.\n * @returns\n */\nfunction parseRule(rule) {\n  const trimmed = rule.trim();\n  if (trimmed) {\n    const matches = trimmed.match(ruleExtractor);\n    if (matches && typeof matches[1] === 'string') {\n      const ruleName = matches[1].trim();\n      const args = matches[2] && typeof matches[2] === 'string' ? matches[2].split(',').map(s => s.trim()) : [];\n      return [ruleName, ...args];\n    }\n  }\n  return false;\n}\n/**\n * Given a rule name, detect if there are any additional hints like !\n * @param ruleName - string representing a rule name\n * @returns\n */\nfunction parseHints(ruleName) {\n  const matches = ruleName.match(hintExtractor);\n  if (!matches) {\n    return [ruleName, {\n      name: ruleName\n    }];\n  }\n  const map = {\n    '*': {\n      force: true\n    },\n    '+': {\n      skipEmpty: false\n    },\n    '?': {\n      blocking: false\n    }\n  };\n  const [, hints, rule] = matches;\n  const hintGroups = hasDebounce.test(hints) ? hints.match(debounceExtractor) || [] : [, hints];\n  return [rule, [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints, group) => {\n    if (!group) return hints;\n    if (hasDebounce.test(group)) {\n      hints.debounce = parseInt(group.substr(1, group.length - 1));\n    } else {\n      group.split('').forEach(hint => has(map, hint) && Object.assign(hints, map[hint]));\n    }\n    return hints;\n  }, {\n    name: rule\n  })];\n}\n/**\n * Extracts hint properties from the validation rule function itself and applies\n * them if they are not already in the set of validation hints extracted from\n * strings.\n * @param existingHints - An existing set of hints already parsed\n * @param rule - The actual rule function, which can contain hint properties\n * @returns\n */\nfunction fnHints(existingHints, rule) {\n  if (!existingHints.name) {\n    existingHints.name = rule.ruleName || rule.name;\n  }\n  return ['skipEmpty', 'force', 'debounce', 'blocking'].reduce((hints, hint) => {\n    if (has(rule, hint) && !has(hints, hint)) {\n      Object.assign(hints, {\n        [hint]: rule[hint]\n      });\n    }\n    return hints;\n  }, existingHints);\n}\n/**\n * Extracts all validation messages from the given node and all its descendants.\n * This is not reactive and must be re-called each time the messages change.\n * @param node - The FormKit node to extract validation rules from — as well as its descendants.\n * @public\n */\nfunction getValidationMessages(node) {\n  const messages = new Map();\n  const extract = n => {\n    const nodeMessages = [];\n    for (const key in n.store) {\n      const message = n.store[key];\n      if (message.type === 'validation' && message.blocking && message.visible && typeof message.value === 'string') {\n        nodeMessages.push(message);\n      }\n    }\n    if (nodeMessages.length) {\n      messages.set(n, nodeMessages);\n    }\n    return n;\n  };\n  extract(node).walk(extract);\n  return messages;\n}\nexport { createMessageName, createValidationPlugin, getValidationMessages };","map":{"version":3,"names":["createMessage","createObserver","removeListeners","isKilled","applyListeners","diffDeps","cloneAny","token","eq","empty","clone","has","validatingMessage","type","blocking","visible","value","key","createValidationPlugin","baseRules","validationPlugin","node","propRules","props","validationRules","availableRules","observedNode","state","input","rerun","isPassing","validation","on","payload","reboot","newValidation","newRules","_a","Object","keys","receipts","parsedRules","forEach","messageObserver","kill","store","filter","parseRules","validate","validations","message","meta","removeImmediately","debounce","clearTimeout","timer","length","set","run","remove","current","complete","currentRun","next","async","result","queued","newDeps","stopObserve","deps","setTimeout","createFailedMessage","removeMessage","skipEmpty","force","runRule","Promise","then","r","observe","after","rule","args","name","_node","watch","i18nArgs","createI18nArgs","customMessage","createCustomMessage","messageKey","localize","validationMessages","undefined","createMessageName","validationLabel","label","String","hintPattern","rulePattern","ruleExtractor","RegExp","hintExtractor","debounceExtractor","hasDebounce","defaultHints","rules","intents","extractRules","reduce","shift","hints","ruleName","parsedHints","parseHints","assign","push","Map","fnHints","split","parsedRule","parseRule","trimmed","trim","matches","match","map","s","hintGroups","test","group","parseInt","substr","hint","existingHints","getValidationMessages","messages","extract","n","nodeMessages","walk"],"sources":["D:/VueJS/Form Validation with Formkit/node_modules/@formkit/validation/dist/index.mjs"],"sourcesContent":["import { createMessage } from '@formkit/core';\nimport { createObserver, removeListeners, isKilled, applyListeners, diffDeps } from '@formkit/observer';\nimport { cloneAny, token, eq, empty, clone, has } from '@formkit/utils';\n\n/**\n * Message that gets set when the node is awaiting validation.\n */\nconst validatingMessage = createMessage({\n    type: 'state',\n    blocking: true,\n    visible: false,\n    value: true,\n    key: 'validating',\n});\n/**\n * The actual validation plugin function. Everything must be bootstrapped here.\n *\n * @param baseRules - Base validation rules to include in the plugin. By default,\n * FormKit makes all rules in the \\@formkit/rules package available via the\n * defaultConfig.\n *\n * @public\n */\nfunction createValidationPlugin(baseRules = {}) {\n    return function validationPlugin(node) {\n        let propRules = cloneAny(node.props.validationRules || {});\n        let availableRules = { ...baseRules, ...propRules };\n        // create an observed node\n        let observedNode = createObserver(node);\n        const state = { input: token(), rerun: null, isPassing: true };\n        let validation = cloneAny(node.props.validation);\n        // If the node's validation props change, reboot:\n        node.on('prop:validation', ({ payload }) => reboot(payload, availableRules));\n        node.on('prop:validationRules', ({ payload }) => reboot(validation, payload));\n        /**\n         * Reboots the validation using new rules or declarations/intents.\n         * @param newValidation - New validation declaration to use\n         * @param newRules - New validation rules to use\n         * @returns\n         */\n        function reboot(newValidation, newRules) {\n            var _a;\n            if (eq(Object.keys(propRules || {}), Object.keys(newRules || {})) &&\n                eq(validation, newValidation))\n                return;\n            propRules = cloneAny(newRules);\n            validation = cloneAny(newValidation);\n            availableRules = { ...baseRules, ...propRules };\n            // Destroy all observers that may re-trigger validation on an old stack\n            removeListeners(observedNode.receipts);\n            // Clear existing message observers\n            (_a = node.props.parsedRules) === null || _a === void 0 ? void 0 : _a.forEach((validation) => {\n                var _a;\n                validation.messageObserver = (_a = validation.messageObserver) === null || _a === void 0 ? void 0 : _a.kill();\n            });\n            // Remove all existing messages before re-validating\n            node.store.filter(() => false, 'validation');\n            node.props.parsedRules = parseRules(newValidation, availableRules);\n            observedNode.kill();\n            observedNode = createObserver(node);\n            validate(observedNode, node.props.parsedRules, state);\n        }\n        // Validate the field when this plugin is initialized\n        node.props.parsedRules = parseRules(validation, availableRules);\n        validate(observedNode, node.props.parsedRules, state);\n    };\n}\n/**\n * Given parsed validations, a value and a node, run the validations and set\n * the appropriate store messages on the node.\n * @param value - The value being validated\n * @param node - The Node this value belongs to\n * @param rules - The rules\n */\nfunction validate(node, validations, state) {\n    if (isKilled(node))\n        return;\n    state.input = token();\n    state.isPassing = true;\n    node.store.filter((message) => !message.meta.removeImmediately, 'validation');\n    validations.forEach((validation) => validation.debounce && clearTimeout(validation.timer));\n    if (validations.length) {\n        node.store.set(validatingMessage);\n        run(0, validations, node, state, false, () => {\n            node.store.remove(validatingMessage.key);\n        });\n    }\n}\n/**\n * Runs validation rules recursively while collecting dependencies allowing for\n * cross-node validation rules that automatically re-trigger when a foreign\n * value is changed.\n * @param current - The index of the current validation rule\n * @param validations - The remaining validation rule stack to run\n * @param node - An observed node, the owner of this validation stack\n * @param state - An object of state information about this run\n * @param removeImmediately - Should messages created during this call be removed immediately when a new commit takes place?\n * @returns\n */\nfunction run(current, validations, node, state, removeImmediately, complete) {\n    const validation = validations[current];\n    if (!validation)\n        return complete();\n    const currentRun = state.input;\n    validation.state = null;\n    function next(async, result) {\n        state.isPassing = state.isPassing && !!result;\n        validation.queued = false;\n        const newDeps = node.stopObserve();\n        applyListeners(node, diffDeps(validation.deps, newDeps), () => {\n            validation.queued = true;\n            if (state.rerun)\n                clearTimeout(state.rerun);\n            state.rerun = setTimeout(validate, 0, node, validations, state);\n        });\n        validation.deps = newDeps;\n        if (state.input === currentRun) {\n            validation.state = result;\n            if (result === false) {\n                createFailedMessage(node, validation, removeImmediately || async);\n            }\n            else {\n                removeMessage(node, validation);\n            }\n            if (validations.length > current + 1) {\n                run(current + 1, validations, node, state, removeImmediately || async, complete);\n            }\n            else {\n                // The validation has completed\n                complete();\n            }\n        }\n    }\n    if ((!empty(node.value) || !validation.skipEmpty) &&\n        (state.isPassing || validation.force)) {\n        if (validation.queued) {\n            runRule(validation, node, (result) => {\n                result instanceof Promise\n                    ? result.then((r) => next(true, r))\n                    : next(false, result);\n            });\n        }\n        else {\n            // In this case our rule is not queued, so literally nothing happened that\n            // would affect it, we just need to move past this rule and make no\n            // modifications to state\n            run(current + 1, validations, node, state, removeImmediately, complete);\n        }\n    }\n    else {\n        // This rule is not being run because either:\n        //  1. The field is empty and this rule should not run when empty\n        //  2. A previous validation rule is failing and this one is not forced\n        // In this case we should call next validation.\n        if (empty(node.value) && validation.skipEmpty && state.isPassing) {\n            // This node has an empty value so its validation was skipped. So we\n            // need to queue it up, we do that by starting an observation and just\n            // touching the value attribute.\n            node.observe();\n            node.value;\n            // Because this validation rule is skipped when the node's value is empty\n            // so we keep the current value `state.isPassing` to the next rule execution\n            // if we pass null it will be typecasted to false and all following rules\n            // will be ignored including `required` rule which cause odds behavior\n            next(false, state.isPassing);\n        }\n        else {\n            next(false, null);\n        }\n    }\n}\n/**\n * Run a validation rule debounced or not.\n * @param validation - A validation to debounce\n */\nfunction runRule(validation, node, after) {\n    if (validation.debounce) {\n        validation.timer = setTimeout(() => {\n            node.observe();\n            after(validation.rule(node, ...validation.args));\n        }, validation.debounce);\n    }\n    else {\n        node.observe();\n        after(validation.rule(node, ...validation.args));\n    }\n}\n/**\n * The messages given to this function have already been set on the node, but\n * any other validation messages on the node that are not included in this\n * stack should be removed because they have been resolved.\n * @param node - The node to operate on.\n * @param messages - A new stack of messages\n */\nfunction removeMessage(node, validation) {\n    const key = `rule_${validation.name}`;\n    if (validation.messageObserver) {\n        validation.messageObserver = validation.messageObserver.kill();\n    }\n    if (has(node.store, key)) {\n        node.store.remove(key);\n    }\n}\n/**\n *\n * @param value - The value that is failing\n * @param validation - The validation object\n */\nfunction createFailedMessage(node, validation, removeImmediately) {\n    if (isKilled(node))\n        return;\n    if (!validation.messageObserver) {\n        validation.messageObserver = createObserver(node._node);\n    }\n    validation.messageObserver.watch((node) => {\n        const i18nArgs = createI18nArgs(node, validation);\n        return i18nArgs;\n    }, (i18nArgs) => {\n        const customMessage = createCustomMessage(node, validation, i18nArgs);\n        // Here we short circuit the i18n system to force the output.\n        const message = createMessage({\n            blocking: validation.blocking,\n            key: `rule_${validation.name}`,\n            meta: {\n                /**\n                 * Use this key instead of the message root key to produce i18n validation\n                 * messages.\n                 */\n                messageKey: validation.name,\n                /**\n                 * For messages that were created *by or after* a debounced or async\n                 * validation rule — we make note of it so we can immediately remove them\n                 * as soon as the next commit happens.\n                 */\n                removeImmediately,\n                /**\n                 * Determines if this message should be passed to localization.\n                 */\n                localize: !customMessage,\n                /**\n                 * The arguments that will be passed to the validation rules\n                 */\n                i18nArgs,\n            },\n            type: 'validation',\n            value: customMessage || 'This field is not valid.',\n        });\n        node.store.set(message);\n    });\n}\n/**\n * Returns a custom validation message if applicable.\n * @param node - FormKit Node\n * @param validation - The validation rule being processed.\n */\nfunction createCustomMessage(node, validation, i18nArgs) {\n    const customMessage = node.props.validationMessages &&\n        has(node.props.validationMessages, validation.name)\n        ? node.props.validationMessages[validation.name]\n        : undefined;\n    if (typeof customMessage === 'function') {\n        return customMessage(...i18nArgs);\n    }\n    return customMessage;\n}\n/**\n * Creates the arguments passed to the i18n\n * @param node - The node that performed the validation\n * @param validation - The validation that failed\n */\nfunction createI18nArgs(node, validation) {\n    // If a custom message has been found, short circuit the i18n system.\n    return [\n        {\n            node,\n            name: createMessageName(node),\n            args: validation.args,\n        },\n    ];\n}\n/**\n * Given a node, this returns the name that should be used in validation\n * messages. This is either the `validationLabel` prop, the `label` prop, or\n * the name of the input (in that order).\n * @param node - The node to display\n * @returns\n * @public\n */\nfunction createMessageName(node) {\n    if (typeof node.props.validationLabel === 'function') {\n        return node.props.validationLabel(node);\n    }\n    return (node.props.validationLabel ||\n        node.props.label ||\n        node.props.name ||\n        String(node.name));\n}\n/**\n * Describes hints, must also be changed in the debounceExtractor.\n */\nconst hintPattern = '(?:[\\\\*+?()0-9]+)';\n/**\n * A pattern to describe rule names. Rules names can only contain letters,\n * numbers, and underscores and must start with a letter.\n */\nconst rulePattern = '[a-zA-Z][a-zA-Z0-9_]+';\n/**\n * Regular expression for extracting rule data.\n */\nconst ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`, 'i');\n/**\n * Validation hints are special characters preceding a validation rule, like\n * !phone\n */\nconst hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, 'i');\n/**\n * Given a hint string like ^(200)? or ^? or (200)?^ extract the hints to\n * matches.\n */\nconst debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/;\n/**\n * Determines if a given string is in the proper debounce format.\n */\nconst hasDebounce = /\\(\\d+\\)/;\n/**\n * The default values of the available validation hints.\n */\nconst defaultHints = {\n    blocking: true,\n    debounce: 0,\n    force: false,\n    skipEmpty: true,\n    name: '',\n};\n/**\n * Parse validation intents and strings into validation rule stacks.\n * @param validation - Either a string a validation rules, or proper array of structured rules.\n * @internal\n */\nfunction parseRules(validation, rules) {\n    if (!validation)\n        return [];\n    const intents = typeof validation === 'string'\n        ? extractRules(validation)\n        : clone(validation);\n    return intents.reduce((validations, args) => {\n        let rule = args.shift();\n        const hints = {};\n        if (typeof rule === 'string') {\n            const [ruleName, parsedHints] = parseHints(rule);\n            if (has(rules, ruleName)) {\n                rule = rules[ruleName];\n                Object.assign(hints, parsedHints);\n            }\n        }\n        if (typeof rule === 'function') {\n            validations.push({\n                rule,\n                args,\n                timer: 0,\n                state: null,\n                queued: true,\n                deps: new Map(),\n                ...defaultHints,\n                ...fnHints(hints, rule),\n            });\n        }\n        return validations;\n    }, []);\n}\n/**\n * A string of validation rules written in FormKitRule notation.\n * @param validation - The string of rules\n * @internal\n */\nfunction extractRules(validation) {\n    return validation.split('|').reduce((rules, rule) => {\n        const parsedRule = parseRule(rule);\n        if (parsedRule) {\n            rules.push(parsedRule);\n        }\n        return rules;\n    }, []);\n}\n/**\n * Given a rule like confirm:password_confirm produce a FormKitValidationIntent\n * @param rule - A string representing a validation rule.\n * @returns\n */\nfunction parseRule(rule) {\n    const trimmed = rule.trim();\n    if (trimmed) {\n        const matches = trimmed.match(ruleExtractor);\n        if (matches && typeof matches[1] === 'string') {\n            const ruleName = matches[1].trim();\n            const args = matches[2] && typeof matches[2] === 'string'\n                ? matches[2].split(',').map((s) => s.trim())\n                : [];\n            return [ruleName, ...args];\n        }\n    }\n    return false;\n}\n/**\n * Given a rule name, detect if there are any additional hints like !\n * @param ruleName - string representing a rule name\n * @returns\n */\nfunction parseHints(ruleName) {\n    const matches = ruleName.match(hintExtractor);\n    if (!matches) {\n        return [ruleName, { name: ruleName }];\n    }\n    const map = {\n        '*': { force: true },\n        '+': { skipEmpty: false },\n        '?': { blocking: false },\n    };\n    const [, hints, rule] = matches;\n    const hintGroups = hasDebounce.test(hints)\n        ? hints.match(debounceExtractor) || []\n        : [, hints];\n    return [\n        rule,\n        [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints, group) => {\n            if (!group)\n                return hints;\n            if (hasDebounce.test(group)) {\n                hints.debounce = parseInt(group.substr(1, group.length - 1));\n            }\n            else {\n                group\n                    .split('')\n                    .forEach((hint) => has(map, hint) && Object.assign(hints, map[hint]));\n            }\n            return hints;\n        }, { name: rule }),\n    ];\n}\n/**\n * Extracts hint properties from the validation rule function itself and applies\n * them if they are not already in the set of validation hints extracted from\n * strings.\n * @param existingHints - An existing set of hints already parsed\n * @param rule - The actual rule function, which can contain hint properties\n * @returns\n */\nfunction fnHints(existingHints, rule) {\n    if (!existingHints.name) {\n        existingHints.name = rule.ruleName || rule.name;\n    }\n    return ['skipEmpty', 'force', 'debounce', 'blocking'].reduce((hints, hint) => {\n        if (has(rule, hint) && !has(hints, hint)) {\n            Object.assign(hints, {\n                [hint]: rule[hint],\n            });\n        }\n        return hints;\n    }, existingHints);\n}\n/**\n * Extracts all validation messages from the given node and all its descendants.\n * This is not reactive and must be re-called each time the messages change.\n * @param node - The FormKit node to extract validation rules from — as well as its descendants.\n * @public\n */\nfunction getValidationMessages(node) {\n    const messages = new Map();\n    const extract = (n) => {\n        const nodeMessages = [];\n        for (const key in n.store) {\n            const message = n.store[key];\n            if (message.type === 'validation' &&\n                message.blocking &&\n                message.visible &&\n                typeof message.value === 'string') {\n                nodeMessages.push(message);\n            }\n        }\n        if (nodeMessages.length) {\n            messages.set(n, nodeMessages);\n        }\n        return n;\n    };\n    extract(node).walk(extract);\n    return messages;\n}\n\nexport { createMessageName, createValidationPlugin, getValidationMessages };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}