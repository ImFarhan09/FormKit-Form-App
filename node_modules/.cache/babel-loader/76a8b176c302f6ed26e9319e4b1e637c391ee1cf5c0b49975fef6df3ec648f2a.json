{"ast":null,"code":"import { has } from '@formkit/utils';\nimport { isNode } from '@formkit/core';\n\n/**\n * FormKit Observer is a utility to wrap a FormKitNode in a dependency tracking observer proxy.\n *\n * @packageDocumentation\n */\n/**\n * A registry of all revoked observers.\n */\nconst revokedObservers = new WeakSet();\n/**\n * Creates the observer.\n * @param node - The {@link @formkit/core#FormKitNode | FormKitNode} to observe.\n * @param dependencies - The dependent nodes and the events that are required to\n * watch for changes.\n * @returns Returns a {@link @formkit/observer#FormKitObservedNode | FormKitObservedNode}.\n * @public\n */\nfunction createObserver(node, dependencies) {\n  // The dependencies touched during tracking\n  const deps = dependencies || Object.assign(new Map(), {\n    active: false\n  });\n  // A registry of event receipts returned by the event system\n  const receipts = new Map();\n  /**\n   * Simple function to add a dependency to the deps map.\n   * @param event - The name of the event type (like commit/input etc)\n   */\n  const addDependency = function (event) {\n    var _a;\n    if (!deps.active) return;\n    if (!deps.has(node)) deps.set(node, new Set());\n    (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);\n  };\n  /**\n   * Proxies the props of a node so we know which ones were messed with, could\n   * potentially be more generalized in the future if we want to support\n   * more sub-objects.\n   * @param props - The props object from a node\n   * @returns\n   */\n  const observeProps = function (props) {\n    return new Proxy(props, {\n      get(...args) {\n        typeof args[1] === 'string' && addDependency(`prop:${args[1]}`);\n        return Reflect.get(...args);\n      }\n    });\n  };\n  /**\n   * Observes the FormKit ledger \"value\".\n   * @param ledger - A formkit ledger counter.\n   */\n  const observeLedger = function (ledger) {\n    return new Proxy(ledger, {\n      get(...args) {\n        if (args[1] === 'value') {\n          return key => {\n            addDependency(`count:${key}`);\n            return ledger.value(key);\n          };\n        }\n        return Reflect.get(...args);\n      }\n    });\n  };\n  /**\n   * Return values from our observer proxy first pass through this function\n   * which gives us a chance to listen sub-dependencies and properties.\n   */\n  const observe = function (value, property) {\n    if (isNode(value)) {\n      return createObserver(value, deps);\n    }\n    if (property === 'value') addDependency('commit');\n    if (property === 'props') return observeProps(value);\n    if (property === 'ledger') return observeLedger(value);\n    return value;\n  };\n  /**\n   * The actual proxy object of the original node.\n   */\n  const {\n    proxy: observed,\n    revoke\n  } = Proxy.revocable(node, {\n    get(...args) {\n      switch (args[1]) {\n        case '_node':\n          return node;\n        case 'deps':\n          return deps;\n        case 'watch':\n          return (block, after) => watch(observed, block, after);\n        case 'observe':\n          return () => {\n            const old = new Map(deps);\n            deps.clear();\n            deps.active = true;\n            return old;\n          };\n        case 'stopObserve':\n          return () => {\n            const newDeps = new Map(deps);\n            deps.active = false;\n            return newDeps;\n          };\n        case 'receipts':\n          return receipts;\n        case 'kill':\n          return () => {\n            removeListeners(receipts);\n            revokedObservers.add(args[2]);\n            revoke();\n            return undefined;\n          };\n      }\n      const value = Reflect.get(...args);\n      // If we're dealing with a function, we need to sub-call the function\n      // get that return value, and pass it through the same logic.\n      if (typeof value === 'function') {\n        return (...subArgs) => {\n          const subValue = value(...subArgs);\n          return observe(subValue, args[1]);\n        };\n      }\n      return observe(value, args[1]);\n    }\n  });\n  return observed;\n}\n/**\n * Given two maps (`toAdd` and `toRemove`), apply the dependencies as event\n * listeners on the underlying nodes.\n * @param node - The node to apply dependencies to.\n * @param callback - The callback to add or remove.\n * @internal\n */\nfunction applyListeners(node, [toAdd, toRemove], callback) {\n  toAdd.forEach((events, depNode) => {\n    events.forEach(event => {\n      var _a;\n      node.receipts.has(depNode) || node.receipts.set(depNode, {});\n      node.receipts.set(depNode, Object.assign((_a = node.receipts.get(depNode)) !== null && _a !== void 0 ? _a : {}, {\n        [event]: depNode.on(event, callback)\n      }));\n    });\n  });\n  toRemove.forEach((events, depNode) => {\n    events.forEach(event => {\n      if (node.receipts.has(depNode)) {\n        const nodeReceipts = node.receipts.get(depNode);\n        if (nodeReceipts && has(nodeReceipts, event)) {\n          depNode.off(nodeReceipts[event]);\n          delete nodeReceipts[event];\n          node.receipts.set(depNode, nodeReceipts);\n        }\n      }\n    });\n  });\n}\n/**\n * Remove all the receipts from the observed node and subtree.\n * @param receipts - The FormKit observer receipts to remove.\n * @public\n */\nfunction removeListeners(receipts) {\n  receipts.forEach((events, node) => {\n    for (const event in events) {\n      node.off(events[event]);\n    }\n  });\n}\n/**\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\n * code when those dependencies are manipulated.\n * @param node - The node to observer\n * @param block - The block of code to observe\n * @public\n */\nfunction watch(node, block, after) {\n  const doAfterObservation = res => {\n    const newDeps = node.stopObserve();\n    applyListeners(node, diffDeps(oldDeps, newDeps), () => watch(node, block, after));\n    if (after) after(res);\n  };\n  const oldDeps = new Map(node.deps);\n  node.observe();\n  const res = block(node);\n  if (res instanceof Promise) res.then(val => doAfterObservation(val));else doAfterObservation(res);\n}\n/**\n * Determines which nodes should be added as dependencies and which should be\n * removed.\n * @param previous - The previous watcher dependencies.\n * @param current - The new/current watcher dependencies.\n * @returns A tuple of maps: `toAdd` and `toRemove`.\n * @public\n */\nfunction diffDeps(previous, current) {\n  const toAdd = new Map();\n  const toRemove = new Map();\n  current.forEach((events, node) => {\n    if (!previous.has(node)) {\n      toAdd.set(node, events);\n    } else {\n      const eventsToAdd = new Set();\n      const previousEvents = previous.get(node);\n      events.forEach(event => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));\n      toAdd.set(node, eventsToAdd);\n    }\n  });\n  previous.forEach((events, node) => {\n    if (!current.has(node)) {\n      toRemove.set(node, events);\n    } else {\n      const eventsToRemove = new Set();\n      const newEvents = current.get(node);\n      events.forEach(event => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));\n      toRemove.set(node, eventsToRemove);\n    }\n  });\n  return [toAdd, toRemove];\n}\n/**\n * Checks if the given node is revoked.\n * @param node - Any observed node to check.\n * @returns A `boolean` indicating if the node is revoked.\n * @public\n */\nfunction isKilled(node) {\n  return revokedObservers.has(node);\n}\nexport { applyListeners, createObserver, diffDeps, isKilled, removeListeners };","map":{"version":3,"names":["has","isNode","revokedObservers","WeakSet","createObserver","node","dependencies","deps","Object","assign","Map","active","receipts","addDependency","event","_a","set","Set","get","add","observeProps","props","Proxy","args","Reflect","observeLedger","ledger","key","value","observe","property","proxy","observed","revoke","revocable","block","after","watch","old","clear","newDeps","removeListeners","undefined","subArgs","subValue","applyListeners","toAdd","toRemove","callback","forEach","events","depNode","on","nodeReceipts","off","doAfterObservation","res","stopObserve","diffDeps","oldDeps","Promise","then","val","previous","current","eventsToAdd","previousEvents","eventsToRemove","newEvents","isKilled"],"sources":["D:/VueJS/Form Validation with Formkit/node_modules/@formkit/observer/dist/index.mjs"],"sourcesContent":["import { has } from '@formkit/utils';\nimport { isNode } from '@formkit/core';\n\n/**\n * FormKit Observer is a utility to wrap a FormKitNode in a dependency tracking observer proxy.\n *\n * @packageDocumentation\n */\n/**\n * A registry of all revoked observers.\n */\nconst revokedObservers = new WeakSet();\n/**\n * Creates the observer.\n * @param node - The {@link @formkit/core#FormKitNode | FormKitNode} to observe.\n * @param dependencies - The dependent nodes and the events that are required to\n * watch for changes.\n * @returns Returns a {@link @formkit/observer#FormKitObservedNode | FormKitObservedNode}.\n * @public\n */\nfunction createObserver(node, dependencies) {\n    // The dependencies touched during tracking\n    const deps = dependencies || Object.assign(new Map(), { active: false });\n    // A registry of event receipts returned by the event system\n    const receipts = new Map();\n    /**\n     * Simple function to add a dependency to the deps map.\n     * @param event - The name of the event type (like commit/input etc)\n     */\n    const addDependency = function (event) {\n        var _a;\n        if (!deps.active)\n            return;\n        if (!deps.has(node))\n            deps.set(node, new Set());\n        (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);\n    };\n    /**\n     * Proxies the props of a node so we know which ones were messed with, could\n     * potentially be more generalized in the future if we want to support\n     * more sub-objects.\n     * @param props - The props object from a node\n     * @returns\n     */\n    const observeProps = function (props) {\n        return new Proxy(props, {\n            get(...args) {\n                typeof args[1] === 'string' && addDependency(`prop:${args[1]}`);\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Observes the FormKit ledger \"value\".\n     * @param ledger - A formkit ledger counter.\n     */\n    const observeLedger = function (ledger) {\n        return new Proxy(ledger, {\n            get(...args) {\n                if (args[1] === 'value') {\n                    return (key) => {\n                        addDependency(`count:${key}`);\n                        return ledger.value(key);\n                    };\n                }\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Return values from our observer proxy first pass through this function\n     * which gives us a chance to listen sub-dependencies and properties.\n     */\n    const observe = function (value, property) {\n        if (isNode(value)) {\n            return createObserver(value, deps);\n        }\n        if (property === 'value')\n            addDependency('commit');\n        if (property === 'props')\n            return observeProps(value);\n        if (property === 'ledger')\n            return observeLedger(value);\n        return value;\n    };\n    /**\n     * The actual proxy object of the original node.\n     */\n    const { proxy: observed, revoke, } = Proxy.revocable(node, {\n        get(...args) {\n            switch (args[1]) {\n                case '_node':\n                    return node;\n                case 'deps':\n                    return deps;\n                case 'watch':\n                    return (block, after) => watch(observed, block, after);\n                case 'observe':\n                    return () => {\n                        const old = new Map(deps);\n                        deps.clear();\n                        deps.active = true;\n                        return old;\n                    };\n                case 'stopObserve':\n                    return () => {\n                        const newDeps = new Map(deps);\n                        deps.active = false;\n                        return newDeps;\n                    };\n                case 'receipts':\n                    return receipts;\n                case 'kill':\n                    return () => {\n                        removeListeners(receipts);\n                        revokedObservers.add(args[2]);\n                        revoke();\n                        return undefined;\n                    };\n            }\n            const value = Reflect.get(...args);\n            // If we're dealing with a function, we need to sub-call the function\n            // get that return value, and pass it through the same logic.\n            if (typeof value === 'function') {\n                return (...subArgs) => {\n                    const subValue = value(...subArgs);\n                    return observe(subValue, args[1]);\n                };\n            }\n            return observe(value, args[1]);\n        },\n    });\n    return observed;\n}\n/**\n * Given two maps (`toAdd` and `toRemove`), apply the dependencies as event\n * listeners on the underlying nodes.\n * @param node - The node to apply dependencies to.\n * @param callback - The callback to add or remove.\n * @internal\n */\nfunction applyListeners(node, [toAdd, toRemove], callback) {\n    toAdd.forEach((events, depNode) => {\n        events.forEach((event) => {\n            var _a;\n            node.receipts.has(depNode) || node.receipts.set(depNode, {});\n            node.receipts.set(depNode, Object.assign((_a = node.receipts.get(depNode)) !== null && _a !== void 0 ? _a : {}, {\n                [event]: depNode.on(event, callback),\n            }));\n        });\n    });\n    toRemove.forEach((events, depNode) => {\n        events.forEach((event) => {\n            if (node.receipts.has(depNode)) {\n                const nodeReceipts = node.receipts.get(depNode);\n                if (nodeReceipts && has(nodeReceipts, event)) {\n                    depNode.off(nodeReceipts[event]);\n                    delete nodeReceipts[event];\n                    node.receipts.set(depNode, nodeReceipts);\n                }\n            }\n        });\n    });\n}\n/**\n * Remove all the receipts from the observed node and subtree.\n * @param receipts - The FormKit observer receipts to remove.\n * @public\n */\nfunction removeListeners(receipts) {\n    receipts.forEach((events, node) => {\n        for (const event in events) {\n            node.off(events[event]);\n        }\n    });\n}\n/**\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\n * code when those dependencies are manipulated.\n * @param node - The node to observer\n * @param block - The block of code to observe\n * @public\n */\nfunction watch(node, block, after) {\n    const doAfterObservation = (res) => {\n        const newDeps = node.stopObserve();\n        applyListeners(node, diffDeps(oldDeps, newDeps), () => watch(node, block, after));\n        if (after)\n            after(res);\n    };\n    const oldDeps = new Map(node.deps);\n    node.observe();\n    const res = block(node);\n    if (res instanceof Promise)\n        res.then((val) => doAfterObservation(val));\n    else\n        doAfterObservation(res);\n}\n/**\n * Determines which nodes should be added as dependencies and which should be\n * removed.\n * @param previous - The previous watcher dependencies.\n * @param current - The new/current watcher dependencies.\n * @returns A tuple of maps: `toAdd` and `toRemove`.\n * @public\n */\nfunction diffDeps(previous, current) {\n    const toAdd = new Map();\n    const toRemove = new Map();\n    current.forEach((events, node) => {\n        if (!previous.has(node)) {\n            toAdd.set(node, events);\n        }\n        else {\n            const eventsToAdd = new Set();\n            const previousEvents = previous.get(node);\n            events.forEach((event) => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));\n            toAdd.set(node, eventsToAdd);\n        }\n    });\n    previous.forEach((events, node) => {\n        if (!current.has(node)) {\n            toRemove.set(node, events);\n        }\n        else {\n            const eventsToRemove = new Set();\n            const newEvents = current.get(node);\n            events.forEach((event) => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));\n            toRemove.set(node, eventsToRemove);\n        }\n    });\n    return [toAdd, toRemove];\n}\n/**\n * Checks if the given node is revoked.\n * @param node - Any observed node to check.\n * @returns A `boolean` indicating if the node is revoked.\n * @public\n */\nfunction isKilled(node) {\n    return revokedObservers.has(node);\n}\n\nexport { applyListeners, createObserver, diffDeps, isKilled, removeListeners };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}